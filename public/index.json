[{"authors":["Ben"],"categories":null,"content":"I am an Assistant Professor at Michigan State University in the Department of Economics and a faculty affiliate in the Social Science Data Analytics Program. Prior to coming to MSU, I was a Postdoctoral Research Fellow at Harvard University and a Visiting Scholar at Harvard Business School. My research focuses on the intersection of psychology and economics \u0026ndash; also known as behavioral economics \u0026ndash; and has appeared in the American Economic Review and Neuron. Prior to coming to Michigan State University, I worked with the U.S. Army to help soldiers become more psychologically resilient.\nI hold a Ph.D. in Social Science (Economics) from the California Institute of Technology (Caltech), and a B.S. in Economics from the University of Oregon.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1592849563,"objectID":"bf008f22d9b0754cde4f6972811c28b7","permalink":"https://ssc442kirkpatrick.netlify.app/authors/ben/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/ben/","section":"authors","summary":"I am an Assistant Professor at Michigan State University in the Department of Economics and a faculty affiliate in the Social Science Data Analytics Program. Prior to coming to MSU, I was a Postdoctoral Research Fellow at Harvard University and a Visiting Scholar at Harvard Business School. My research focuses on the intersection of psychology and economics \u0026ndash; also known as behavioral economics \u0026ndash; and has appeared in the American Economic Review and Neuron.","tags":null,"title":"Ben Bushong","type":"authors"},{"authors":["Justin"],"categories":null,"content":"I am an Assistant Professor at Michigan State University who has not yet filled out this description.\nI hold a Ph.D. in Environmental Economics from Duke University, an M.E.M. in Environmental Policy and Economics from Duke University, and a B.S. in Environmental Policy Analysis and City Planning from the University of California at Davis.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607463658,"objectID":"8422260f0f3251af15c00666a8df9838","permalink":"https://ssc442kirkpatrick.netlify.app/authors/justin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/justin/","section":"authors","summary":"I am an Assistant Professor at Michigan State University who has not yet filled out this description.\nI hold a Ph.D. in Environmental Economics from Duke University, an M.E.M. in Environmental Policy and Economics from Duke University, and a B.S. in Environmental Policy Analysis and City Planning from the University of California at Davis.","tags":null,"title":"Justin Kirkpatrick","type":"authors"},{"authors":null,"categories":null,"content":"\r\rWeekly Writings\r\rWeekly Writing Template\r\rLabs\r\rLab Template\r\rProjects\rFinal project\r\r\rThis course is the capstone of the Data Analytics Minor in the College of Social Science. Accordingly, you should—fingers crossed—enjoy data analysis. You will get the most of out this class if you:\nEngage with the readings and lecture materials\rRegularly use R (aka engage daily or almost every day in some way)\r\rEach type of assignment in this class helps with one of these strategies.\nDownload and save the following files (right-click to Save Link As…)\n\r Weekly writing template\n\r Lab assignment template\n\r\rWeekly Writings\rTo encourage you to actively engage with the course content, you will write a ≈150 word memorandum about the reading or lecture each week. That’s fairly short: there are ≈250 words on a typical double-spaced page. You must complete eleven of these in the course. I will drop your one lowest weekly writing score. Your actual prompt will be assigned in class, so you must login each day to ensure you get these assignments. To keep you on your toes, we will vary whether these are assigned on Tuesdays or Thursdays. Each week’s weekly writing will be due on D2L by 11:59pm on Saturday\nYou can do a lot of different things with this memo: discuss something you learned from the course content, write about the best or worst data visualization you saw recently, connect the course content to your own work, etc. These reflections let you explore and answer some of the key questions of this course, including:\n\rWhen is a link correlational vs causal? How can we still make useful statements about non-causal things?\rWhy do we visualize data?\rWhat makes a great data analysis? What makes a bad analysis?\rHow do you choose which kind of analysis method to use?\rWhat is the role of the data structure in choosing an analysis? Can we be flexible?\r\rThe course content for each day will also include a set of questions specific to that topic. You do not have to answer all (or any) of these questions. That would be impossible. They exist to guide your thinking and to make complex reading more digestible. The specific topic for each week will be assigned in class. (We can’t emphasize this enough.)\nThe TA will grade these mini-exercises using a very simple system:\n\r✔+: (9.2 points (115%) in gradebook) Work shows phenomenal thought and engagement with the course content. We will not assign these often.\r✔: (8 points (100%) in gradebook) Work is thoughtful, well-written, and shows engagement with the course content. This is the expected level of performance.\r✔−: (4 points (50%) in gradebook) Work is hastily composed, too short, and/or only cursorily engages with the course content. This grade signals that you need to improve next time. I will hopefully not assign these often.\r\r(There is an implicit 0 above for work that is not turned in by Saturday at 11:59pm). Notice that this is essentially a pass/fail or completion-based system. We’re not grading your writing ability; we’re not counting the exact number of words you’re writing; and we’re not looking for encyclopedic citations of every single reading to prove that you did indeed read everything. We are looking for thoughtful engagement. Read the material, engage with the work and you’ll get a ✓.\nWeekly Writing Template\rYou will turn these reflections in via D2L. You will write them using R Markdown and this weekly writing template (right-click to Save Link As…) . You must knit your work to a PDF document (this will be what you turn in). D2L will have eleven weekly writing assignments available. Upload your first weekly writing assignment to number 1, your second (regardless of which week you are writing on) to number 2, etc.\n\r\rLabs\rEach week of the course has fully annotated examples of code that teach and demonstrate how to do specific tasks in R. However, without practicing these principles and making graphics on your own, you won’t remember what you learn.\nPlease do not do labs more than one week ahead of time. I am updating the assignments as the semester proceeds, and you may do an entire assignment that is completely changed.\nFor example, to practice working with ggplot2 and making data-based graphics, you will complete a brief set of exercises over a few class sessions. These exercises will have 1–3 short tasks that are directly related to the topic for the week. You need to show that you made a good faith effort to work each question. There will also be a final question which requires significantly more thought and work. This will be where you get to show some creativity and stretch your abilities. Overall, labs will be graded the same check system:\n\r✔+: (17.5 points (115%) in gradebook) Exercises are complete. Every task was attempted and answered, and most answers are correct. Knitted document is clean and easy to follow. Work on the final problem shows creativity or is otherwise exceptional. We will not assign these often.\r✔: (15 points (100%) in gradebook) Exercises are complete and most answers are correct. This is the expected level of performance.\r✔−: (7.5 points (50%) in gradebook) Exercises are less than 70% complete and/or most answers are incorrect. This indicates that you need to improve next time. We will hopefully not assign these often, but subpar work can expect a ✔−.\r\rThere is an implicit 0 for any assignment not turned in on time. If you have only partial work, then turn that in for partial credit. As noted in the syllabus, we are not grading your coding ability. We are not checking each line of code to make sure it produces some exact final figure, and we do not expect perfection. Also note that a ✓ does not require 100% success. You will sometimes get stuck with weird errors that you can’t solve, or the demands of pandemic living might occasionally become overwhelming. We are looking for good faith effort. Try hard, engage with the task, and you’ll get a ✓.\nYou may work together on the labs, but you must turn in your own answers.\nLab Template\rYou will turn these labs in via D2L. You will write them using R Markdown and this lab assignment template. You must knit your work to a PDF document (this will be what you turn in).\n\r\rProjects\rTo give you practice with the data and design principles you’ll learn in this class, you will complete two projects en route to the overarching final project of the course. Both these mini projects and the final project must be completed in groups.\nThe two (mini) projects are checkpoints to ensure you’re working on your project seriously. They will be graded using a check system:\n\r✔+: (55 points (≈115%) in gradebook) Project is phenomenally well-designed and uses advanced R techniques. The project uncovers an important story that is not readily apparent from just looking at the raw data. I will not assign these often.\r✔: (50 points (100%) in gradebook) Project is fine, follows most design principles, answers a question from the data, and uses R correctly. This is the expected level of performance.\r✔−: (25 points (50%) in gradebook) Project is missing large components, is poorly designed, does not answer a relevant question, and/or uses R incorrectly. This indicates that you need to improve next time. I will hopefully not assign these often.\r\rBecause these mini projects give you practice for the final project, we will provide you with substantial feedback on your design and code.\n\rFinal project\rAt the end of the course, you will demonstrate your skills by completing a final project. Complete details for the final project (including past examples of excellent projects) are here. In brief, the final project has the following elements:\nYou must find existing data to analyze.1 Aggregating data from multiple sources is encouraged, but is not required.\r\rYou must visualize (at least) three interesting features of that data. Visualizations should aid the reader in understanding something about the data that might not be readily aparent.2\r\rYou must come up with some analysis—using tools from the course—which relates your data to either a prediction or a policy conclusion. For example, if you collected data from Major League Baseball games, you could try to “predict” whether a left-hander was pitching based solely on the outcomes of the batsmen.3\r\rYou must write your analysis as if presenting to a C-suite executive. If you are not familiar with this terminology, the C-suite includes, e.g., the CEO, CFO, and COO of a given company. Generally speaking, such executives are not particularly analytically oriented, and therefore your explanations need to be clear, consise (their time is valuable) and contain actionable (or valuable) information.\r\rThere is no final exam. This project is your final exam.\nThe project will not be graded using a check system, and will be graded by me (the main instructor, not a TA). I will evaluate the following four elements of your project:\nTechnical skills: Was the project easy? Does it showcase mastery of data analysis?\rVisual design: Was the information smartly conveyed and usable? Was it beautiful?\rAnalytic design: Was the analysis appropriate? Was it sensible, given the dataset?\rStory: Did we learn something?\r\rIf you’ve engaged with the course content and completed the exercises and mini projects throughout the course, you should do just fine with the final project.\n\r\rNote that existing is taken to mean that you are not permitted to collect data by interacting with other people. That is not to say that you cannot gather data that previously has not been gathered into a single place—this sort of exercise is encouraged.↩︎\n\rPie charts of any kind will result in a 25% grade deduction.↩︎\n\rThis is an extremely dumb idea for a number of reasons. Moreover, it’s worth mentioning that sports data, while rich, can be overwhelming due to its sheer magnitude and the variety of approaches that can be applied. Use with caution.↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1661858355,"objectID":"3aa23ffb1eb3dedbe4d8a9c2165e2c58","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/","section":"assignment","summary":"Weekly Writings\r\rWeekly Writing Template\r\rLabs\r\rLab Template\r\rProjects\rFinal project\r\r\rThis course is the capstone of the Data Analytics Minor in the College of Social Science. Accordingly, you should—fingers crossed—enjoy data analysis. You will get the most of out this class if you:\nEngage with the readings and lecture materials\rRegularly use R (aka engage daily or almost every day in some way)\r\rEach type of assignment in this class helps with one of these strategies.","tags":null,"title":"Assignments","type":"docs"},{"authors":null,"categories":null,"content":"\rThis section contains the content covered in Thursday lectures and some annotated R code that you can use as a reference for creating your own work. The intention is that in the Content section, you will sequentially build up your understanding of R and data analytics; here, you can see how all the pieces work together.\nVisit this section after you have finished the readings in the Content section and any supplemental lecture videos.\n](https://mediaspace.msu.edu/channel/SSC442+-+Spring+2021+-+KIRKPATRICK/199607633/subscribe). --\r","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1661815238,"objectID":"00e8826988eea7dfc8b8047b4c0184ce","permalink":"https://ssc442kirkpatrick.netlify.app/example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/example/","section":"example","summary":"This section contains the content covered in Thursday lectures and some annotated R code that you can use as a reference for creating your own work. The intention is that in the Content section, you will sequentially build up your understanding of R and data analytics; here, you can see how all the pieces work together.\nVisit this section after you have finished the readings in the Content section and any supplemental lecture videos.","tags":null,"title":"Examples","type":"docs"},{"authors":null,"categories":null,"content":"\rIn these reference pages, I’ve included some useful resources to help you in the course\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1661858355,"objectID":"8939c748f3090c6f91bdac5d32db55ec","permalink":"https://ssc442kirkpatrick.netlify.app/resource/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resource/","section":"resource","summary":"In these reference pages, I’ve included some useful resources to help you in the course","tags":null,"title":"Helpful resources","type":"docs"},{"authors":null,"categories":null,"content":"\rEach week has a set of required readings that you should complete before coming to the (online) Tuesday lecture. That is, you should complete the reading, attend Tuesday class, then do the associated “exercises” (contained within the reading) before Thursday. You will be working each week’s lab between Thursday afternoon and Monday at 11:59 PM (when the labs are due). Don’t forget your weekly writing in between, due Saturday at 11:59pm.\nThe course content is structured as follows. For each topic, we begin with a set of questions that might guide your reading and help frame your thoughts. These questions can serve as helpful starting places for your thinking; they are not representative of the totality of the content and are not intended to be limiting. You should not try to respond to all of these (or any of them if you don’t want to)—they’ll just help you know what to look for and think about as you read.\n](https://mediaspace.msu.edu/channel/SSC442+-+Spring+20221+-+KIRKPATRICK/199607633/subscribe). --\r","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1661811829,"objectID":"1413f960ec974b9863bc45d887efa8bd","permalink":"https://ssc442kirkpatrick.netlify.app/content/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/content/","section":"content","summary":"Each week has a set of required readings that you should complete before coming to the (online) Tuesday lecture. That is, you should complete the reading, attend Tuesday class, then do the associated “exercises” (contained within the reading) before Thursday. You will be working each week’s lab between Thursday afternoon and Monday at 11:59 PM (when the labs are due). Don’t forget your weekly writing in between, due Saturday at 11:59pm.","tags":null,"title":"Readings, lectures, and videos","type":"docs"},{"authors":null,"categories":null,"content":"\r\rIntroduction to Examples\r\rGetting started with R and RStudio Workflows\r\rInstalling R and RStudio\r\rThe R console\rScripts\rRStudio\r\rThe panes\rKey bindings\rRunning commands while editing scripts\r\rInstalling R packages\rRmarkdown\r\r\r\rIntroduction to Examples\rExamples in this class are designed to be presented in-class. Accordingly, the notes here are not comprehensive. Instead, they are intended to guide students through\nI’m also aware that my writing is dry and lifeless. If you’re reading this online without the advantage of seeing it in person, don’t worry—I’ll be “funnier” in class.1\nGetting started with R and RStudio Workflows\rIn Content this week, we reviewed the use of R. Now, let’s talk about doing work in R.\nR is not a programming language like C or Java. It was not created by software engineers for software development. Instead, it was developed by statisticians as an interactive environment for data analysis. You can read the full history in the paper A Brief History of S2. The interactivity is an indispensable feature in data science because, as you will soon learn, the ability to quickly explore data is a necessity for success in this field. However, like in other programming languages, you can save your work as scripts that can be easily executed at any moment. These scripts serve as a record of the analysis you performed, a key feature that facilitates reproducible work. If you are an expert programmer, you should not expect R to follow the conventions you are used—assuming this will leave you disappointed. If you are patient, you will come to appreciate the unequal power of R when it comes to data analysis and data visualization.\nOther attractive features of R are:\nR is free and open source3.\rIt runs on all major platforms: Windows, Mac OS, UNIX/Linux.\rScripts and data objects can be shared seamlessly across platforms.\rThere is a large, growing, and active community of R users and, as a result, there are numerous resources for learning and asking questions4 5 6.\rIt is easy for others to contribute add-ons which enables developers to share software implementations of new data science methodologies. The latest methods and tools are developed in R for a wide variety of disciplines and since social science is so broad, R is one of the few tools that spans the varied social sciences.\r\rInstalling R and RStudio\rIf you have not yet done so, you’ll need to install both R and RStudio. See the Installing page of our course resources for instructions.\nI have created a video walkthrough for the basics of using R for another course, but it is useful here. You can see part A here (labeled “Part 2a”) here ] and part B here (labeled “Part 2b”) . You should already be at this level of familiarity with R, but if you need a review, this is a good place to start.\n\r\rThe R console\rInteractive data analysis usually occurs on the R console that executes commands as you type them. There are several ways to gain access to an R console. One way is to simply start R on your computer. R Studio runs R inside of, so you won’t usually access R this way. The console looks something like this:\nAs a quick example, try using the console to calculate a 15% tip on a meal that cost $19.71:7\n0.15 * 19.71 \r## [1] 2.9565\rNote that in this course (at least, on most browsers), grey boxes are used to show R code typed into the R console. The symbol ## is used to denote what the R console outputs.\n\rScripts\rOne of the great advantages of R over point-and-click analysis software is that you can save your work as scripts. You can edit and save these scripts using a text editor. The material in this course was developed using the interactive integrated development environment (IDE) RStudio8. RStudio includes an editor with many R specific features, a console to execute your code, and other useful panes, including one to show figures.\nMost web-based R consoles also provide a pane to edit scripts, but not all permit you to save the scripts for later use. On the upper-right part of this webpage you’ll see a little button with the R logo. You can access a web-based console there.\n\rRStudio\rRStudio will be our launching pad for data science projects. It not only provides an editor for us to create and edit our scripts but also provides many other useful tools. In this section, we go over some of the basics.\nThe panes\rWhen you start RStudio for the first time, you will see three panes. The left pane shows the R console. On the right, the top pane includes tabs such as Environment and History, while the bottom pane shows five tabs: File, Plots, Packages, Help, and Viewer (these tabs may change in new versions). You can click on each tab to move across the different features.\nTo start a new script, you can click on File, then New File, then R Script.\nThis starts a new pane on the left and it is here where you can start writing your script.\n\rKey bindings\rMany tasks we perform with the mouse can be achieved with a combination of key strokes instead. These keyboard versions for performing tasks are referred to as key bindings. For example, we just showed how to use the mouse to start a new script, but you can also use a key binding: Ctrl+Shift+N on Windows and command+shift+N on the Mac.\nAlthough in this tutorial we often show how to use the mouse, we highly recommend that you memorize key bindings for the operations you use most. RStudio provides a useful cheat sheet with the most widely used commands. You might want to keep this handy so you can look up key-bindings when you find yourself performing repetitive point-and-clicking.\n\rRunning commands while editing scripts\rThere are many editors specifically made for coding. These are useful because color and indentation are automatically added to make code more readable. RStudio is one of these editors, and it was specifically developed for R. One of the main advantages provided by RStudio over other editors is that we can test our code easily as we edit our scripts. Below we show an example.\nLet’s start by opening a new script as we did before. A next step is to give the script a name. We can do this through the editor by saving the current new unnamed script. To do this, click on the save icon or use the key binding Ctrl+S on Windows and command+S on the Mac.\nWhen you ask for the document to be saved for the first time, RStudio will prompt you for a name. A good convention is to use a descriptive name, with lower case letters, no spaces, only hyphens to separate words, and then followed by the suffix .R. We will call this script my-first-script.R.\nNow we are ready to start editing our first script. The first lines of code in an R script are dedicated to loading the libraries we will use. Another useful RStudio feature is that once we type library() it starts auto-completing with libraries that we have installed. Note what happens when we type library(ti):\nAnother feature you may have noticed is that when you type library( the second parenthesis is automatically added. This will help you avoid one of the most common errors in coding: forgetting to close a parenthesis.\nNow we can continue to write code. As an example, we will make a graph showing murder totals versus population totals by state. Once you are done writing the code needed to make this plot, you can try it out by executing the code. To do this, click on the Run button on the upper right side of the editing pane. You can also use the key binding: Ctrl+Shift+Enter on Windows or command+shift+return on the Mac.\nOnce you run the code, you will see it appear in the R console and, in this case, the generated plot appears in the plots console. Note that the plot console has a useful interface that permits you to click back and forward across different plots, zoom in to the plot, or save the plots as files.\nTo run one line at a time instead of the entire script, you can use Control-Enter on Windows and command-return on the Mac.\nSETUP TIP\nChange the option Save workspace to .RData on exit to Never and uncheck the Restore .RData into workspace at start. By default, when you exit R saves all the objects you have created into a file called .RData. This is done so that when you restart the session in the same folder, it will load these objects. I find that this causes confusion especially when sharing code with colleagues or peers.\n\r\r\rInstalling R packages\rThe functionality provided by a fresh install of R is only a small fraction of what is possible. In fact, we refer to what you get after your first install as base R. The extra functionality comes from add-ons available from developers. There are currently hundreds of these available from CRAN and many others shared via other repositories such as GitHub. However, because not everybody needs all available functionality, R instead makes different components available via packages. R makes it very easy to install packages from within R. For example, to install the dslabs package, which we use to share datasets and code related to this course, you would type:\ninstall.packages(\u0026quot;dslabs\u0026quot;)\rIn RStudio, you can navigate to the Tools tab and select install packages. We can then load the package into our R sessions using the library function:\nlibrary(dslabs)\r## ## Attaching package: \u0026#39;dslabs\u0026#39;\r## The following object is masked from \u0026#39;package:gapminder\u0026#39;:\r## ## gapminder\rAs you go through this course, you will see that we load packages without installing them. This is because once you install a package, it remains installed and only needs to be loaded with library. The package remains loaded until we quit the R session. If you try to load a package and get an error, it probably means you need to\rinstall it first.\nWe can install more than one package at once by feeding a character vector to this function:\ninstall.packages(c(\u0026quot;tidyverse\u0026quot;, \u0026quot;dslabs\u0026quot;))\rOne advantage of using RStudio is that it auto-completes package names once you start typing, which is helpful when you do not remember the exact spelling of the package. Once you select your package, we recommend selecting all the defaults. Note that installing tidyverse actually installs several packages. This commonly occurs when a package has dependencies, or uses functions from other packages. When you load a package using library, you also load its dependencies.\nOnce packages are installed, you can load them into R and you do not need to install them again, unless you install a fresh version of R. Remember packages are installed in R not RStudio.\nIt is helpful to keep a list of all the packages you need for your work in a script because if you need to perform a fresh install of R, you can re-install all your packages by simply running a script.\nYou can see all the packages you have installed using the following function:\ninstalled.packages()\rAs we move through this course, we will constantly be adding to our toolbox of packages. Accordingly, you will need to keep track to ensure you have the requisite package for any given lecture.\n\rRmarkdown\rMarkdown is a general-purpose syntax for laying out documents. Rmarkdown is a combination of R and markdown, as the name implies. When using markdown, one can define headers and tables using specific notation, and depending on the rendering engine, the headers and tables (and a whole lot more) are customized. In fact, this whole website is built in R using Rmarkdown (and a lot of add-ons like Hugo and blogdown). In other contexts, the rendering engine may recognize that your headers are likely to be entries in a table of contents, and does so for you. The table of contents at the top of this document is built from the markdown headers.\nThe power of Rmarkdown is that it lets us mix formatted text with R code. That is, you can have a section of the document that understands R code, and a separate section right after that discusses the results from the R code.\nTry it out using the Weekly Writing Template. If it opens in your web browser, just right-click the link and select Save As…. Make sure you save the file to its own folder on your hard drive. In converting your Rmarkdown .Rmd file to a .pdf, your system will make multiple interim files9. It also creates folders to store the output of any plots or graphics you create with your R code.\nIf you’re new to Rmarkdown, I have made a short video on how to use it . This video is for my EC420 course, but works for us as well.\nIf we have time today, let’s open the template linked above and see what happens when we select “knit to pdf”.\n\r\r\rComments from previous classes indicate that I am not, in fact, funny.↩︎\n\rhttps://pdfs.semanticscholar.org/9b48/46f192aa37ca122cfabb1ed1b59866d8bfda.pdf↩︎\n\rhttps://opensource.org/history↩︎\n\rhttps://stats.stackexchange.com/questions/138/free-resources-for-learning-r↩︎\n\rhttps://www.r-project.org/help.html↩︎\n\rhttps://stackoverflow.com/documentation/r/topics↩︎\n\rBut probably tip more than 15%. Times are tough, man.↩︎\n\rhttps://www.rstudio.com/↩︎\n\rSpecifically, knitr will create an intermediate .md file which is then processed with Pandoc using Latex to create a pdf. Whew!↩︎\n\r\r\r","date":1661817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661857285,"objectID":"bbf45ee74dc37731d7fd26186d3a77a6","permalink":"https://ssc442kirkpatrick.netlify.app/example/00-example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/example/00-example/","section":"example","summary":"Introduction to Examples\r\rGetting started with R and RStudio Workflows\r\rInstalling R and RStudio\r\rThe R console\rScripts\rRStudio\r\rThe panes\rKey bindings\rRunning commands while editing scripts\r\rInstalling R packages\rRmarkdown\r\r\r\rIntroduction to Examples\rExamples in this class are designed to be presented in-class. Accordingly, the notes here are not comprehensive. Instead, they are intended to guide students through","tags":null,"title":"Working with R and RStudio","type":"docs"},{"authors":null,"categories":null,"content":"\r\rInstall R\rInstall RStudio\rInstall tidyverse\rInstall tinytex\r\r\rAs mentioned in the syllabus, you will do all of your work in this class with the open source programming language R. You will use RStudio as the main program to access R. Think of R as an engine and RStudio as a car dashboard—–R handles all the calculations and the actual statistics, while RStudio provides a nice interface for running R code.\nHopefully you’re well-versed in dealing with these things, but if you’re lost, here’s how you install the required software for the course.\nInstall R\rI have created a video walkthrough for installing R for another course, but it is useful here. You can see it here ]\nFirst you need to install R itself (the engine).\nGo to the CRAN (Collective R Archive Network)1 website: https://cran.r-project.org/\n\rClick on “Download R for XXX”, where XXX is either Mac or Windows:\n\rIf you use macOS, scroll down to the first .pkg file in the list of files (in this picture, it’s R-4.0.0.pkg; as of Summer 2022 now, the current version is also 4.2.1 so use the most recent one) and download it.\n\rIf you use Windows, click “base” (or click on the bolded “install R for the first time” link) and download it.\n\r\rDouble click on the downloaded file (check your Downloads folder). Click yes through all the prompts to install like any other program.\n\rIf you use macOS, download and install XQuartz. You do not need to do this on Windows.\n\r\r\rInstall RStudio\rNext, you need to install the most recent version of RStudio, the nicer graphical user interface (GUI) for R (the dashboard). Once R and RStudio are both installed, you can ignore R and only use RStudio. RStudio will use R automatically and you won’t ever have to interact with it directly.\nGo to the free download location on RStudio’s website: https://www.rstudio.com/products/rstudio/download/#download\n\rThe website should automatically detect your operating system (macOS or Windows) and show a big download button for it:\nIf not, scroll down a little to the large table and choose the version of RStudio that matches your operating system.\n\rDouble click on the downloaded file (again, check your Downloads folder). Click yes through all the prompts to install like any other program.\n\r\rDouble click on RStudio to run it (check your applications folder or start menu).\n\rInstall tidyverse\rR packages are easy to install with RStudio. Select the packages panel, click on “Install,” type the name of the package you want to install, and press enter.\nThis can sometimes be tedious when you’re installing lots of packages, though. The tidyverse, for instance, consists of dozens of packages (including the ever-present ggplot2) that all work together. Rather than install each individually, you can install a single magical package and get them all at the same time.\nGo to the packages panel in RStudio, click on “Install,” type “tidyverse”, and press enter. You’ll see a bunch of output in the RStudio console as all the tidyverse packages are installed.\nNotice also that RStudio will generate a line of code for you and run it: install.packages(\"tidyverse\"). You can also just paste and run this instead of using the packages panel. Hopefully you’ve experienced installing packages before now; if not, consider this a crash course!\n\rInstall tinytex\rWhen you knit to PDF, R uses a special scientific typesetting program named LaTeX.2\nLaTeX is neat and makes pretty documents, but it’s a huge program—the macOS version, for instance, is nearly 4 GB. To make life easier, there’s an R package named tinytex that installs a minimal LaTeX program and that automatically deals with differences between macOS and Windows.\nHere’s how to install tinytex so you can knit to pretty PDFs:\nUse the Packages in panel in RStudio to install tinytex like you did above with tidyverse. Alternatively, run install.packages(\"tinytex\") in the console.\rRun tinytex::install_tinytex() in the console.\rWait for a bit while R downloads and installs everything you need.\rThe end! You should now be able to knit to PDF.\r\rFind the course assignment template (for SSC442, see the Assignments page), right-click to download it (don’t just click on it - that won’t work), open it in Rstudio, and without changing anything, click the “knit” button to test out your install. Your system should open a PDF that looks like something like this:\nknitr::include_graphics(here(\u0026#39;content/resource\u0026#39;,\u0026#39;RenderedPDF.png\u0026#39;))\rSee the Markdown and R Markdown sidebars for instructions on using the template.\n\r\rIt’s a goofy name, but CRAN is where most R packages—and R itself—lives.↩︎\n\rPronounced “lay-tek” for those who are correct; or “lah-tex” to those who love goofy nerdy pronunciation. Technically speaking, the x is the “ch” sound in “Bach”, but most people just say it as “k”. While either saying “lay” or “lah” is correct, “layteks” is frowned upon because it clearly shows you’re not cool.↩︎\n\r\r\r","date":1661817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661857285,"objectID":"efb59c0882a965443ffcbafa3cd27ca6","permalink":"https://ssc442kirkpatrick.netlify.app/resource/install/","publishdate":"2022-08-30T00:00:00Z","relpermalink":"/resource/install/","section":"resource","summary":"Install R\rInstall RStudio\rInstall tidyverse\rInstall tinytex\r\r\rAs mentioned in the syllabus, you will do all of your work in this class with the open source programming language R. You will use RStudio as the main program to access R. Think of R as an engine and RStudio as a car dashboard—–R handles all the calculations and the actual statistics, while RStudio provides a nice interface for running R code.","tags":null,"title":"Installing R, RStudio, tidyverse, and tinytex","type":"docs"},{"authors":null,"categories":null,"content":"\r\rIntroduction to data visualization\rggplot2\r\rThe components of a graph\rggplot objects\rGeometries (briefly)\rAesthetic mappings\r\rAesthetics in general\rNow, back to aesthetic mappings\rLegends for aesthetics\r\rAnnotation Layers\r\rGlobal versus local aesthetic mappings\r\rTry it!\rLecture Videos\r\r\r\rIntroduction to data visualization\rLooking at the numbers and character strings that define a dataset is rarely useful. To convince yourself, print and stare at the US murders data table:\nlibrary(dslabs)\rdata(murders)\rhead(murders)\r## state abb region population total\r## 1 Alabama AL South 4779736 135\r## 2 Alaska AK West 710231 19\r## 3 Arizona AZ West 6392017 232\r## 4 Arkansas AR South 2915918 93\r## 5 California CA West 37253956 1257\r## 6 Colorado CO West 5029196 65\rWhat do you learn from staring at this table? Even though it is a relatively straightforward table, we can’t learn anything. For starters, it is grossly abbreviated, though you could scroll through. In doing so, how quickly might you be able to determine which states have the largest populations? Which states have the smallest? How populous is a typical state? Is there a relationship between population size and total murders? How do murder rates vary across regions of the country? For most folks, it is quite difficult to extract this information just by looking at the numbers. In contrast, the answer to the questions above are readily available from examining this plot:\nlibrary(tidyverse)\rlibrary(ggthemes)\rlibrary(ggrepel)\rr \u0026lt;- murders %\u0026gt;%\rsummarize(pop=sum(population), tot=sum(total)) %\u0026gt;%\rmutate(rate = tot/pop*10^6) %\u0026gt;% pull(rate)\rmurders %\u0026gt;% ggplot(aes(x = population/10^6, y = total, label = abb)) +\rgeom_abline(intercept = log10(r), lty=2, col=\u0026quot;darkgrey\u0026quot;) +\rgeom_point(aes(color=region), size = 3) +\rgeom_text_repel() +\rscale_x_log10() +\rscale_y_log10() +\rxlab(\u0026quot;Populations in millions (log scale)\u0026quot;) +\rylab(\u0026quot;Total number of murders (log scale)\u0026quot;) +\rggtitle(\u0026quot;US Gun Murders in 2010\u0026quot;) +\rscale_color_discrete(name=\u0026quot;Region\u0026quot;) +\rtheme_economist_white()\rWe are reminded of the saying: “A picture is worth a thousand words”. Data visualization provides a powerful way to communicate a data-driven finding. In some cases, the visualization is so convincing that no follow-up analysis is required. You should consider visualization the most potent tool in your data analytics arsenal.\nThe growing availability of informative datasets and software tools has led to increased reliance on data visualizations across many industries, academia, and government. A salient example is news organizations, which are increasingly embracing data journalism and including effective infographics as part of their reporting.\nA particularly salient example—given the current state of the world—is a Wall Street Journal article1 showing data related to the impact of vaccines on battling infectious diseases. One of the graphs shows measles cases by US state through the years with a vertical line demonstrating when the vaccine was introduced.\n(Source: Wall Street Journal)\nAnother striking example comes from a New York Times chart2, which summarizes scores from the NYC Regents Exams. As described in\rthe article3, these scores are collected for several reasons, including to determine if a student graduates from high school. In New York City you need a 65 to pass. The distribution of the test scores forces us to notice something somewhat problematic:\n(Source: New York Times via Amanda Cox)\nThe most common test score is the minimum passing grade, with very few scores just below the threshold. This unexpected result is consistent with students close to passing having their scores bumped up.\nThis is an example of how data visualization can lead to discoveries which would otherwise be missed if we simply subjected the data to a battery of data analysis tools or procedures. Data visualization is the strongest tool of what we call exploratory data analysis (EDA). John W. Tukey4, considered the father of EDA, once said,\n\r\r“The greatest value of a picture is when it forces us to notice what we never expected to see.”\n\r\rMany widely used data analysis tools were initiated by discoveries made via EDA. EDA is perhaps the most important part of data analysis, yet it is one that is often overlooked.\nData visualization is also now pervasive in philanthropic and educational organizations. In the talks New Insights on Poverty5 and The Best Stats You’ve Ever Seen6, Hans Rosling forces us to notice the unexpected with a series of plots related to world health and economics. In his videos, he uses animated graphs to show us how the world is changing and how old narratives are no longer true.\nIt is also important to note that mistakes, biases, systematic errors and other unexpected problems often lead to data that should be handled with care. Failure to discover these problems can give rise to flawed analyses and false discoveries. As an example, consider that measurement devices sometimes fail and that most data analysis procedures are not designed to detect these. Yet these data analysis procedures will still give you an answer. The fact that it can be difficult or impossible to notice an error just from the reported results makes data visualization particularly important.\nToday, we will discuss the basics of data visualization and exploratory data analysis. We will use the ggplot2 package to code. To learn the very basics, we will start with a somewhat artificial example: heights reported by students. Then we will cover the two examples mentioned above: 1) world health and economics and 2) infectious disease trends in the United States.\nOf course, there is much more to data visualization than what we cover here. The following are references for those who wish to learn more:\n\rER Tufte (1983) The visual display of quantitative information.\rGraphics Press.\rER Tufte (1990) Envisioning information. Graphics Press.\rER Tufte (1997) Visual explanations. Graphics Press.\rWS Cleveland (1993) Visualizing data. Hobart Press.\rWS Cleveland (1994) The elements of graphing data. CRC Press.\rA Gelman, C Pasarica, R Dodhia (2002) Let’s practice what we preach:\rTurning tables into graphs. The American Statistician 56:121-130.\rNB Robbins (2004) Creating more effective graphs. Wiley.\rA Cairo (2013) The functional art: An introduction to information graphics and visualization. New Riders.\rN Yau (2013) Data points: Visualization that means something. Wiley.\r\rWe also do not cover interactive graphics, a topic that is both too advanced for this course and too unweildy. Some useful resources for those interested in learning more can be found below, and you are encouraged to draw inspiration from those websites in your projects:\n\rhttps://shiny.rstudio.com/\rhttps://d3js.org/\r\r\rggplot2\rExploratory data visualization is perhaps the greatest strength of R. One can quickly go from idea to data to plot with a unique balance of flexibility and ease. For example, Excel may be easier than R for some plots, but it is nowhere near as flexible. D3.js may be more flexible and powerful than R, but it takes much longer to generate a plot. One of the reasons we use R is its incredible flexibility and ease.\nThroughout this course, we will be creating plots using the ggplot27 package.\nlibrary(dplyr)\rlibrary(ggplot2)\rMany other approaches are available for creating plots in R. In fact, the plotting capabilities that come with a basic installation of R are already quite powerful. There are also other packages for creating graphics such as grid and lattice. We chose to use ggplot2 in this course because it breaks plots into components in a way that permits beginners to create relatively complex and aesthetically pleasing plots using syntax that is intuitive and comparatively easy to remember.\nOne reason ggplot2 is generally more intuitive for beginners is that it uses a so-called “grammar of graphics”8, the letters gg in ggplot2. This is analogous to the way learning grammar can help a beginner construct hundreds of different sentences by learning just a handful of verbs, nouns and adjectives without having to memorize each specific sentence. Similarly, by learning a handful of ggplot2 building blocks and its grammar, you will be able to create hundreds of different plots.\nAnother reason ggplot2 is easy for beginners is that its default behavior is carefully chosen to satisfy the great majority of cases and is visually pleasing. As a result, it is possible to create informative and elegant graphs with relatively simple and readable code.\nOne limitation is that ggplot2 is designed to work exclusively with data tables in tidy format (where rows are observations and columns are variables). However, a substantial percentage of datasets that beginners work with are in, or can be converted into, this format. An advantage of this approach is that, assuming that our data is tidy, ggplot2 simplifies plotting code and the learning of grammar for a variety of plots. You should review the previous content about tidy data if you are feeling lost.\nTo use ggplot2 you will have to learn several functions and arguments. These are hard to memorize, so we highly recommend you have the ggplot2 cheat sheet handy. You can get a copy here: https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf or simply perform an internet search for “ggplot2 cheat sheet”.\nThe components of a graph\rWe will eventually construct a graph that summarizes the US murders dataset that looks like this:\nWe can clearly see how much states vary across population size and the total number of murders. Not surprisingly, we also see a clear relationship between murder totals and population size. A state falling on the dashed grey line has the same murder rate as the US average. The four geographic regions are denoted with color, which depicts how most southern states have murder rates above the average.\nThis data visualization shows us pretty much all the information in the data table. The code needed to make this plot is relatively simple. We will learn to create the plot part by part.\nThe first step in learning ggplot2 is to be able to break a graph apart into components. Let’s break down the plot above and introduce some of the ggplot2 terminology. The main five components to note are:\n\rData: The US murders data table is being summarized. We refer to this as the data component.\n\rGeometry: The plot above is a scatterplot. This is referred to as the\rgeometry component. Other possible geometries are barplot, histogram, smooth densities, qqplot, boxplot, pie (ew!), and many, many more. We will learn about these later.\n\rAesthetic mapping: The plot uses several visual cues to represent the information provided by the dataset. The two most important cues in this plot are the point positions on the x-axis and y-axis, which represent population size and the total number of murders, respectively. Each point represents a different observation, and we map data about these observations to visual cues like x- and y-scale. Color is another visual cue that we map to region. We refer to this as the aesthetic mapping component. How we define the mapping depends on what geometry we are using.\n\rAnnotations: These are things like axis labels, axis ticks (the lines along the axis at regular intervals or specific points of interest), axis scales (e.g. log-scale), titles, legends, etc.\n\rStyle: An overall appearance of the graph determined by fonts, color palattes, layout, blank spaces, and more.\n\r\rWe also note that:\n\rThe points are labeled with the state abbreviations.\rThe range of the x-axis and y-axis appears to be defined by the range of the data. They are both on log-scales.\rThere are labels, a title, a legend, and we use the style of The Economist magazine.\r\rAll of the flexibility and visualization power of ggplot is contained in these four elements (plus your data)\n\rggplot objects\rWe will now construct the plot piece by piece.\nWe start by loading the dataset:\nlibrary(dslabs)\rdata(murders)\rThe first step in creating a ggplot2 graph is to define a ggplot object. We do this with the function ggplot, which initializes the graph. If we read the help file for this function, we see that the first argument is used to specify what data is associated with this object:\nggplot(data = murders)\rWe can also pipe the data in as the first argument. So this line of code is equivalent to the one above:\nmurders %\u0026gt;% ggplot()\rIt renders a plot, in this case a blank slate since no geometry has been defined. The only style choice we see is a grey background.\nWhat has happened above is that the object was created and, because it was not assigned, it was automatically evaluated. But we can assign our plot to an object, for example like this:\np \u0026lt;- ggplot(data = murders)\rclass(p)\r## [1] \u0026quot;gg\u0026quot; \u0026quot;ggplot\u0026quot;\rTo render the plot associated with this object, we simply print the object p. The following two lines of code each produce the same plot we see above:\nprint(p)\rp\r\rGeometries (briefly)\rIn ggplot2 we create graphs by adding geometry layers. Layers can define geometries, compute summary statistics, define what scales to use, create annotations, or even change styles. To add layers, we use the symbol +. In general, a line of code will look like this:\n\rDATA %\u0026gt;% ggplot() + LAYER 1 + LAYER 2 + ... + LAYER N\n\rUsually, the first added layer after ggplot() + defines the geometry. After that, we may add additional geometries, we may rescale an axis, we may add annotations and labels, or we may change the style. For now, we want to make a scatterplot. What geometry do we use?\nTaking a quick look at the cheat sheet, we see that the function used to create plots with this geometry is geom_point.\n(Image courtesy of RStudio9. CC-BY-4.0 license10.)\nGeometry function names follow the pattern: geom_X where X is the name of some specific geometry. Some examples include geom_point, geom_bar, and geom_histogram. You’ve already seen a few of these. We will start with a scatterplot created using geom_point() for now, then circle back to more geometries after we cover aesthetic mappings, layers, and annotations.\nFor geom_point to run properly we need to provide data and an aesthetic mapping. The simplest mapping for a scatter plot is to say we want one variable on the X-axis, and a different one on the Y-axis, so each point is an {X,Y} pair. That is an aesthetic mapping because X and Y are aesthetics in a geom_point scatterplot.\nWe have already connected the object p with the murders data table, and if we add the layer geom_point it defaults to using this data. To find out what mappings are expected, we read the Aesthetics section of the help file ?geom_point help file:\n\u0026gt; Aesthetics\r\u0026gt;\r\u0026gt; geom_point understands the following aesthetics (required aesthetics are in bold):\r\u0026gt;\r\u0026gt; **x**\r\u0026gt;\r\u0026gt; **y**\r\u0026gt;\r\u0026gt; alpha\r\u0026gt;\r\u0026gt; colour\r\u0026gt;\r\u0026gt; fill\r\u0026gt;\r\u0026gt; group\r\u0026gt;\r\u0026gt; shape\r\u0026gt;\r\u0026gt; size\r\u0026gt;\r\u0026gt; stroke\rand—although it does not show in bold above—we see that at least two arguments are required: x and y. You can’t have a geom_point scatterplot unless you state what you want on the X and Y axes.\n\rAesthetic mappings\rAesthetic mappings describe how properties of the data connect with features of the graph, such as distance along an axis, size, or color. The aes function connects data with what we see on the graph by defining aesthetic mappings and will be one of the functions you use most often when plotting. The outcome of the aes function is often used as the argument of a geometry function. This example produces a scatterplot of population in millions (x-axis) versus total murders (y-axis):\nmurders %\u0026gt;% ggplot() +\rgeom_point(aes(x = population/10^6, y = total))\rInstead of defining our plot from scratch, we can also add a layer to the p object that was defined above as p \u0026lt;- ggplot(data = murders):\np + geom_point(aes(x = population/10^6, y = total))\rThe scales and annotations like axis labels are defined by default when adding this layer (note the x-axis label is exactly what we wrote in the function call). Like dplyr functions, aes also uses the variable names from the object component: we can use population and total without having to call them as murders$population and murders$total. The behavior of recognizing the variables from the data component is quite specific to aes. With most functions, if you try to access the values of population or total outside of aes you receive an error.\nNote that we did some rescaling within the aes() call - we can do simple things like multiplication or division on the variable names in the ggplot call. The axis labels reflect this. We will change the axis labels later.\nThe aesthetic mappings are very powerful - changing the variable in x= or y= changes the meaning of the plot entirely. We’ll come back to additional aesthetic mappings once we talk about aesthetics in general.\nAesthetics in general\rEven without mappings, a plots aesthetics can be useful. Things like color, fill, alpha, and size are aesthetics that can be changed.\nLet’s say we want larger points in our scatterplot. The size aesthetic can be used to set the size. The scale of size is “multiples of the defaults” (so size = 1 is the default)\np + geom_point(aes(x = population/10^6, y = total), size = 3)\rsize is not a mapping so it is not in the aes() part: whereas mappings use data from specific observations and need to be inside aes(), operations we want to affect all the points the same way do not need to be included inside aes. We’ll see what happens if size is inside aes(size = xxx) in a second.\nWe can change the shape to one of the many different base-R options found here:\np + geom_point(aes(x = population/10^6, y = total), size = 3, shape = 17)\rWe can also change the fill and the color:\np + geom_point(aes(x = population/10^6, y = total), size = 4, shape = 23, fill = \u0026#39;#18453B\u0026#39;)\rfill can take a common name like 'green', or can take a hex color like '#18453B', which is MSU Green according to MSU’s branding site. You can also find UM Maize and OSU Scarlet on respective branding pages, or google “XXX color hex.” We’ll learn how to build a color palatte later on.\ncolor (or colour, same thing because ggplot creators allow both spellings) is a little tricky with points - it changes the outline of the geometry rather than the fill color, but in geom_point() most shapes are only the outline, including the default. This is more useful with, say, a barplot where the outline and the fill might be different colors. Still, shapes 21-25 have both fill and color:\np + geom_point(aes(x = population/10^6, y = total), size = 5, shape = 23, fill = \u0026#39;#18453B\u0026#39;, color = \u0026#39;white\u0026#39;)\rThe color = 'white' makes the outline of the shape white, which you can see if you look closely in the areas where the shapes overlap. This only works with shapes 21-25, or any other geometry that has both an outline and a fill.\n\rNow, back to aesthetic mappings\rNow that we’ve seen a few aesthetics (and know we can find more by looking at which aesthetics work with our geometry in the help file), let’s return to the power of aesthetic mappings.\nAn aesthetic mapping means we can vary an aesthetic (like fill or shape or size) according to some variable in our data. This opens up a world of possibilities! Let’s try adding to our x and y aesthetics with a color aesthetic (since points respond to color better than fill) that varies by region, which is a column in our data:\np + geom_point(aes(x = population/10^6, y = total, color = region), size = 3)\rWe include color=region inside the aes call, which tells R to find a variable called region and change color based on that. R will choose a somewhat ghastly color palatte, and every unique value in the data for region will get a different color if the variable is discrete. If the variable is a continuous value, then ggplot will automatically make a color ramp. Thus, discrete and continuous values for aesthetic mappings work differently.\nLet’s see a useful example of a continuous aesthetic mapping to color. In our data, we are making a scatterplot of population and total murders, which really just shows that states with higher populations have higher murders. What we really want is murders per capita (I think COVID taught us a lot about rates vs. levels like “cases” and “cases per 100,000 people”). We can create a variable of “murders per capita” on the fly. Since “murders per capita” is a very small number and hard to read, we’ll multiply by 100 so that we get “percent of population murdered per year”:\np + geom_point(aes(x = population/10^5, y = total, color = 100*total/population), size = 3)\rWhile the clear pattern of “more population means more murders” is still there, look at the outlier in light blue in the bottom left. With the color ramp, see how easy it is to see here that there is one location where murders per capita is quite high?\nNote that size is outside of aes and is set to an explicit value, not to a variable. What if we set size to a variable in the data?\np + geom_point(aes(x = population/10^6, y = total, color = region, size = population/10^6))\r\rLegends for aesthetics\rHere we see yet another useful default behavior: ggplot2 automatically adds a legend that maps color to region, and size to population (which we scaled by 1,000,000). To avoid adding this legend we set the geom_point argument show.legend = FALSE. This removes both the size and the color legend.\np + geom_point(aes(x = population/10^6, y = total, color = region, size = population/10^6), show.legend = FALSE)\rLater on, when we get to annotation layers, we’ll talk about controlling the legend text and layout. For now, we just need to know how to turn them off.\n\r\rAnnotation Layers\rA second layer in the plot we wish to make involves adding a label to each point to identify the state. The geom_label and geom_text functions permit us to add text to the plot with and without a rectangle behind the text, respectively.\nBecause each point (each state in this case) has a label, we need an aesthetic mapping to make the connection between points and labels. By reading the help file ?geom_text, we learn that we supply the mapping between point and label through the label argument of aes. That is, label is an aesthetic that we can map. So the code looks like this:\np + geom_point(aes(x = population/10^6, y = total)) +\rgeom_text(aes(x = population/10^6, y = total, label = abb))\rWe have successfully added a second layer to the plot.\nAs an example of the unique behavior of aes mentioned above, note that this call:\np + geom_point(aes(x = population/10^6, y = total)) + geom_text(aes(population/10^6, total, label = abb))\ris fine, whereas this call:\np + geom_point(aes(x = population/10^6, y = total)) + geom_text(aes(population/10^6, total), label = abb)\rwill give you an error since abb is not found because it is outside of the aes function. The layer geom_text does not know where to find abb since it is a column name and not a global variable, and ggplot does not look for column names for non-mapped aesthetics. For a trivial example:\np + geom_point(aes(x = population/10^6, y = total)) +\rgeom_text(aes(population/10^6, total), label = \u0026#39;abb\u0026#39;)\rGlobal versus local aesthetic mappings\rIn the previous line of code, we define the mapping aes(population/10^6, total) twice, once in each geometry. We can avoid this by using a global aesthetic mapping. We can do this when we define the blank slate ggplot object. Remember that the function ggplot contains an argument that permits us to define aesthetic mappings:\nargs(ggplot)\r## function (data = NULL, mapping = aes(), ..., environment = parent.frame()) ## NULL\rIf we define a mapping in ggplot, all the geometries that are added as layers will default to this mapping. We redefine p:\np \u0026lt;- murders %\u0026gt;% ggplot(aes(x = population/10^6, y = total, label = abb))\rand then we can simply write the following code to produce the previous plot:\np + geom_point(size = 3) +\rgeom_text(nudge_x = 1.5) # offsets the label\rWe keep the size and nudge_x arguments in geom_point and geom_text, respectively, because we want to only increase the size of points and only nudge the labels. If we put those arguments in aes then they would apply to both plots. Also note that the geom_point function does not need a label argument and therefore ignores that aesthetic.\nIf necessary, we can override the global mapping by defining a new mapping within each layer. These local definitions override the global. Here is an example:\np + geom_point(size = 3) +\rgeom_text(aes(x = 10, y = 800, label = \u0026quot;Hello there!\u0026quot;))\rClearly, the second call to geom_text does not use x = population and y = total.\n\r\rTry it!\rLet’s break in to smaller groups and try playing with some of the aesthetics and aesthetic mappings. If we’re online, we’ll use Zoom Breakout Rooms. Each of the rooms have a room number which will correspond with one of the tasks below. If we’re in person (woohoo!), we’ll form the same number of groups in class.\nIn each group, one person should be the main coder - someone who has the packages like dslabs installed and has successfully run the plots above. Each set of tasks ask you to learn about an aesthetic and put it into action with the murder data. We’ll leave about 5 minutes to do the task, then have you come back and share your results with the class.\nFor each group, we’ll start with the following code:\np + geom_point(aes(x = population/10^6, y = total)) +\rgeom_text(aes(x = population/10^6, y = total, label = abb))\rThe alpha aesthetic mapping.\rThe alpha aesthetic can only take a number between 0 and 1. So first, in murders, create a murders_per_capita column by dividing total by population. Second, find the max(murders$murders_per_capita) and then create another new column called murders_per_capita_rescaled which divides murders_per_capita by the max value. murders_per_capita_rescaled will be between 0 and 1, with the value of 1 for the state with the max murder rate. This is a little hard to do on the fly in ggplot.\rSet the alpha aesthetic mapping to murders_per_capita_rescaled for geom_point.\rTurn off the legend using show.legend=FALSE\rInclude the geom_text labels, but make sure the aesthetic mapping does not apply to the labels.\rUse nudge_x = 1.5 as before to offset the labels.\rBe able to explain the plot.\r\rDoes the alpha aesthetic help present the data here? It’s OK if it doesn’t!\r\r\rThe stroke aesthetic mapping.\rThe stroke aesthetic works a bit like the size aesthetic. It must be used with a plot that has both a border and a fill, like shapes 21-25, so use one of those.\rUse the stroke aesthetic mapping (meaning the stroke will change according to a value in the data) to set a different stroke size based on murders per capita. You can create a murders per capita variable on the fly, or add it to your murders data.\r\rInclude the text labels as before and use nudge_x = 1.5.\rMake sure you’re only setting the aesthetic for the points on the scatterplot!\r\r\rThe angle aesthetic\rUsing the ?geom_text help, note that geom_text takes an aesthetic of angle.\rUse the angle aesthetic (not aesthetic mapping) in the appropriate place (e.g. on geom_text and not on other geometries) to adjust the labels on our plot.\rNow, try using the angle aesthetic mapping by using the total field as both the y value and the angle value in the geom_text layer.\rDoes using angle as an aesthetic help? What about as an aesthetic mapping?\r\rThe color aesthetic mapping\rSet the color aesthetic mapping in geom_text to total/population.\r\rUse the nudge_x = 1.5 aesthetic in geom_text still\r\rTry it with and without the legend using show.legend.\rBe able to explain the plot.\r\rDoes the color aesthetic mapping help present the data here?\r\r\rgeom_label and the fill aesthetic\rLooking at ?geom_label (which is the same help as geom_text), we note that “The fill aesthetic controls the backgreound colour of the label”.\rSet the fill aesthetic mapping to total/population in geom_label (replacing geom_text but still using nudge_x=1.5)\rSet the fill aesthetic (not mapping) to the color of your choice.\rBe able to explain the plots.\r\r\rDoes the fill aesthetic mapping help present the data here?\rWhat color did you choose for the non-mapped fill aesthetic?\r\r\r\r\rLecture Videos\rAll videos are in the SSC442 Mediaspace channel available here \n\r\r\rhttp://graphics.wsj.com/infectious-diseases-and-vaccines/?mc_cid=711ddeb86e↩︎\n\rhttp://graphics8.nytimes.com/images/2011/02/19/nyregion/19schoolsch/19schoolsch-popup.gif↩︎\n\rhttps://www.nytimes.com/2011/02/19/nyregion/19schools.html↩︎\n\rhttps://en.wikipedia.org/wiki/John_Tukey↩︎\n\rhttps://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en↩︎\n\rhttps://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen↩︎\n\rhttps://ggplot2.tidyverse.org/↩︎\n\rhttp://www.springer.com/us/book/9780387245447↩︎\n\rhttps://github.com/rstudio/cheatsheets↩︎\n\rhttps://github.com/rstudio/cheatsheets/blob/master/LICENSE↩︎\n\r\r\r","date":1661731200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661815619,"objectID":"059bb398e999a9d10b388c3df2b5644f","permalink":"https://ssc442kirkpatrick.netlify.app/example/01-example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/example/01-example/","section":"example","summary":"Introduction to data visualization\rggplot2\r\rThe components of a graph\rggplot objects\rGeometries (briefly)\rAesthetic mappings\r\rAesthetics in general\rNow, back to aesthetic mappings\rLegends for aesthetics\r\rAnnotation Layers\r\rGlobal versus local aesthetic mappings\r\rTry it!\rLecture Videos\r\r\r\rIntroduction to data visualization\rLooking at the numbers and character strings that define a dataset is rarely useful. To convince yourself, print and stare at the US murders data table:","tags":null,"title":"Introduction to Visualization","type":"docs"},{"authors":null,"categories":null,"content":"\r\rVisualizing data distributions\r\rVariable types\rCase study: describing student heights\r\rDistribution function\rCumulative distribution functions\r\rGeometries for describing distributions\r\rHistograms\rSmoothed density\rInterpreting the y-axis\rDensities permit stratification\r\rThe normal distribution\r\rStandard units\rQuantile-quantile plots\rPercentiles\r\rggplot2 geometries\r\rBarplots\rHistograms\rDensity plots\rBoxplots\r\rLecture Videos\rTry it!\r\r\r\rVisualizing data distributions\rThroughout your education, you may have noticed that numerical data is often summarized with the average value. For example, the quality of a high school is sometimes summarized with one number: the average score on a standardized test. Occasionally, a second number is reported: the standard deviation. For example, you might read a report stating that scores were 680 plus or minus 50 (the standard deviation). The report has summarized an entire vector of scores with just two numbers. Is this appropriate? Is there any important piece of information that we are missing by only looking at this summary rather than the entire list?\nOur first data visualization building block is learning to summarize lists of factors or numeric vectors—the two primary data types that we encounter in data analytics. More often than not, the best way to share or explore this summary is through data visualization. The most basic statistical summary of a list of objects or numbers is its distribution. Once a vector has been summarized as a distribution, there are several data visualization techniques to effectively relay this information.\nIn this section, we first discuss properties of a variety of distributions and how to visualize distributions using a motivating example of student heights. We then discuss some principles of data visualizations more broadly, and introduce new ggplot geometries to help us along the way.\nVariable types\rWe will be working with two types of variables: categorical and numeric. Each can be divided into two other groups: categorical can be ordinal or not, whereas numerical variables can be discrete or continuous.\nWhen each entry in a vector comes from one of a small number of groups, we refer to the data as categorical data. Two simple examples are sex (male or female) and regions (Northeast, South, North Central, West). Some categorical data can be ordered even if they are not numbers per se, such as spiciness (mild, medium, hot). In statistics textbooks, ordered categorical data are referred to as ordinal data. In psychology, a number of different terms are used for this same idea.\nExamples of numerical data are population sizes, murder rates, and heights. Some numerical data can be treated as ordered categorical. We can further divide numerical data into continuous and discrete. Continuous variables are those that can take any value, such as heights, if measured with enough precision. For example, a pair of twins may be 68.12 and 68.11 inches, respectively. Counts, such as population sizes, are discrete because they have to be integers—that’s how we count.1\n\rCase study: describing student heights\rHere we consider an artificial problem to help us illustrate the underlying concepts.\nPretend that we have to describe the heights of our classmates to ET, an extraterrestrial that has never seen humans. As a first step, we need to collect data. To do this, we ask students to report their heights in inches. We ask them to provide sex information because we know there are two different distributions by sex. We collect the data and save it in the heights data frame:\nlibrary(tidyverse)\rlibrary(dslabs)\rdata(heights)\rOne way to convey the heights to ET is to simply send him this list of 1050 heights. But there are much more effective ways to convey this information, and understanding the concept of a distribution will help. To simplify the explanation, we first focus on male heights.\nDistribution function\rIt turns out that, in some cases, the average and the standard deviation are pretty much all we need to understand the data. We will learn data visualization techniques that will help us determine when this two number summary is appropriate. These same techniques will serve as an alternative for when two numbers are not enough.\nThe most basic statistical summary of a list of objects or numbers is its distribution. The simplest way to think of a distribution is as a compact description of a list with many entries. This concept should not be new for readers of this book. For example, with categorical data, the distribution simply describes the proportion of each unique category. The sex represented in the heights dataset is:\n## ## Female Male ## 0.2266667 0.7733333\rThis two-category frequency table is the simplest form of a distribution. We don’t really need to visualize it since one number describes everything we need to know: 23% are females and the rest are males. When there are more categories, then a simple barplot describes the distribution. Here is an example with US state regions:\nThis particular plot simply shows us four numbers, one for each category. We usually use barplots to display a few numbers. Although this particular plot does not provide much more insight than a frequency table itself, it is a first example of how we convert a vector into a plot that succinctly summarizes all the information in the vector. When the data is numerical, the task of displaying distributions is more challenging.\n\rCumulative distribution functions\rNumerical data that are not categorical also have distributions. In general, when data is not categorical, reporting the frequency of each entry is not an effective summary since most entries are unique. In our case study, while several students reported a height of 68 inches, only one student reported a height of 68.503937007874 inches and only one student reported a height 68.8976377952756 inches. We assume that they converted from 174 and 175 centimeters, respectively.\nStatistics textbooks teach us that a more useful way to define a distribution for numeric data is to define a function that reports the proportion of the data below \\(a\\) for all possible values of \\(a\\). This function is called the cumulative distribution function (CDF). In statistics, the following notation is used:\n\\[ F(a) = \\mbox{Pr}(x \\leq a) \\]\nHere is a plot of \\(F\\) for the male height data:\nSimilar to what the frequency table does for categorical data, the CDF\rdefines the distribution for numerical data. From the plot, we can see that 16% of the values are below 65, since \\(F(66)=\\) 0.1637931, or that 84% of the values are below 72, since \\(F(72)=\\) 0.841133,\rand so on. In fact, we can report the proportion of values between any two heights, say \\(a\\) and \\(b\\), by computing \\(F(b) - F(a)\\). This means that if we send this plot above to ET, he will have all the information needed to reconstruct the entire list. Paraphrasing the expression “a picture is worth a thousand words”, in this case, a picture is as informative as 812 numbers.\nA final note: because CDFs can be defined mathematically—and absent any data—the word empirical is added to make the distinction when data is used. We therefore use the term empirical CDF (eCDF).\n\r\rGeometries for describing distributions\rNow, we’ll introduce ggplot geometries useful for describing distributions (or for many other things).\nHistograms\rAlthough the CDF concept is widely discussed in statistics textbooks, the plot is actually not very popular in practice. The main reason is that it does not easily convey characteristics of interest such as: at what value is the distribution centered? Is the distribution symmetric? What ranges contain 95% of the values? I doubt you can figure these out from glancing at the plot above. Histograms are much preferred because they greatly facilitate answering such questions. Histograms sacrifice just a bit of information to produce plots that are much easier to interpret.\nThe simplest way to make a histogram is to divide the span of our data into non-overlapping bins of the same size. Then, for each bin, we count the number of values that fall in that interval. The histogram plots these counts as bars with the base of the bar defined by the intervals. Here is the histogram for the height data splitting the range of values into one inch intervals: \\((49.5, 50.5],(50.5, 51.5],(51.5,52.5],(52.5,53.5],...,(82.5,83.5]\\)\nheights %\u0026gt;%\rfilter(sex==\u0026quot;Male\u0026quot;) %\u0026gt;%\rggplot(aes(x = height)) +\rgeom_histogram(binwidth = 1, color = \u0026quot;black\u0026quot;)\rIf we send this histogram plot to some uninformed reader, she will immediately learn some important properties about our data. First, the range of the data is from 50 to 84 with the majority (more than 95%) between 63 and 75 inches. Second, the heights are close to symmetric around 69 inches. Also, by adding up counts, this reader could obtain a very good approximation of the proportion of the data in any interval. Therefore, the histogram above is not only easy to interpret, but also provides almost all the information contained in the raw list of 812 heights with about 30 bin counts.\nWhat information do we lose? Note that all values in each interval are treated the same when computing bin heights. So, for example, the histogram does not distinguish between 64, 64.1, and 64.2 inches. Given that these differences are almost unnoticeable to the eye, the practical implications are negligible and we were able to summarize the data to just 23 numbers.\nThe geom_histogram layer only requires one aesthetic mapping - the x-axis. This is because the y-axis is computed from counts of the x-axis. Giving an aesthetic mapping to an additional variable for y will result in an error. Using an aesthetic mapping like fill will work - it’ll give you two histograms on top of each other. Try it! Try setting the alpha aesthetic to .5 (not an aesthetic mapping) so you can see both layers when they overlap.\n\rSmoothed density\rSmooth density plots are aesthetically more appealing than histograms. geom_density is the geometry that gives a smoothed density. Here is what a smooth density plot looks like for our heights data:\nheights %\u0026gt;%\rfilter(sex==\u0026quot;Male\u0026quot;) %\u0026gt;%\rggplot(aes(height)) +\rgeom_density(alpha = .2, fill= \u0026quot;#00BFC4\u0026quot;, color = \u0026#39;gray50\u0026#39;) \rIn this plot, we no longer have sharp edges at the interval boundaries and many of the local peaks have been removed. Also, the scale of the y-axis changed from counts to density. That is, the area under the curve will add up to 1, so we can read it like a probability density.\nTo understand the smooth densities, we have to understand estimates, a topic we don’t cover until later. However, we provide a heuristic explanation to help you understand the basics so you can use this useful data visualization tool.\nThe main new concept you must understand is that we assume that our list of observed values is a subset of a much larger list of unobserved values. In the case of heights, you can imagine that our list of 812 male students comes from a hypothetical list containing all the heights of all the male students in all the world measured very precisely. Let’s say there are 1,000,000 of these measurements. This list of values has a distribution, like any list of values, and this larger distribution is really what we want to report to ET since it is much more general. Unfortunately, we don’t get to see it.\nHowever, we make an assumption that helps us perhaps approximate it. If we had 1,000,000 values, measured very precisely, we could make a histogram with very, very small bins. The assumption is that if we show this, the height of consecutive bins will be similar. This is what we mean by smooth: we don’t have big jumps in the heights of consecutive bins. Below we have a hypothetical histogram with bins of size 1:\nThe smaller we make the bins, the smoother the histogram gets. Here are the histograms with bin width of 1, 0.5, and 0.1:\nThe smooth density is basically the curve that goes through the top of the histogram bars when the bins are very, very small. To make the curve not depend on the hypothetical size of the hypothetical list, we compute the curve on frequencies rather than counts. We do this by using the double-dot object ..density... Objects surrounded by .. are objects that are calculated by ggplot. If we look at ?geom_histogram, and go down to “Computed variables”, we see that we could use ..count.. to get “number of points in a bin”; ..ncount.. for the count scaled to a max of 1; or ..ndensity.. which scales the density to a max of 1 (which is a strange one). We can manually set the y aesthetic mapping, which defaults to ..count.., to ..density..:\nx %\u0026gt;% ggplot(aes(x = height)) +\rgeom_histogram(aes(y=..density..), binwidth = 0.1, color = \u0026quot;black\u0026quot;) \rNow, back to reality. We don’t have millions of measurements. In this concrete example, we have 812 and we can’t make a histogram with very small bins.\nWe therefore make a histogram, using bin sizes appropriate for our data and computing frequencies rather than counts, and we draw a smooth curve that goes through the tops of the histogram bars. The following plots (loosely) demonstrate the steps that the computer goes through to ultimately create a smooth density:\n\rInterpreting the y-axis\rNote that interpreting the y-axis of a smooth density plot is not straightforward. It is scaled so that the area under the density curve adds up to 1. If you imagine we form a bin with a base 1 unit in length, the y-axis value tells us the proportion of values in that bin. However, this is only true for bins of size 1. For other size intervals, the best way to determine the proportion of data in that interval is by computing the proportion of the total area contained in that interval. For example, here are the proportion of values between 65 and 68:\nThe proportion of this area is about\r0.3,\rmeaning that about\r30%\rof male heights are between 65 and 68 inches.\nBy understanding this, we are ready to use the smooth density as a summary. For this dataset, we would feel quite comfortable with the smoothness assumption, and therefore with sharing this aesthetically pleasing figure with ET, which he could use to understand our male heights data:\nheights %\u0026gt;%\rfilter(sex==\u0026quot;Male\u0026quot;) %\u0026gt;%\rggplot(aes(x = height)) +\rgeom_density(alpha=.2, fill= \u0026quot;#00BFC4\u0026quot;, color = \u0026#39;black\u0026#39;) \rNote that the only aesthetic mapping is x = height, while the fill and color are set as un-mapped aesthetics.\n\rDensities permit stratification\rAs a final note, we point out that an advantage of smooth densities over histograms for visualization purposes is that densities make it easier to compare two distributions. This is in large part because the jagged edges of the histogram add clutter. Here is an example comparing male and female heights:\nheights %\u0026gt;%\rggplot(aes(height, fill=sex)) +\rgeom_density(alpha = 0.2, color = \u0026#39;black\u0026#39;)\rWith the right argument, ggplot automatically shades the intersecting region with a different color.\n\r\rThe normal distribution\rHistograms and density plots provide excellent summaries of a distribution. But can we summarize even further? We often see the average and standard deviation used as summary statistics: a two-number summary! To understand what these summaries are and why they are so widely used, we need to understand the normal distribution.\nThe normal distribution, also known as the bell curve and as the Gaussian distribution, is one of the most famous mathematical concepts in history. A reason for this is that approximately normal distributions occur in many situations, including gambling winnings, heights, weights, blood pressure, standardized test scores, and experimental measurement errors. There are explanations for this, but we describe these later. Here we focus on how the normal distribution helps us summarize data.\nRather than using data, the normal distribution is defined with a mathematical formula. For any interval \\((a,b)\\), the proportion of values in that interval can be computed using this formula:\n\\[\\mbox{Pr}(a \u0026lt; x \u0026lt; b) = \\int_a^b \\frac{1}{\\sqrt{2\\pi}s} e^{-\\frac{1}{2}\\left( \\frac{x-m}{s} \\right)^2} \\, dx\\]\nYou don’t need to memorize or understand the details of the formula. But note that it is completely defined by just two parameters: \\(m\\) and \\(s\\). The rest of the symbols in the formula represent the interval ends that we determine, \\(a\\) and \\(b\\), and known mathematical constants \\(\\pi\\) and \\(e\\). These two parameters, \\(m\\) and \\(s\\), are referred to as the average (also called the mean) and the standard deviation (SD) of the distribution, respectively.\nThe distribution is symmetric, centered at the average, and most values (about 95%) are within 2 SDs from the average. Here is what the normal distribution looks like when the average is 0 and the SD is 1:\nThe fact that the distribution is defined by just two parameters implies that if a dataset is approximated by a normal distribution, all the information needed to describe the distribution can be encoded in just two numbers: the average and the standard deviation. We now define these values for an arbitrary list of numbers.\nFor a list of numbers contained in a vector x, the average is defined as:\nm \u0026lt;- sum(x) / length(x)\rand the SD is defined as:\ns \u0026lt;- sqrt(sum((x-mu)^2) / length(x))\rwhich can be interpreted as the average distance between values and their average.\nLet’s compute the values for the height for males which we will store in the object \\(x\\):\nindex \u0026lt;- heights$sex == \u0026quot;Male\u0026quot;\rx \u0026lt;- heights$height[index]\rThe pre-built functions mean and sd (note that for reasons explained later, sd divides by length(x)-1 rather than length(x)) can be used here:\nm \u0026lt;- mean(x)\rs \u0026lt;- sd(x)\rc(average = m, sd = s)\r## average sd ## 69.314755 3.611024\rHere is a plot of the smooth density and the normal distribution with mean = 69.3 and SD = 3.6 plotted as a black line with our student height smooth density in blue:\nNow, we can ask the question “is our height data approximately normally distributed?”. The normal distribution does appear to be quite a good approximation here. We now will see how well this approximation works at predicting the proportion of values within intervals.\nStandard units\rFor data that is approximately normally distributed, it is convenient to think in terms of standard units. The standard unit of a value tells us how many standard deviations away from the average it is. Specifically, for a value x from a vector X, we define the value of x in standard units as z = (x - m)/s with m and s the average and standard deviation of X, respectively. Why is this convenient?\nFirst look back at the formula for the normal distribution and note that what is being exponentiated is \\(-z^2/2\\) with \\(z\\) equivalent to \\(x\\) in standard units. Because the maximum of \\(e^{-z^2/2}\\) is when \\(z=0\\), this explains why the maximum of the distribution occurs at the average. It also explains the symmetry since \\(- z^2/2\\) is symmetric around 0. Second, note that if we convert the normally distributed data to standard units, we can quickly know if, for example, a person is about average (\\(z=0\\)), one of the largest (\\(z \\approx 2\\)), one of the smallest (\\(z \\approx -2\\)), or an extremely rare occurrence (\\(z \u0026gt; 3\\) or \\(z \u0026lt; -3\\)). Remember that it does not matter what the original units are, these rules apply to any data that is approximately normal.\nIn R, we can obtain standard units using the function scale:\nz \u0026lt;- scale(x)\rNow to see how many men are within 2 SDs from the average, we simply type:\nmean(abs(z) \u0026lt; 2)\r## [1] 0.9495074\rThe proportion is about 95%, which is what the normal distribution predicts! To further confirm that, in fact, the approximation is a good one, we can use quantile-quantile plots.\n\rQuantile-quantile plots\rA systematic way to assess how well the normal distribution fits the data is to check if the observed and predicted proportions match. In general, this is the approach of the quantile-quantile plot (QQ-plot). If our heights distribution is really normal, then the 10th percentile of our heights data should be the same as the 10th percentile of a theoretical normal, as should the 20th, 30th, 33rd, 37.5th, etc. percentiles.\nFirst let’s define the theoretical quantiles (percentiles) for the normal distribution. In statistics books we use the symbol \\(\\Phi(x)\\) to define the function that gives us the probability of a standard normal distribution being smaller than \\(x\\). So, for example, \\(\\Phi(-1.96) = 0.025\\) and \\(\\Phi(1.96) = 0.975\\). In R, we can evaluate \\(\\Phi\\) using the pnorm function:\npnorm(-1.96)\r## [1] 0.0249979\rThe inverse function \\(\\Phi^{-1}(x)\\) gives us the theoretical quantiles for the normal distribution. So, for example, \\(\\Phi^{-1}(0.975) = 1.96\\). In R, we can evaluate the inverse of \\(\\Phi\\) using the qnorm function.\nqnorm(0.975)\r## [1] 1.959964\rNote that these calculations are for the standard normal distribution by default (mean = 0, standard deviation = 1), but we can also define these for any normal distribution. We can do this using the mean and sd arguments in the pnorm and qnorm function. For example, we can use qnorm to determine quantiles of a distribution with a specific average and standard deviation\nqnorm(0.975, mean = 5, sd = 2)\r## [1] 8.919928\rFor the normal distribution, all the calculations related to quantiles are done without data, thus the name theoretical quantiles. But quantiles can be defined for any distribution, including an empirical one. So if we have data in a vector \\(x\\), we can define the quantile associated with any proportion \\(p\\) as the \\(q\\) for which the proportion of values below \\(q\\) is \\(p\\). Using R code, we can define q as the value for which mean(x \u0026lt;= q) = p. Notice that not all \\(p\\) have a \\(q\\) for which the proportion is exactly \\(p\\). There are several ways of defining the best \\(q\\) as discussed in the help for the quantile function.\nTo give a quick example, for the male heights data, we have that:\nmean(x \u0026lt;= 69.5)\r## [1] 0.5147783\rSo about 50% are shorter or equal to 69 inches. This implies that if \\(p=0.50\\) then \\(q=69.5\\).\nThe idea of a QQ-plot is that if your data is well approximated by normal distribution then the quantiles of your data should be similar to the quantiles of a normal distribution. To construct a QQ-plot, we do the following:\nDefine a vector of \\(m\\) proportions \\(p_1, p_2, \\dots, p_m\\).\rDefine a vector of quantiles \\(q_1, \\dots, q_m\\) for your data for the proportions \\(p_1, \\dots, p_m\\). We refer to these as the sample quantiles.\rDefine a vector of theoretical quantiles for the proportions \\(p_1, \\dots, p_m\\) for a normal distribution with the same average and standard deviation as the data.\rPlot the sample quantiles versus the theoretical quantiles.\r\rLet’s construct a QQ-plot using R code. Start by defining the vector of proportions.\np \u0026lt;- seq(0.005, 0.995, 0.01)\rTo obtain the quantiles from the data, we can use the quantile function like this:\nsample_quantiles \u0026lt;- quantile(x, p)\rTo obtain the theoretical normal distribution quantiles with the corresponding average and SD, we use the qnorm function:\ntheoretical_quantiles \u0026lt;- qnorm(p, mean = mean(x), sd = sd(x))\rdf = data.frame(sample_quantiles, theoretical_quantiles)\rTo see if they match or not, we plot them against each other and draw the identity line:\nggplot(data = df, aes(x = theoretical_quantiles, y = sample_quantiles)) + geom_point() + geom_abline() # a 45-degree line \rNotice that this code becomes much cleaner if we use standard units:\nsample_quantiles \u0026lt;- quantile(z, p)\rtheoretical_quantiles \u0026lt;- qnorm(p)\rdf2 = data.frame(sample_quantiles, theoretical_quantiles)\rggplot(data = df2, aes(x = theoretical_quantiles, y = sample_quantiles)) + geom_point() + geom_abline()\rThe above code is included to help describe QQ-plots. However, in practice it is easier to use the ggplot geometry geom_qq:\nheights %\u0026gt;% filter(sex == \u0026quot;Male\u0026quot;) %\u0026gt;%\rggplot(aes(sample = scale(height))) +\rgeom_qq() +\rgeom_abline()\rWhile for the illustration above we used 100 quantiles, the default from the geom_qq function is to use as many quantiles as data points.\n\rPercentiles\rBefore we move on, let’s define some terms that are commonly used in exploratory data analysis.\nPercentiles are special cases of quantiles that are commonly used. The percentiles are the quantiles you obtain when setting the \\(p\\) at \\(0.01, 0.02, ..., 0.99\\). We call, for example, the case of \\(p=0.25\\) the 25th percentile, which gives us a number for which 25% of the data is below. The most famous percentile is the 50th, also known as the median.\nFor the normal distribution the median and average are the same, but this is generally not the case.\nAnother special case that receives a name are the quartiles, which are obtained when setting \\(p=0.25,0.50\\), and \\(0.75\\).\n\r\rggplot2 geometries\rAlhough we haven’t gone into detain about the ggplot2 package for data visualization, we now will briefly discuss some of the geometries involved in the plots above. We will discuss ggplot2 in (excruciating) detail later this week. For now, we will briefly demonstrate how to generate plots related to distributions.\nBarplots\rTo generate a barplot we can use the geom_bar geometry. The default is to count the number of each category and draw a bar. Here is the plot for the regions of the US.\nmurders %\u0026gt;% ggplot(aes(region)) + geom_bar()\rWe often already have a table with a distribution that we want to present as a barplot. Here is an example of such a table:\ndata(murders)\rtab \u0026lt;- murders %\u0026gt;%\rcount(region) %\u0026gt;%\rmutate(proportion = n/sum(n))\rtab\r## region n proportion\r## 1 Northeast 9 0.1764706\r## 2 South 17 0.3333333\r## 3 North Central 12 0.2352941\r## 4 West 13 0.2549020\rWe no longer want geom_bar to count, but rather just plot a bar to the height provided by the proportion variable. For this we need to provide x (the categories) and y (the values) and use the stat=\"identity\" option. This tells R to just use the actual value in proportion for the y aesthetic. This is only necessary when you’re telling R that you have your own field (proportion) that you want to use instead of just the count.\ntab %\u0026gt;% ggplot(aes(x = region, y = proportion)) + geom_bar(stat = \u0026quot;identity\u0026quot;)\r\rHistograms\rTo generate histograms we use geom_histogram. By looking at the help file for this function, we learn that the only required argument is x, the variable for which we will construct a histogram. We dropped the x because we know it is the first argument.\rThe code looks like this:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(height)) +\rgeom_histogram()\rIf we run the code above, it gives us a message:\n\rstat_bin() using bins = 30. Pick better value with\rbinwidth.\n\rWe previously used a bin size of 1 inch (of observed height), so the code looks like this:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(height)) +\rgeom_histogram(binwidth = 1)\rFinally, if for aesthetic reasons we want to add color, we use the arguments described in the help file. We also add labels and a title:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(height)) +\rgeom_histogram(binwidth = 1, fill = \u0026quot;blue\u0026quot;, col = \u0026quot;black\u0026quot;) +\rlabs(x = \u0026quot;Male heights in inches\u0026quot;, title = \u0026quot;Histogram\u0026quot;)\r\rDensity plots\rTo create a smooth density, we use the geom_density. To make a smooth density plot with the data previously shown as a histogram we can use this code:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(x = height)) +\rgeom_density()\rTo fill in with color, we can use the fill argument.\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(x = height)) +\rgeom_density(fill=\u0026quot;blue\u0026quot;)\rTo change the smoothness of the density, we use the adjust argument to multiply the default value by that adjust. For example, if we want the bandwidth to be twice as big we use:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rggplot(aes(x = height)) + geom_density(fill=\u0026quot;blue\u0026quot;, adjust = 2)\r\rBoxplots\rThe geometry for boxplot is geom_boxplot. As discussed, boxplots are useful for comparing distributions. For example, below are the previously shown heights for women, but compared to men. For this geometry, we need arguments x as the categories, and y as the values.\nNote that our x-axis is a categorical variable. The order is determined by either the factor variable levels in heights or, if no levels are set, in the order in which the sex variable first encounters them. Later on, we’ll learn how to change the ordering.\nWe can do much more with boxplots when we have more data. Right now, our heights data has only two variables - sex and height. Let’s say we took the measurements over two different years - 2010 and 2020. That’s not in our data, so purely for exposition, we’ll add it by randomly drawing a year for each observation. We’ll do this with sample\nheights = heights %\u0026gt;%\rdplyr::mutate(year = sample(x = c(2010, 2020), size = n(), replace = TRUE, prob = c(.5, .5)))\rhead(heights)\r## sex height year\r## 1 Male 75 2020\r## 2 Male 70 2010\r## 3 Male 68 2020\r## 4 Male 74 2010\r## 5 Male 61 2020\r## 6 Female 65 2010\rNow, let’s look at the boxplot of heights by sex, but broken out by year. We can do this by adding year as an aesthetic mapping. Because our year variable is an integer, R will start by thinking it’s a continuous numeric, but we want to treat it as a discrete variable. So, we wrap it in as.factor() to force R to recognize it as a discrete variable.\nheights %\u0026gt;% ggplot(aes(x = sex, y = height, fill = as.factor(year))) +\rgeom_boxplot() +\rlabs(fill = \u0026#39;Year\u0026#39;)\rNow we have each sex broken out by year! Since we randomly assigned year to our data (and didn’t actually take samples in two different decades), the distribution between years and within sex is nearly identical.\nWhat if we wanted to have year on the x-axis, but then put the sex boxplots next to each other. This would let us compare the difference in heights by sex over the two sample years.\nheights %\u0026gt;% ggplot(aes(x = year, y = height, fill = sex)) + geom_boxplot() +\rlabs(fill = \u0026#39;Sex\u0026#39;)\rWoah. Wait. What? Remember, in our data, class(heights$year) is numeric, so when we ask R to put year on the x-axis, it thinks it’s plotting a number. It gives us a nonsense x-axis. How do we fix this? We force as.factor(year) to tell R that yes, year is a categorical variable. Note that we didn’t have to use as.factor(sex) - that’s because sex is already a categorical variable.\nheights %\u0026gt;% ggplot(aes(x = as.factor(year), y = height, fill = sex)) + geom_boxplot() +\rlabs(fill = \u0026#39;Sex\u0026#39;)\rNow we can see the height difference by sex, by year.\nWe will explore more with boxplots and colors in our next lecture.\n\r\rLecture Videos\rThe video from this lecture will be available here around 3-6 days after class \n\rTry it!\rTry it!\nTRY IT\nStart by loading the dplyr and ggplot2 library as well as the murders and heights data.\nlibrary(dplyr)\rlibrary(ggplot2)\rlibrary(dslabs)\rdata(heights)\rdata(murders)\rFirst, create a new variable in murders that has murders_per_capita.\r\rmurders = murders %\u0026gt;%\rmutate(........)\rMake a histogram of murders per capita. Use the default values for color and fill, but make sure you label the x-axis with a meaningful label.\n\rMake the same histogram, but set the fill aesthetic to MSU Green and the color to black.\n\rDo the same, but make it a smooth density plot\n\rFinally, plot the smooth density but use a fill aesthetic mapping so that each region’s density is shown. Set a meaningful title on the legend, and make sure you make the density transparent so we can see all of the region’s densities (see alpha aesthetic).\n\rNow, try making a boxplot to show the same data - the distribution across states of murders per capita by region. What is the average Northeastern state’s murder rate? What about the average Southern state?\n\r\r\r\r\r\rKeep in mind that discrete numeric data can be considered ordinal. Although this is technically true, we usually reserve the term ordinal data for variables belonging to a small number of different groups, with each group having many members. In contrast, when we have many groups with few cases in each group, we typically refer to them as discrete numerical variables. So, for example, the number of packs of cigarettes a person smokes a day, rounded to the closest pack, would be considered ordinal, while the actual number of cigarettes would be considered a numerical variable. But, indeed, there are examples that can be considered both numerical and ordinal when it comes to visualizing data.↩︎\n\r\r\r","date":1661731200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661815238,"objectID":"ce879375c9ab42490f4d0d112e48c07c","permalink":"https://ssc442kirkpatrick.netlify.app/example/02-example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/example/02-example/","section":"example","summary":"Visualizing data distributions\r\rVariable types\rCase study: describing student heights\r\rDistribution function\rCumulative distribution functions\r\rGeometries for describing distributions\r\rHistograms\rSmoothed density\rInterpreting the y-axis\rDensities permit stratification\r\rThe normal distribution\r\rStandard units\rQuantile-quantile plots\rPercentiles\r\rggplot2 geometries\r\rBarplots\rHistograms\rDensity plots\rBoxplots\r\rLecture Videos\rTry it!\r\r\r\rVisualizing data distributions\rThroughout your education, you may have noticed that numerical data is often summarized with the average value.","tags":null,"title":"ggplot2: Everything you ever wanted to know","type":"docs"},{"authors":null,"categories":null,"content":"\r\rProgramming basics\r\rConditional expressions\rDefining functions\rNamespaces\rFor-loops\rVectorization and functionals\rExercises\r\r\r\rYou must turn in a PDF document knitted from your R Markdown code. Submit this to “Lab 0” on D2L by 11:59 PM on Monday September 5th. You do not need to submit your .rmd file code - just the properly-knitted PDF.\nNOTE:\nAs you read through this assignment, practice with each of the examples (copy-paste them into an empty R script and run them). At the bottom of this page you will find the questions that comprise the assignment. These questions apply and expand on the topics and R functions in the assignment.\nRight-click to download the homework .Rmd template . Please save the template into the labs folder in the SSC442 folder on your local hard drive. If you don’t have a nice file structure setup for the course, please do so now. It will save you headaches in the future.\n\rIf you have not yet done so, you’ll need to install both R and RStudio. See the Installing page of our course resources for instructions.\nI have created a video walkthrough for the basics of using R for another course, but it is useful here. You can see part A here (labeled “Part 2a”) here ] and part B here (labeled “Part 2b”) . You should already be at this level of familiarity with R, but if you need a review, this is a good place to start.\nProgramming basics\rWe teach R because it greatly facilitates data analysis, the main topic of this book. By coding in R, we can efficiently perform exploratory data analysis, build data analysis pipelines, and prepare data visualization to communicate results. However, R is not just a data analysis environment but a programming language. Advanced R programmers can develop complex packages and even improve R itself, but we do not cover advanced programming in this book. Nonetheless, in this section, we introduce three key programming concepts: conditional expressions, for-loops, and functions. These are not just key building blocks for advanced programming, but are sometimes useful during data analysis. We also note that there are several functions that are widely used to program in R but that we will not cover in this book. These include split, cut, do.call, and Reduce, as well as the data.table package. These are worth learning if you plan to become an expert R programmer.\nConditional expressions\rConditional expressions are one of the basic features of programming. They are used for what is called flow control. The most common conditional expression is the if-else statement. In R, we can actually perform quite a bit of data analysis without conditionals. However, they do come up occasionally, and you will need them once you start writing your own functions and packages.\nHere is a very simple example showing the general structure of an if-else statement. The basic idea is to print the reciprocal of a unless a is 0:\na \u0026lt;- 0\rif(a!=0){\rprint(1/a)\r} else{\rprint(\u0026quot;No reciprocal for 0.\u0026quot;)\r}\r## [1] \u0026quot;No reciprocal for 0.\u0026quot;\rLet’s look at one more example using the US murders data frame:\nlibrary(dslabs)\rdata(murders)\rmurder_rate \u0026lt;- murders$total / murders$population*100000\rHere is a very simple example that tells us which states, if any, have a murder rate lower than 0.5 per 100,000. The if statement protects us from the case in which no state satisfies the condition.\nind \u0026lt;- which.min(murder_rate)\rif(murder_rate[ind] \u0026lt; 0.5){\rprint(murders$state[ind])\r} else{\rprint(\u0026quot;No state has murder rate that low\u0026quot;)\r}\r## [1] \u0026quot;Vermont\u0026quot;\rIf we try it again with a rate of 0.25, we get a different answer:\nif(murder_rate[ind] \u0026lt; 0.25){\rprint(murders$state[ind])\r} else{\rprint(\u0026quot;No state has a murder rate that low.\u0026quot;)\r}\r## [1] \u0026quot;No state has a murder rate that low.\u0026quot;\rA related function that is very useful is ifelse. This function takes three arguments: a logical and two possible answers. If the logical is TRUE, the value in the second argument is returned and if FALSE, the value in the third argument is returned. Here is an example:\na \u0026lt;- 0\rifelse(a \u0026gt; 0, 1/a, NA)\r## [1] NA\rThe function is particularly useful because it works on vectors. It examines each entry of the logical vector and returns elements from the vector provided in the second argument, if the entry is TRUE, or elements from the vector provided in the third argument, if the entry is FALSE.\na \u0026lt;- c(0, 1, 2, -4, 5)\rresult \u0026lt;- ifelse(a \u0026gt; 0, 1/a, NA)\rThis table helps us see what happened:\r\r\r\ra\r\ris_a_positive\r\ranswer1\r\ranswer2\r\rresult\r\r\r\r\r\r0\r\rFALSE\r\rInf\r\rNA\r\rNA\r\r\r\r1\r\rTRUE\r\r1.00\r\rNA\r\r1.0\r\r\r\r2\r\rTRUE\r\r0.50\r\rNA\r\r0.5\r\r\r\r-4\r\rFALSE\r\r-0.25\r\rNA\r\rNA\r\r\r\r5\r\rTRUE\r\r0.20\r\rNA\r\r0.2\r\r\r\r\rHere is an example of how this function can be readily used to replace all the missing values in a vector with zeros:\ndata(na_example)\rno_nas \u0026lt;- ifelse(is.na(na_example), 0, na_example)\rsum(is.na(no_nas))\r## [1] 0\rTwo other useful functions are any and all. The any function takes a vector of logicals and returns TRUE if any of the entries is TRUE. The all function takes a vector of logicals and returns TRUE if all of the entries are TRUE. Here is an example:\nz \u0026lt;- c(TRUE, TRUE, FALSE)\rany(z)\r## [1] TRUE\rall(z)\r## [1] FALSE\r\rDefining functions\rAs you become more experienced, you will find yourself needing to perform the same operations over and over. A simple example is computing averages. We can compute the average of a vector x using the sum and length functions: sum(x)/length(x). Because we do this repeatedly, it is much more efficient to write a function that performs this operation. This particular operation is so common that someone already wrote the mean function and it is included in base R. However, you will encounter situations in which the function does not already exist, so R permits you to write your own. A simple version of a function that computes the average can be defined like this:\navg \u0026lt;- function(x){\rs \u0026lt;- sum(x)\rn \u0026lt;- length(x)\rs/n\r}\rNow avg is a function that computes the mean:\nx \u0026lt;- 1:100\ridentical(mean(x), avg(x))\r## [1] TRUE\rNotice that variables defined inside a function are not saved in the workspace. So while we use s and n when we call avg, the values are created and changed only during the call. Here is an illustrative example:\ns \u0026lt;- 3\ravg(1:10)\r## [1] 5.5\rs\r## [1] 3\rNote how s is still 3 after we call avg.\nIn general, functions are objects, so we assign them to variable names with \u0026lt;-. The function function tells R you are about to define a function. The general form of a function definition looks like this:\nmy_function \u0026lt;- function(VARIABLE_NAME){\rperform operations on VARIABLE_NAME and calculate VALUE\rVALUE\r}\rThe functions you define can have multiple arguments as well as default values. For example, we can define a function that computes either the arithmetic or geometric average depending on a user defined variable like this:\navg \u0026lt;- function(x, arithmetic = TRUE){\rn \u0026lt;- length(x)\rifelse(arithmetic, sum(x)/n, prod(x)^(1/n))\r}\rWe will learn more about how to create functions through experience as we face more complex tasks.\n\rNamespaces\rOnce you start becoming more of an R expert user, you will likely need to load several add-on packages for some of your analysis. Once you start doing this, it is likely that two packages use the same name for two different functions. And often these functions do completely different things. In fact, you have already encountered this because both dplyr and the R-base stats package define a filter function. There are five other examples in dplyr. We know this because when we first load dplyr we see the following message:\nThe following objects are masked from ‘package:stats’:\rfilter, lag\rThe following objects are masked from ‘package:base’:\rintersect, setdiff, setequal, union\rSo what does R do when we type filter? Does it use the dplyr function or the stats function? From our previous work we know it uses the dplyr one. But what if we want to use the stats version?\nThese functions live in different namespaces. R will follow a certain order when searching for a function in these namespaces. You can see the order by typing:\nsearch()\rThe first entry in this list is the global environment which includes all the objects you define.\nSo what if we want to use the stats filter instead of the dplyr filter but dplyr appears first in the search list? You can force the use of a specific namespace by using double colons (::) like this:\nstats::filter\rIf we want to be absolutely sure that we use the dplyr filter, we can use\ndplyr::filter\rAlso note that if we want to use a function in a package without loading the entire package, we can use the double colon as well.\nFor more on this more advanced topic we recommend the R packages book1.\n\rFor-loops\rIf we had to write this section in a single sentence, it would be: Don’t use for-loops. Looping is intuitive, but R is designed to provide more computationally efficient solutions. For-loops should be considered a quick-and-dirty way to get an answer. But, hey, you live your own life. Below we provide a brief overview to for-looping.\nThe formula for the sum of the series \\(1+2+\\dots+n\\) is \\(n(n+1)/2\\). What if we weren’t sure that was the right function? How could we check? Using what we learned about functions we can create one that computes the \\(S_n\\):\ncompute_s_n \u0026lt;- function(n){\rx \u0026lt;- 1:n\rsum(x)\r}\rHow can we compute \\(S_n\\) for various values of \\(n\\), say \\(n=1,\\dots,25\\)? Do we write 25 lines of code calling compute_s_n? No, that is what for-loops are for in programming. In this case, we are performing exactly the same task over and over, and the only thing that is changing is the value of \\(n\\). For-loops let us define the range that our variable takes (in our example \\(n=1,\\dots,10\\)), then change the value and evaluate expression as you loop.\nPerhaps the simplest example of a for-loop is this useless piece of code:\nfor(i in 1:5){\rprint(i)\r}\r## [1] 1\r## [1] 2\r## [1] 3\r## [1] 4\r## [1] 5\rHere is the for-loop we would write for our \\(S_n\\) example:\nm \u0026lt;- 25\rs_n \u0026lt;- vector(length = m) # create an empty vector\rfor(n in 1:m){\rs_n[n] \u0026lt;- compute_s_n(n)\r}\rIn each iteration \\(n=1\\), \\(n=2\\), etc…, we compute \\(S_n\\) and store it in the \\(n\\)th entry of s_n.\nNow we can create a plot to search for a pattern:\nn \u0026lt;- 1:m\rplot(n, s_n)\rIf you noticed that it appears to be a quadratic, you are on the right track because the formula is \\(n(n+1)/2\\).\r--\n\rVectorization and functionals\rAlthough for-loops are an important concept to understand, in R we rarely use them. As you learn more R, you will realize that vectorization is preferred over for-loops since it results in shorter and clearer code. (It’s also vastly more efficient computationally, which can matter as your data grows.) A vectorized function is a function that will apply the same operation on each of the vectors.\nx \u0026lt;- 1:10\rsqrt(x)\r## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\r## [9] 3.000000 3.162278\ry \u0026lt;- 1:10\rx*y\r## [1] 1 4 9 16 25 36 49 64 81 100\rTo make this calculation, there is no need for for-loops. However, not all functions work this way. For instance, the function we just wrote, compute_s_n, does not work element-wise since it is expecting a scalar. This piece of code does not run the function on each entry of n:\nn \u0026lt;- 1:25\rcompute_s_n(n)\rFunctionals are functions that help us apply the same function to each entry in a vector, matrix, data frame, or list. Here we cover the functional that operates on numeric, logical, and character vectors: sapply.\nThe function sapply permits us to perform element-wise operations on any function. Here is how it works:\nx \u0026lt;- 1:10\rsapply(x, sqrt)\r## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\r## [9] 3.000000 3.162278\rEach element of x is passed on to the function sqrt and the result is returned. These results are concatenated. In this case, the result is a vector of the same length as the original x. This implies that the for-loop above can be written as follows:\nn \u0026lt;- 1:25\rs_n \u0026lt;- sapply(n, compute_s_n)\rOther functionals are apply, lapply, tapply, mapply, vapply, and replicate. We mostly use sapply, apply, and replicate in this book, but we recommend familiarizing yourselves with the others as they can be very useful.\n\rExercises\rThis is your first weekly lab assignment. Each lab assignment will need to be done in Rmarkdown using the lab template, just right-click and Save As…Start a new folder on your drive for this course, and inside that a new folder for lab assignments, and inside that a new folder for Lab No. 0. Rmarkdown will place some intermediate files in that folder, so leaving .Rmd files on your desktop will make things messy, fast.\nOnce you’ve saved the file, open it up in Rstudio.\n\rChange the title to “Lab 0”\n\rPut your name on it\n\rLeave the date alone. That little `r Sys.time(...)` will ask R to return the date (with M-D-Y formatting), which Rmarkdown will put in as if you had typed in the actual date. Note - if your system time is rendered in unicode characters (which may be the case in some languages), you will get an error. If this happens, you’ll have to manually change the date in the header along with your name.\n\rWhen you type ## 1. Text of..., Markdown will recognize “1. Text of” as a header and will automatically make it big.\n\rSo please copy the number and text of the question you are answering here.\r\rNext will be the ```{r q1} text that will be in gray. R will recognize this as code and will treat it as such. Anything run in that block will have an output.\n\rIf you want to see what the code will do, copy the code and paste it into the gray area. Then, click the green right arrow in the top-right corner of the gray code chunk. It should show you the results.\n\rUse the results (plus your understanding of the code) to answer the question\n\r\rWith each completed question, clidk the “Knit” button up above the script window. Rmarkdown will create a .pdf for you of your work (as long as it doesn’t hit any R errors). Knit often to make sure you haven’t hit an error!\n\rThe \\newpage line is a Latex command (the program that makes the typesetting look nice). It will start a new pdf page.\n\rOn the next page, copy question #2 to a new header using ##.\n\rOnce done, render one last .pdf, proofread it, and turn it in on D2L!\n\r\rFor more on using R Markdown, see the R Markdown page of our course resources. You can also learn about the general Markdown language on our Markdown page of our course resources\nEXERCISES\nIn your first code chunk, load the package library tidyverse, which you will need for Question 8. Always load all your package libraries at the top, in the first code chunk!\n\rWhat will this conditional expression return and why?\n\r\rx \u0026lt;- c(1,2,-3,4)\rif(all(x\u0026gt;0)){\rprint(\u0026quot;All Postives\u0026quot;)\r} else{\rprint(\u0026quot;Not all positives\u0026quot;)\r}\rWhich of the following expressions is always FALSE when at least one entry of a logical vector x is TRUE?\r\rall(x)\rany(x)\rany(!x)\rall(!x)\r\rThe function nchar tells you how many characters long a character vector is. Write a line of code that assigns a new column in murders called new_names that is equal to the state column. Then, replace new_names with the corresponding state abbreviation when the state name is longer than 8 characters.\n\rCreate a function sum_n that for any given value, say \\(n\\), computes the sum of the integers from 1 to n (inclusive). Use the function to determine the sum of integers from 1 to 5,000.\n\rCreate a function altman_plot that takes two arguments, x and y, and plots the difference against the sum. That is, the difference should be on the y-axis and the and the sum should be on the x-axis. Use it to make an altman plot of x \u0026lt;- c(5,7,9) and y \u0026lt;- c(10,11,12). When your function creates the plot, it will output automatically in your Rmarkdown knitted .pdf.\n\rAfter running the code below, what is the value of x and why?\n\r\rx \u0026lt;- 3\rmy_func \u0026lt;- function(y){\rx \u0026lt;- 5\ry+5\r}\rWrite a function compute_s_n that for any given \\(n\\) computes the sum \\(S_n = 1^2 + 2^2 + 3^2 + \\dots n^2\\). Report the value of the sum when \\(n=10\\).\n\rDefine an empty numerical vector s_n of size 25 using s_n \u0026lt;- vector(\"numeric\", 25) and store in the results of \\(S_1, S_2, \\dots S_{25}\\) using a for-loop.\n\rRepeat exercise 8, but this time use sapply.\n\rRepeat exercise 8, but this time use map_dbl.\n\rPlot \\(S_n\\) versus \\(n\\). Use points defined by \\(n=1,\\dots,25\\).\n\rConfirm that the equivalent formula for this sum is \\(S_n= n(n+1)(2n+1)/6\\). To do so, compare whether compute_s_n gives the same result for the vector s_n as the equivalent formula for the sum.\n\r\r\r\r\r\rhttp://r-pkgs.had.co.nz/namespace.html↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661857285,"objectID":"5e86e029830987df59b0fed9d67636a4","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/00-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/00-assignment/","section":"assignment","summary":"Programming basics\r\rConditional expressions\rDefining functions\rNamespaces\rFor-loops\rVectorization and functionals\rExercises\r\r\r\rYou must turn in a PDF document knitted from your R Markdown code. Submit this to “Lab 0” on D2L by 11:59 PM on Monday September 5th. You do not need to submit your .rmd file code - just the properly-knitted PDF.\nNOTE:\nAs you read through this assignment, practice with each of the examples (copy-paste them into an empty R script and run them).","tags":null,"title":"Programming Basics in R","type":"docs"},{"authors":null,"categories":null,"content":"\r\rUsing ggplot2\r\rHow to use ggplot2 – the too-fast and wholly unclear recipe\r\rMappings Link Data to Things You See\rThe Recipe\r\rMapping Aesthetics vs Setting them\r\r\r\rNOTE\nYou must turn in a PDF document of your R markdown code. Submit this to D2L by 11:59 PM on September 12th.\n\rOur primary tool for data visualization in the course will be ggplot. Technically, we’re using ggplot2; the o.g. version lacked some of the modern features of its big brother. ggplot2 implements the grammar of graphics, a coherent and relatively straightforward system for describing and building graphs. With ggplot2, you can do more faster by learning one system and applying it in many places. Other languages provide more specific tools, but require you to learn a different tool for each application. In this class, we’ll dig into a single package for our visuals.\nUsing ggplot2\rIn order to get our hands dirty, we will first have to load ggplot2. To do this, and to access the datasets, help pages, and functions that we will use in this assignment, we will load the so-called tidyverse by running this code:\nlibrary(tidyverse)\rIf you run this code and get an error message “there is no package called ‘tidyverse’”, you’ll need to first install it, then run library() once again. To install packages in R, we utilize the simple function install.packages(). In this case, we would write:\ninstall.packages(\u0026quot;tidyverse\u0026quot;)\rlibrary(tidyverse)\rOnce we’re up and running, we’re ready to dive into some basic exercises. ggplot2 works by specifying the connections between the variables in the data and the colors, points, and shapes you see on the screen. These logical connections are called aesthetic mappings or simply aesthetics.\nHow to use ggplot2 – the too-fast and wholly unclear recipe\r\rdata =: Define what your data is. For instance, below we’ll use the mpg data frame found in ggplot2 (by using ggplot2::mpg). As a reminder, a data frame is a rectangular collection of variables (in the columns) and observations (in the rows). This structure of data is often called a “table” but we’ll try to use terms slightly more precisely. The mpg data frame contains observations collected by the US Environmental Protection Agency on 38 different models of car.\n\rmapping = aes(...): How to map the variables in the data to aesthetics\n\rAxes, size of points, intensities of colors, which colors, shape of points, lines/points\r\rThen say what type of plot you want:\n\rboxplot, scatterplot, histogram, …\rthese are called ‘geoms’ in ggplot’s grammar, such as geom_point() giving scatter plots\r\r\rlibrary(ggplot2)\r... + geom_point() # Produces scatterplots\r... + geom_bar() # Bar plots\r.... + geom_boxplot() # boxplots\r... #\rYou link these steps by literally adding them together with + as we’ll see.\nTry it: What other types of plots are there? Try to find several more geom_ functions.\n\r\rMappings Link Data to Things You See\rlibrary(gapminder)\rlibrary(ggplot2)\rgapminder::gapminder\r## # A tibble: 1,704 × 6\r## country continent year lifeExp pop gdpPercap\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Afghanistan Asia 1952 28.8 8425333 779.\r## 2 Afghanistan Asia 1957 30.3 9240934 821.\r## 3 Afghanistan Asia 1962 32.0 10267083 853.\r## 4 Afghanistan Asia 1967 34.0 11537966 836.\r## 5 Afghanistan Asia 1972 36.1 13079460 740.\r## 6 Afghanistan Asia 1977 38.4 14880372 786.\r## 7 Afghanistan Asia 1982 39.9 12881816 978.\r## 8 Afghanistan Asia 1987 40.8 13867957 852.\r## 9 Afghanistan Asia 1992 41.7 16317921 649.\r## 10 Afghanistan Asia 1997 41.8 22227415 635.\r## # … with 1,694 more rows\rp \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp))\rp + geom_point()\rAbove we’ve loaded a different dataset and have started to explore a particular relationship. Before putting in this code yourself, try to intuit what might be going on.\nAny ideas?\nHere’s a breakdown of everything that happens after the p\u0026lt;- ggplot() call:\n\rdata = gapminder tells ggplot to use gapminder dataset, so if variable names are mentioned, they should be looked up in gapminder\rmapping = aes(...) shows that the mapping is a function call. There is a deeper logic to this that I will disucss below, but it’s easiest to simply accept that this is how you write it. Put another way, the mapping = aes(...) argument links variables to things you will see on the plot.\raes(x = gdpPercap, y = lifeExp) maps the GDP data onto x, which is a known aesthetic (the x-coordinate) and life expectancy data onto y\r\rx and y are predefined names that are used by ggplot and friends\r\r\rExercise 1:\nLet’s return to the mpg data. Among the variables in mpg are:\n\rdispl, a car’s engine size, in litres.\n\rhwy, a car’s fuel efficiency on the highway, in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance.\n\r\rGenerate a scatterplot between these two variables. Does it capture the intuitive relationship you expected? What happens if you make a scatterplot of class vs drv? Why is the plot not useful?\n\rIt turns out there’s a reason for doing all of this:\n\r“The greatest value of a picture is when it forces us to notice what we never expected to see.”” — John Tukey\n\rIn the plot you made above, one group of points seems to fall outside of the linear trend. These cars have a higher mileage than you might expect. How can you explain these cars?\nLet’s hypothesize that the cars are hybrids. One way to test this hypothesis is to look at the class value for each car. The class variable of the mpg dataset classifies cars into groups such as compact, midsize, and SUV. If the outlying points are hybrids, they should be classified as compact cars or, perhaps, subcompact cars (keep in mind that this data was collected before hybrid trucks and SUVs became popular).\nYou can add a third variable, like class, to a two dimensional scatterplot by mapping it to an aesthetic. An aesthetic is a visual property of the objects in your plot. Aesthetics include things like the size, the shape, or the color of your points. You can display a point (like the one below) in different ways by changing the values of its aesthetic properties. Since we already use the word “value” to describe data, let’s use the word “level” to describe aesthetic properties. Thus, we are interested in exploring class as a level.\nYou can convey information about your data by mapping the aesthetics in your plot to the variables in your dataset. For example, you can map the colors of your points to the class variable to reveal the class of each car. To map an aesthetic to a variable, associate the name of the aesthetic to the name of the variable inside aes(). ggplot2 will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable, a process known as scaling. ggplot2 will also add a legend that explains which levels correspond to which values.\nExercise 2:\nUsing your previous scatterplot of displ and hwy, map the colors of your points to the class variable to reveal the class of each car. What conclusions can we make?\n\rLet’s explore our previously saved p in greater detail. As with Exercise 1, we’ll add a layer. This says how some data gets turned into concrete visual aspects.\np + geom_point()\rp + geom_smooth()\rNote: Both of the above geom’s use the same mapping, where the x-axis represents gdpPercap and the y-axis represents lifeExp. You can find this yourself with some ease. But the first one maps the data to individual points, the other one maps it to a smooth line with error ranges.\nWe get a message that tells us that geom_smooth() is using the method = ‘gam’, so presumably we can use other methods. Let’s see if we can figure out which other methods there are.\n?geom_smooth\rp + geom_point() + geom_smooth() + geom_smooth(method = ...) + geom_smooth(method = ...)\rp + geom_point() + geom_smooth() + geom_smooth(method = ...) + geom_smooth(method = ..., color = \u0026quot;red\u0026quot;)\rYou may start to see why ggplot2’s way of breaking up tasks is quite powerful: the geometric objects can all reuse the same mapping of data to aesthetics, yet the results are quite different. And if we want later geoms to use different mappings, then we can override them – but it isn’t necessary.\nConsider the output we’ve explored thus far. One potential issue lurking in the data is that most of it is bunched to the left. If we instead used a logarithmic scale, we should be able to spread the data out better.\np + geom_point() + geom_smooth(method = \u0026quot;lm\u0026quot;) + scale_x_log10()\rTry it: Describe what the scale_x_log10() does. Why is it a more evenly distributed cloud of points now? (2-3 sentences.)\nNice. We’re starting to get somewhere. But, you might notice that the x-axis now has scientific notation. Let’s change that.\nlibrary(scales)\rp + geom_point() +\rgeom_smooth(method = \u0026quot;lm\u0026quot;) +\rscale_x_log10(labels = scales::dollar)\rp + geom_point() +\rgeom_smooth(method = \u0026quot;lm\u0026quot;) +\rscale_x_log10(labels = scales::...)\rTry it: What does the dollar() call do? How can you find other ways of relabeling the scales when using scale_x_log10()?\n?dollar()\r\rThe Recipe\rTell the ggplot() function what our data is.\rTell ggplot() what relationships we want to see. For convenience we will put the results of the first two steps in an object called p.\rTell ggplot how we want to see the relationships in our data.\rLayer on geoms as needed, by adding them on the p object one at a time.\rUse some additional functions to adjust scales, labels, tickmarks, titles.\r\r\re.g. scale_, labs(), and guides() functions\r\rAs you start to run more R code, you’re likely to run into problems. Don’t worry — it happens to everyone. I have been writing code in numerous languages for years, and every day I still write code that doesn’t work. Sadly, R is particularly persnickity, and its error messages are often opaque.\nStart by carefully comparing the code that you’re running to the code in these notes. R is extremely picky, and a misplaced character can make all the difference. Make sure that every ( is matched with a ) and every ” is paired with another “. Sometimes you’ll run the code and nothing happens. Check the left-hand of your console: if it’s a +, it means that R doesn’t think you’ve typed a complete expression and it’s waiting for you to finish it. In this case, it’s usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.\nOne common problem when creating ggplot2 graphics is to put the + in the wrong place: it has to come at the end of the line, not the start.\nMapping Aesthetics vs Setting them\rp \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp, color = \u0026#39;yellow\u0026#39;))\rp + geom_point() + scale_x_log10()\rThis is interesting (or annoying): the points are not yellow. How can we tell ggplot to draw yellow points?\np \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp, ...))\rp + geom_point(...) + scale_x_log10()\rTry it: describe in your words what is going on.\rOne way to avoid such mistakes is to read arguments inside aes(\u0026lt;property\u0026gt; = \u0026lt;variable\u0026gt;)as the property  in the graph is determined by the data in .\nTry it: Write the above sentence for the original call aes(x = gdpPercap, y = lifeExp, color = 'yellow').\nAesthetics convey information about a variable in the dataset, whereas setting the color of all points to yellow conveys no information about the dataset - it changes the appearance of the plot in a way that is independent of the underlying data.\nRemember: color = 'yellow' and aes(color = 'yellow') are very different, and the second makes usually no sense, as 'yellow' is treated as data.\np \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp))\rp + geom_point() + geom_smooth(color = \u0026quot;orange\u0026quot;, se = FALSE, size = 8, method = \u0026quot;lm\u0026quot;) + scale_x_log10()\rTry it: Write down what all those arguments in geom_smooth(...) do.\np + geom_point(alpha = 0.3) +\rgeom_smooth(method = \u0026quot;gam\u0026quot;) +\rscale_x_log10(labels = scales::dollar) +\rlabs(x = \u0026quot;GDP Per Capita\u0026quot;, y = \u0026quot;Life Expectancy in Years\u0026quot;,\rtitle = \u0026quot;Economic Growth and Life Expectancy\u0026quot;,\rsubtitle = \u0026quot;Data Points are country-years\u0026quot;,\rcaption = \u0026quot;Source: Gapminder\u0026quot;)\rColoring by continent:\nlibrary(scales)\rp \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))\rp + geom_point()\rp + geom_point() + scale_x_log10(labels = dollar)\rp + geom_point() + scale_x_log10(labels = dollar) + geom_smooth()\rTry it: What does fill = continent do? What do you think about the match of colors between lines and error bands?\np \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp))\rp + geom_point(mapping = aes(color = continent)) + geom_smooth() + scale_x_log10()\rTry it: Notice how the above code leads to a single smooth line, not one per continent. Why?\nTry it: What is bad about the following example, assuming the graph is the one we want? Think about why you should set aesthetics at the top level rather than at the individual geometry level if that’s your intent.\np \u0026lt;- ggplot(data = gapminder,\rmapping = aes(x = gdpPercap, y = lifeExp))\rp + geom_point(mapping = aes(color = continent)) +\rgeom_smooth(mapping = aes(color = continent, fill = continent)) +\rscale_x_log10() +\rgeom_smooth(mapping = aes(color = continent), method = \u0026quot;gam\u0026quot;)\rExercise 3:\nGenerate two new plots with data = gapminder (note: you’ll need to install the package by the same name if you have not already). Label the axes and the header with clear, easy to understand language. In a few sentences, describe what you’ve visualized and why.\nNote that this is your first foray into ggplot2; accordingly, you should try to make sure that you do not bite off more than you can chew. We will improve and refine our abilities as we progress through the semester.\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"94cae82c16c517ab19420570e5d8c2ad","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/01-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/01-assignment/","section":"assignment","summary":"Using ggplot2\r\rHow to use ggplot2 – the too-fast and wholly unclear recipe\r\rMappings Link Data to Things You See\rThe Recipe\r\rMapping Aesthetics vs Setting them\r\r\r\rNOTE\nYou must turn in a PDF document of your R markdown code. Submit this to D2L by 11:59 PM on September 12th.\n\rOur primary tool for data visualization in the course will be ggplot.","tags":null,"title":"Basics of ggplot","type":"docs"},{"authors":null,"categories":null,"content":"\r\rPreliminaries\rBackground\r\rR Markdown\rData Prep\r\rGetting help\rTurning everything in\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, September 19th.\n\rPreliminaries\rAs always, we will first have to load ggplot2. To do this, we will load the tidyverse by running this code:\nlibrary(tidyverse)\r\rBackground\rThe New York City Department of Buildings (DOB) maintains a list of construction sites that have been categorized as “essential” during the city’s shelter-in-place pandemic order. They’ve provided an interactive map here where you can see the different projects. There’s also a link there to download the complete dataset.\nFor this exercise, you’re going to use this data to visualize the amounts or proportions of different types of essential projects in the five boroughs of New York City (Brooklyn, Manhattan, the Bronx, Queens, and Staten Island).\nAs you hopefully figured out by now, you’ll be doing all your R work in R Markdown. You can use an RStudio Project to keep your files well organized (either on your computer or on RStudio.cloud), but this is optional. If you decide to do so, either create a new project for this exercise only, or make a project for all your work in this class.\nYou’ll need to download one CSV file and put it somewhere on your computer (or upload it to RStudio.cloud if you’ve gone that direction)—preferably in a folder named data in your project folder. You can download the data from the DOB’s map, or use this link to get it directly:\n\r EssentialConstruction.csv\r\rR Markdown\rWriting regular text with R Markdown follows the rules of Markdown. You can make lists; different-size headers, etc. This should be relatively straightfoward. We talked about a few Markdown features like bold and italics in class. See this resource for more formatting.\nYou’ll also need to insert your own code chunks where needed. Rather than typing them by hand (that’s tedious and you might miscount the number of backticks!), use the “Insert” button at the top of the editing window, or type ctrl + alt + i on Windows, or ⌘ + ⌥ + i on macOS.\n\rData Prep\rOnce you download the EssentialConstruction.csv file and save it in your project folder, you can open it and start cleaning. I’ll help with that. I’ll give you a .Rmd that will get you started on the Exercises below. Download this and use it in place of your lab assignment template.\n\r 02-lab.Rmd\r\rExercise 1 of 1: Essential pandemic construction\nUsing the Lab 02 template above, do the following:\nA. Show the count or proportion of approved projects by borough using a bar chart. Make sure all the elements of your plot (axes, legend, etc.) are labeled.\nB. Show the count or proportion of approved projects by category using a lollipop chart. Not sure of what a lollipop chart is? Google R ggplot lollipop. A huge portion of knowing how to code is knowing how to google, find examples, and figure out where to put your variables from your data! Make sure all the elements of your plot (axes, legend, etc.) are labeled.\nYou don’t need to make these super fancy, but if you’re feeling brave, experiment with adding a labs() layer or changing fill colors with scale_fill_manual() or with palettes.\nBonus\nOverlay the data from Part 1 above onto a map of NYC. Make sure all the elements of your plot (axes, legend, etc.) are labeled.\n\r\r\rGetting help\rUse the SSC442 Slack if you get stuck (click the Slack logo at the top right of this website header).\n\rTurning everything in\rWhen you’re all done, click on the “Knit” button at the top of the editing window and create a PDF. Upload the PDF file to D2L.\n\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"b6a0ce80cabafe6d7d9f272294abfa85","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/02-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/02-assignment/","section":"assignment","summary":"Preliminaries\rBackground\r\rR Markdown\rData Prep\r\rGetting help\rTurning everything in\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, September 19th.\n\rPreliminaries\rAs always, we will first have to load ggplot2. To do this, we will load the tidyverse by running this code:\nlibrary(tidyverse)\r\rBackground\rThe New York City Department of Buildings (DOB) maintains a list of construction sites that have been categorized as “essential” during the city’s shelter-in-place pandemic order.","tags":null,"title":"Applying ggplot2 to Real Data","type":"docs"},{"authors":null,"categories":null,"content":"\r\rGetting started\r\rBonus Exercise\rTurning everything in\rPostscript: how we got this unemployment data\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, September 26th\n\rGetting started\rFor this exercise you’ll use state-level unemployment data from 2006 to 2016 that comes from the US Bureau of Labor Statistics (if you’re curious, we describe how we built this dataset down below).\n\r unemployment.csv\r\rIn the end, to help you master file organization, we suggest that the structure of your project directory should look something like this:\nyour-project-name\\\r03-lab.Rmd\ryour-project-name.Rproj\rdata\\\runemployment.csv\rThe example for this week will be incredibly helpful for this exercise. Reference it.\nFor this week, you need to start making your plots look nice. For full credit, you will have to label axes, label the plot, and experiment with themes. Experiment with adding a labs() layer or changing colors. Or, if you’re super brave, try modifying a theme and its elements. Default plots will not receive full credit.\nEXERCISE 1\nUse data from the US Bureau of Labor Statistics (BLS) to show the trends in employment rate for all 50 states plus DC between 2006 and 2016. Your first instinct might be to put all 50 lines on graph. This will be a mess, so let’s give each state its own plot – use facet_grid or facet_wrap to do this. What stories does this plot tell? Which states struggled to recover from the 2008–09 recession?\nSome hints/tips:\n\rYou won’t need to filter out any missing rows because the data here is complete—there are no state-year combinations with missing unemployment data.\n\rYou’ll be plotting 51 facets. You can filter out DC if you want to have a better grid (like 5 × 10).\n\rPlot the date column along the x-axis, not the year column. If you plot by year, you’ll get weird looking lines (try it for fun?), since these observations are monthly. If you really want to plot by year only, you’ll need to create a different data frame where you group by year and state and calculate the average unemployment rate for each year/state combination (i.e. group_by(year, state) %\u0026gt;% summarize(avg_unemployment = mean(unemployment)))\n\rTry mapping other aesthetics onto the graph too. You’ll notice there are columns for region and division—play with those as colors, for instance.\n\rThis plot might be big, so make sure you adjust fig.width and fig.height in the chunk options so that it’s visible when you knit it - try different values and knit to see how they look.\n\r\rEXERCISE 2\nUse data from the BLS to create a slopegraph that compares the unemployment rate in January 2006 with the unemployment rate in January 2009, either for all 50 states at once (good luck with that!) or for a specific region or division. Make sure the plot doesn’t look too busy or crowded in the end.\nWhat story does this plot tell? Which states in the US (or in the specific region you selected) were the most/least affected the Great Recession?\nSome hints/tips:\n\rYou should use filter() to only select rows where the year is 2006 or 2009 (i.e. filter(year %in% c(2006, 2009)) and to select rows where the month is January (filter(month == 1) or filter(month_name == \"January\"))\n\rIn order for the year to be plotted as separate categories on the x-axis, it needs to be a factor, so use mutate(year = factor(year)) to convert it.\n\rTo make ggplot draw lines between the 2006 and 2009 categories, you need to include group = state in the aesthetics.\n\r\r\rBonus Exercise\rThis is entirely optional but might be fun. Then again, it might not be fun. I don’t know.\nFor extra fun times, if you feel like it, create a bump chart showing something from the unemployment data (perhaps the top 10 states or bottom 10 states in unemployment?) Adapt the code in the example for today’s session.\nIf you do this, plotting 51 lines is going to be a huge mess. But filtering the data is also a bad idea, because states could drop in and out of the top/bottom 10 over time, and we don’t want to get rid of them. Instead, you can zoom in on a specific range of data in your plot with coord_cartesian(ylim = c(1, 10)), for instance.\n\rTurning everything in\rWhen you’re all done, click on the “Knit” button at the top of the editing window and create a PDF. Upload the PDF file to D2L.\n\rPostscript: how we got this unemployment data\rFor the curious, here’s the code we used to download the unemployment data from the BLS.\nAnd to pull the curtain back and show how much googling is involved in data visualization (and data analysis and programming in general), here was my process for getting this data:\nWe thought “We want to have students show variation in something domestic over time” and then we googled “us data by state”. Nothing really came up (since it was an exceedingly vague search in the first place), but some results mentioned unemployment rates, so we figured that could be cool.\n\rWe googled “unemployment statistics by state over time” and found that the BLS keeps statistics on this. We clicked on the “Data Tools” link in their main navigation bar, clicked on “Unemployment”, and then clicked on the “Multi-screen data search” button for the Local Area Unemployment Statistics (LAUS).\n\rWe walked through the multiple screens and got excited that we’d be able to download all unemployment stats for all states for a ton of years, but then the final page had links to 51 individual Excel files, which was dumb.\n\rSo we went back to Google and searched for “download bls data r” and found a few different packages people have written to do this. The first one we clicked on was blscrapeR at GitHub, and it looked like it had been updated recently, so we went with it.\n\rWe followed the examples in the blscrapeR package and downloaded data for every state.\n\r\rAnother day in the life of doing modern data science. This is an example of something you will be able to do by the end of this class. we had no idea people had written R packages to access BLS data, but there are (at least) 3 packages out there. After a few minutes of tinkering, we got it working and it is relatively straightforward.\n\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"af0b365ca488e9ad2d9f06d6c238b02e","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/03-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/03-assignment/","section":"assignment","summary":"Getting started\r\rBonus Exercise\rTurning everything in\rPostscript: how we got this unemployment data\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, September 26th\n\rGetting started\rFor this exercise you’ll use state-level unemployment data from 2006 to 2016 that comes from the US Bureau of Labor Statistics (if you’re curious, we describe how we built this dataset down below).","tags":null,"title":"Visualizing Large(ish) Data","type":"docs"},{"authors":null,"categories":null,"content":"\r\r\rStatistical models\r\rPoll aggregators\r\rPoll data\rPollster bias\r\rData-driven models\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 3rd.\n\rFor this exercise you will need to ensure that you’ve carefully read this week’s content and example. We will build on both. The exercises (which you will turn in as this week’s lab) are at the bottom. Note that this week’s lab is much more theoretical than any other week in this class. This is to ensure that you have the foundations necessary to build rich statistical models and apply them to real-world data.\nStatistical models\r\r“All models are wrong, but some are useful.” –George E. P. Box\n\rThe day before the 2008 presidential election, Nate Silver’s FiveThirtyEight stated that “Barack Obama appears poised for a decisive electoral victory”. They went further and predicted that Obama would win the election with 349 electoral votes to 189, and the popular vote by a margin of 6.1%. FiveThirtyEight also attached a probabilistic statement to their prediction claiming that Obama had a 91% chance of winning the election. The predictions were quite accurate since, in the final results, Obama won the electoral college 365 to 173 and the popular vote by a 7.2% difference. Their performance in the 2008 election brought FiveThirtyEight to the attention of political pundits and TV personalities. Four years later, the week before the 2012 presidential election, FiveThirtyEight’s Nate Silver was giving Obama a 90% chance of winning despite many of the experts thinking the final results would be closer. Political commentator Joe Scarborough said during his show1:\n\rAnybody that thinks that this race is anything but a toss-up right now is such an ideologue … they’re jokes.\n\rTo which Nate Silver responded via Twitter:\n\rIf you think it’s a toss-up, let’s bet. If Obama wins, you donate $1,000 to the American Red Cross. If Romney wins, I do. Deal?\n\rIn 2016, Silver was not as certain and gave Hillary Clinton only a 71% of winning. In contrast, most other forecasters were almost certain she would win. She lost. But 71% is still more than 50%, so was Mr. Silver wrong? And what does probability mean in this context anyway? Are dice being tossed somewhere?\nIn this lab we will demonstrate how poll aggregators, such as FiveThirtyEight, collected and combined data reported by different experts to produce improved predictions. We will introduce ideas behind the statistical models, also known as probability models, that were used by poll aggregators to improve election forecasts beyond the power of individual polls. First, we’ll motivate the models, building on the statistical inference concepts we learned in this week’s content and example. We start with relatively simple models, realizing that the actual data science exercise of forecasting elections involves rather complex ones. We will introduce such modeks towards the end of this section of the course.\nPoll aggregators\rA few weeks before the 2012 election Nate Silver was giving Obama a 90% chance of winning. How was Mr. Silver so confident? We will use a Monte Carlo simulation to illustrate the insight Mr. Silver had and others missed. To do this, we generate results for 12 polls taken the week before the election. We mimic sample sizes from actual polls and construct and report 95% confidence intervals for each of the 12 polls. We save the results from this simulation in a data frame and add a poll ID column.\nlibrary(tidyverse)\rlibrary(dslabs)\rd \u0026lt;- 0.039\rNs \u0026lt;- c(1298, 533, 1342, 897, 774, 254, 812, 324, 1291, 1056, 2172, 516)\rp \u0026lt;- (d + 1) / 2\rpolls \u0026lt;- map_df(Ns, function(N) {\rx \u0026lt;- sample(c(0,1), size=N, replace=TRUE, prob=c(1-p, p))\rx_hat \u0026lt;- mean(x)\rse_hat \u0026lt;- sqrt(x_hat * (1 - x_hat) / N)\rlist(estimate = 2 * x_hat - 1,\rlow = 2*(x_hat - 1.96*se_hat) - 1,\rhigh = 2*(x_hat + 1.96*se_hat) - 1,\rsample_size = N)\r}) %\u0026gt;% mutate(poll = seq_along(Ns))\rHere is a visualization showing the intervals the pollsters would have reported for the difference between Obama and Romney:\nNot surprisingly, all 12 polls report confidence intervals that include the election night result (dashed line). However, all 12 polls also include 0 (solid black line) as well. Therefore, if asked individually for a prediction, the pollsters would have to say: it’s a toss-up. Below we describe a key insight they are missing.\nPoll aggregators, such as Nate Silver, realized that by combining the results of different polls you could greatly improve precision. By doing this, we are effectively conducting a poll with a huge sample size. We can therefore report a smaller 95% confidence interval and a more precise prediction.\nAlthough as aggregators we do not have access to the raw poll data, we can use mathematics to reconstruct what we would have obtained had we made one large poll with:\nsum(polls$sample_size)\r## [1] 11269\rparticipants. Basically, we construct an estimate of the spread, let’s call it \\(d\\), with a weighted average in the following way:\nd_hat \u0026lt;- polls %\u0026gt;%\rsummarize(avg = sum(estimate*sample_size) / sum(sample_size)) %\u0026gt;%\rpull(avg)\rOnce we have an estimate of \\(d\\), we can construct an estimate for the proportion voting for Obama, which we can then use to estimate the standard error. Once we do this, we see that our margin of error is 0.0184545.\nThus, we can predict that the spread will be 3.1 plus or minus 1.8, which not only includes the actual result we eventually observed on election night, but is quite far from including 0. Once we combine the 12 polls, we become quite certain that Obama will win the popular vote.\nOf course, this was just a simulation to illustrate the idea. The actual data science exercise of forecasting elections is much more complicated and it involves modeling. Below we explain how pollsters fit multilevel models to the data and use this to forecast election results. In the 2008 and 2012 US presidential elections, Nate Silver used this approach to make an almost perfect prediction and silence the pundits.\nSince the 2008 elections, other organizations have started their own election forecasting group that, like Nate Silver’s, aggregates polling data and uses statistical models to make predictions. In 2016, forecasters underestimated Trump’s chances of winning greatly. The day before the election the New York Times reported2 the following probabilities for Hillary Clinton winning the presidency:\n\r\r\rNYT\r\r538\r\rHuffPost\r\rPW\r\rPEC\r\rDK\r\rCook\r\rRoth\r\r\r\r\r\rWin Prob\r\r85%\r\r71%\r\r98%\r\r89%\r\r\u0026gt;99%\r\r92%\r\rLean Dem\r\rLean Dem\r\r\r\r\rFor example, the Princeton Election Consortium (PEC) gave Trump less than 1% chance of winning, while the Huffington Post gave him a 2% chance. In contrast, FiveThirtyEight had Trump’s probability of winning at 29%, higher than tossing two coins and getting two heads. In fact, four days before the election FiveThirtyEight published an article titled Trump Is Just A Normal Polling Error Behind Clinton3.\rBy understanding statistical models and how these forecasters use them, we will start to understand how this happened.\nAlthough not nearly as interesting as predicting the electoral college, for illustrative purposes we will start by looking at predictions for the popular vote. FiveThirtyEight predicted a 3.6% advantage for Clinton4, included the actual result of 2.1% (48.2% to 46.1%) in their interval, and was much more confident about Clinton winning the election, giving her an 81.4% chance. Their prediction was summarized with a chart like this:\nThe colored areas represent values with an 80% chance of including the actual result, according to the FiveThirtyEight model.\rWe introduce actual data from the 2016 US presidential election to show how models are motivated and built to produce these predictions. To understand the “81.4% chance” statement we need to describe Bayesian statistics, which we don’t cover in this course.\nPoll data\rWe use public polling data organized by FiveThirtyEight for the 2016 presidential election. The data is included as part of the dslabs package:\ndata(polls_us_election_2016)\rThe table includes results for national polls, as well as state polls, taken during the year prior to the election. For this first example, we will filter the data to include national polls conducted during the week before the election. We also remove polls that FiveThirtyEight has determined not to be reliable and graded with a “B” or less. Some polls have not been graded and we include those:\npolls \u0026lt;- polls_us_election_2016 %\u0026gt;%\rfilter(state == \u0026quot;U.S.\u0026quot; \u0026amp; enddate \u0026gt;= \u0026quot;2016-10-31\u0026quot; \u0026amp;\r(grade %in% c(\u0026quot;A+\u0026quot;,\u0026quot;A\u0026quot;,\u0026quot;A-\u0026quot;,\u0026quot;B+\u0026quot;) | is.na(grade)))\rWe add a spread estimate:\npolls \u0026lt;- polls %\u0026gt;%\rmutate(spread = rawpoll_clinton/100 - rawpoll_trump/100)\rFor this example, we will assume that there are only two parties and call \\(p\\) the proportion voting for Clinton and \\(1-p\\) the proportion voting for Trump. We are interested in the spread \\(2p-1\\). Let’s call the spread \\(d\\) (for difference).\nWe have 49 estimates of the spread. The theory we learned tells us that these estimates are a random variable with a probability distribution that is approximately normal. The expected value is the election night spread \\(d\\) and the standard error is \\(2\\sqrt{p (1 - p) / N}\\). Assuming the urn model we described earlier is a good one, we can use this information to construct a confidence interval based on the aggregated data. The estimated spread is:\nd_hat \u0026lt;- polls %\u0026gt;%\rsummarize(d_hat = sum(spread * samplesize) / sum(samplesize)) %\u0026gt;%\rpull(d_hat)\rand the standard error is:\np_hat \u0026lt;- (d_hat+1)/2\rmoe \u0026lt;- 1.96 * 2 * sqrt(p_hat * (1 - p_hat) / sum(polls$samplesize))\rmoe\r## [1] 0.006623178\rSo we report a spread of 1.43% with a margin of error of 0.66%. On election night, we discover that the actual percentage was 2.1%, which is outside a 95% confidence interval. What happened?\nA histogram of the reported spreads shows a problem:\npolls %\u0026gt;%\rggplot(aes(spread)) +\rgeom_histogram(color=\u0026quot;black\u0026quot;, binwidth = .01)\rThe data does not appear to be normally distributed and the standard error appears to be larger than 0.0066232. The theory is not quite working here.\n\rPollster bias\rNotice that various pollsters are involved and some are taking several polls a week:\npolls %\u0026gt;% group_by(pollster) %\u0026gt;% summarize(n())\r## # A tibble: 15 × 2\r## pollster `n()`\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt;\r## 1 ABC News/Washington Post 7\r## 2 Angus Reid Global 1\r## 3 CBS News/New York Times 2\r## 4 Fox News/Anderson Robbins Research/Shaw \u0026amp; Company Research 2\r## 5 IBD/TIPP 8\r## 6 Insights West 1\r## 7 Ipsos 6\r## 8 Marist College 1\r## 9 Monmouth University 1\r## 10 Morning Consult 1\r## 11 NBC News/Wall Street Journal 1\r## 12 RKM Research and Communications, Inc. 1\r## 13 Selzer \u0026amp; Company 1\r## 14 The Times-Picayune/Lucid 8\r## 15 USC Dornsife/LA Times 8\rLet’s visualize the data for the pollsters that are regularly polling:\nThis plot reveals an unexpected result. First, consider that the standard error predicted by theory for each poll:\npolls %\u0026gt;% group_by(pollster) %\u0026gt;%\rfilter(n() \u0026gt;= 6) %\u0026gt;%\rsummarize(se = 2 * sqrt(p_hat * (1-p_hat) / median(samplesize)))\r## # A tibble: 5 × 2\r## pollster se\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ABC News/Washington Post 0.0265\r## 2 IBD/TIPP 0.0333\r## 3 Ipsos 0.0225\r## 4 The Times-Picayune/Lucid 0.0196\r## 5 USC Dornsife/LA Times 0.0183\ris between 0.018 and 0.033, which agrees with the within poll variation we see. However, there appears to be differences across the polls. Note, for example, how the USC Dornsife/LA Times pollster is predicting a 4% win for Trump, while Ipsos is predicting a win larger than 5% for Clinton. The theory we learned says nothing about different pollsters producing polls with different expected values. All the polls should have the same expected value. FiveThirtyEight refers to these differences as “house effects”. We also call them pollster bias.\nIn the following section, rather than use the urn model theory, we are instead going to develop a data-driven model.\n\r\rData-driven models\rFor each pollster, let’s collect their last reported result before the election:\none_poll_per_pollster \u0026lt;- polls %\u0026gt;% group_by(pollster) %\u0026gt;%\rfilter(enddate == max(enddate)) %\u0026gt;%\rungroup()\rHere is a histogram of the data for these 15 pollsters:\nqplot(spread, data = one_poll_per_pollster, binwidth = 0.01)\rIn the previous section, we saw that using the urn model theory to combine these results might not be appropriate due to the pollster effect. Instead, we will model this spread data directly.\nThe new model can also be thought of as an urn model, although the connection is not as direct. Rather than 0s (Republicans) and 1s (Democrats), our urn now contains poll results from all possible pollsters. We assume that the expected value of our urn is the actual spread \\(d=2p-1\\).\nBecause instead of 0s and 1s, our urn contains continuous numbers between -1 and 1, the standard deviation of the urn is no longer \\(\\sqrt{p(1-p)}\\). Rather than voter sampling variability, the standard error now includes the pollster-to-pollster variability. Our new urn also includes the sampling variability from the polling. Regardless, this standard deviation is now an unknown parameter. In statistics textbooks, the Greek symbol \\(\\sigma\\) is used to represent this parameter.\nIn summary, we have two unknown parameters: the expected value \\(d\\) and the standard deviation \\(\\sigma\\).\nOur task is to estimate \\(d\\). Because we model the observed values \\(X_1,\\dots X_N\\) as a random sample from the urn, the CLT might still work in this situation because it is an average of independent random variables. For a large enough sample size \\(N\\), the probability distribution of the sample average \\(\\bar{X}\\) is approximately normal with expected value \\(\\mu\\) and standard error \\(\\sigma/\\sqrt{N}\\). If we are willing to consider \\(N=15\\) large enough, we can use this to construct confidence intervals.\nA problem is that we don’t know \\(\\sigma\\). But theory tells us that we can estimate the urn model \\(\\sigma\\) with the sample standard deviation defined as\r\\(s = \\sqrt{ \\sum_{i=1}^N (X_i - \\bar{X})^2 / (N-1)}\\).\nUnlike for the population standard deviation definition, we now divide by \\(N-1\\). This makes \\(s\\) a better estimate of \\(\\sigma\\). There is a mathematical explanation for this, which is explained in most statistics textbooks, but we don’t cover it here.\nThe sd function in R computes the sample standard deviation:\nsd(one_poll_per_pollster$spread)\r## [1] 0.02419369\rWe are now ready to form a new confidence interval based on our new data-driven model:\nresults \u0026lt;- one_poll_per_pollster %\u0026gt;%\rsummarize(avg = mean(spread),\rse = sd(spread) / sqrt(length(spread))) %\u0026gt;%\rmutate(start = avg - 1.96 * se,\rend = avg + 1.96 * se)\rround(results * 100, 1)\r## avg se start end\r## 1 2.9 0.6 1.7 4.1\rOur confidence interval is wider now since it incorporates the pollster variability. It does include the election night result of 2.1%. Also, note that it was small enough not to include 0, which means we were confident Clinton would win the popular vote.\nEXERCISES\nNote that using dollar signs $ $ to enclose some text is how you make the fancy math you see below. If you installed tinytex or some other Latex distribution in order to render your PDFs, you should be equipped to insert mathematics directly into your .Rmd file. It only works in the text – inside the code chunks, the dollar sign is still the accessor.\nIn this section, we talked about pollster bias. We used visualization to motivate the presence of such bias. Here we will give it a more rigorous treatment. We will consider two pollsters that conducted daily polls. We will look at national polls for the month before the election.\r\rdata(polls_us_election_2016)\rpolls \u0026lt;- polls_us_election_2016 %\u0026gt;%\rfilter(pollster %in% c(\u0026quot;Rasmussen Reports/Pulse Opinion Research\u0026quot;,\r\u0026quot;The Times-Picayune/Lucid\u0026quot;) \u0026amp;\renddate \u0026gt;= \u0026quot;2016-10-15\u0026quot; \u0026amp;\rstate == \u0026quot;U.S.\u0026quot;) %\u0026gt;%\rmutate(spread = rawpoll_clinton/100 - rawpoll_trump/100)\rWe want to answer the question: is there a poll bias? First, make a plot showing the spreads for each poll.\nThe data does seem to suggest there is a difference. However, these data are subject to variability. Perhaps the differences we observe are due to chance.\r\rThe urn model theory says nothing about pollster effect. Under the urn model, both pollsters have the same expected value: the election day difference, that we call \\(d\\).\nWe will model the observed data \\(Y_{i,j}\\) in the following way:\n\\[\rY_{i,j} = d + b_i + \\varepsilon_{i,j}\r\\]\nwith \\(i=1,2\\) indexing the two pollsters, \\(b_i\\) the bias for pollster \\(i\\) and \\(\\varepsilon_ij\\) poll to poll chance variability. We assume the \\(\\varepsilon\\) are independent from each other, have expected value \\(0\\) and standard deviation \\(\\sigma_i\\) regardless of \\(j\\).\nWhich of the following best represents our question?\nIs \\(\\varepsilon_{i,j}\\) = 0?\rHow close are the \\(Y_{i,j}\\) to \\(d\\)?\rIs \\(b_1 \\neq b_2\\)?\rAre \\(b_1 = 0\\) and \\(b_2 = 0\\) ?\r\rSuppose we define \\(\\bar{Y}_1\\) as the average of poll results from the first pollster, \\(Y_{1,1},\\dots,Y_{1,N_1}\\) with \\(N_1\\) the number of polls conducted by the first pollster:\r\rpolls %\u0026gt;%\rfilter(pollster==\u0026quot;Rasmussen Reports/Pulse Opinion Research\u0026quot;) %\u0026gt;%\rsummarize(N_1 = n())\rWhat is the expected value of \\(\\bar{Y}_1\\)?\nWhat is the sample variance \\(s^2_1\\) of the sample \\(Y_1\\)? Using \\(s^2_1\\), what is the standard error of the mean \\(\\bar{Y}_1\\)?\n\rSuppose we define \\(\\bar{Y}_2\\) as the average of poll results from the second pollster, \\(Y_{2,1},\\dots,Y_{2,N_2}\\) with \\(N_2\\) the number of polls conducted by the second pollster. What is the expected value \\(\\bar{Y}_2\\), the sample variance \\(s^2_2\\), and the standard error of the mean \\(\\bar{Y}_2\\)?\n\rWhat does the CLT tell us about the distribution of a new random variable that is defined as \\(\\bar{Y}_2 - \\bar{Y}_1\\)?\n\r\rNothing because this is not the average of a sample.\rBecause the \\(Y_{ij}\\) are approximately normal, so are the averages.\rNote that \\(\\bar{Y}_2\\) and \\(\\bar{Y}_1\\) are sample averages, so if we assume \\(N_2\\) and \\(N_1\\) are large enough, each is approximately normal. The difference of normals is also normal.\rThe data are not 0 or 1, so CLT does not apply.\r\rThe new random variable defined as \\(\\bar{Y}_2 - \\bar{Y}_1\\) has an expected value of \\(b_2 - b_1\\). To see this, take the equation from problem 2 defined for each pollster, write out the difference, and take expectations. \\(b_2 = b_1\\) is the pollster bias difference we want to learn about statistically. If our model holds, then this random variable has an approximately normal distribution and we know its standard error – by the rules of random variable variance, the standard error is the square root of the variance of the new random variable, and the variance of the new variable is the sum of the variances minus twice the covariance (which is zero by our assumptions). The standard error of our new random variable depends on the standard errors of the \\(Y\\) above, which we already estimated in 3-5.\r\rThe statistic formed by dividing our estimate of \\(b_2-b_1\\) by its estimated standard error:\n\\[\r\\frac{\\bar{Y}_2 - \\bar{Y}_1}{\\sqrt{\\underbrace{s_2^2/N_2}_{\\text{Std error of mean from 4, squared}} + \\underbrace{s_1^2/N_1}_{\\text{Std error of mean from 5, squared}}}}\r\\]\nis called the t-statistic. Now you should be able to do the calculations necessary to answer the question: is \\(b_2 - b_1\\) different from 0? Hint: you can build a 95% confidence interval around your estimate.\n\r\r\r\rhttps://www.youtube.com/watch?v=TbKkjm-gheY↩︎\n\rhttps://www.nytimes.com/interactive/2016/upshot/presidential-polls-forecast.html↩︎\n\rhttps://fivethirtyeight.com/features/trump-is-just-a-normal-polling-error-behind-clinton/↩︎\n\rhttps://projects.fivethirtyeight.com/2016-election-forecast/↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"e52acfab5d487b6c8267ead23da8e20e","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/04-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/04-assignment/","section":"assignment","summary":"Statistical models\r\rPoll aggregators\r\rPoll data\rPollster bias\r\rData-driven models\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 3rd.\n\rFor this exercise you will need to ensure that you’ve carefully read this week’s content and example. We will build on both. The exercises (which you will turn in as this week’s lab) are at the bottom.","tags":null,"title":"Statistical Models","type":"docs"},{"authors":null,"categories":null,"content":"\r\rBackstory and Set Up\r\rData Exploration and Processing\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 10th.\n\rBackstory and Set Up\rYou have been recently hired to Zillow’s Zestimate product team as a junior analyst. As a part of their regular hazing, they have given you access to a small subset of their historic sales data. Your job is to present some basic predictions for housing values in a small geographic area (Ames, IA) using this historical pricing.\nFirst, let’s load the data.\nameslist \u0026lt;- read.table(\u0026#39;https://raw.githubusercontent.com/ajkirkpatrick/FS20/postS21_rev/classdata/ames.csv\u0026#39;, header = TRUE,\rsep = \u0026#39;,\u0026#39;) \rBefore we proceed, let’s note a few things about the (simple) code above. First, we have specified header = TRUE because—you guessed it—the original dataset has headers. Although simple, this is an incredibly important step because it allows R to do some smart R things. Specifically, once the headers are in, the variables are formatted as int and factor where appropriate. It is absolutely vital that we format the data correctly; otherwise, many R commands will whine at us.\nTry it: Run the above, but instead specifying header = FALSE. What data type are the various columns? Now try ommitting the line altogether. What is the default behavior of the read.table function?1\nData Exploration and Processing\rWe are not going to tell you anything about this data. This is intended to replicate a real-world experience that you will all encounter in the (possibly near) future: someone hands you data and you’re expected to make sense of it. Fortunately for us, this data is (somewhat) self-contained. We’ll first check the variable names to try to divine some information. Recall, we have a handy little function for that:\nnames(ameslist)\rNote that, when doing data exploration, we will sometimes choose to not save our output. This is a judgement call; here we’ve chosen to merely inspect the variables rather than diving in.\nInspection yields some obvious truths. For example:\n\r\rVariable\rExplanation\rType\r\r\r\rID\rUnique identifier for each row\rint\r\rLotArea\rSize of lot (units unknown)\rint\r\rSalePrice\rSale price of house ($)\rint\r\r\r\r…but we face some not-so-obvious things as well. For example:\n\r\rVariable\rExplanation\rType\r\r\r\rLotShape\r? Something about the lot\rfactor\r\rMSSubClass\r? No clue at all\rint\r\rCondition1\r? Seems like street info\rfactor\r\r\r\rIt will be difficult to learn anything about the data that is of type int without outside documentation. However, we can learn something more about the factor-type variables. In order to understand these a little better, we need to review some of the values that each take on.\nTry it: Go through the variables in the dataset and make a note about your interpretation for each. Many will be obvious, but some require additional thought.\nWe now turn to another central issue—and one that explains our nomenclature choice thus far: the data object is of type list. To verify this for yourself, check:\ntypeof(ameslist)\rThis isn’t ideal—for some visualization packages, for instance, we need data frames and not lists. We’ll make a mental note of this as something to potentially clean up if we desire.\nAlthough there are some variables that would be difficult to clean, there are a few that we can address with relative ease. Consider, for instance, the variable GarageType. This might not be that important, but, remember, the weather in Ames, IA is pretty crummy—a detached garage might be a dealbreaker for some would-be homebuyers. Let’s inspect the values:\n\u0026gt; unique(ameslist$GarageType)\r[1] Attchd Detchd BuiltIn CarPort \u0026lt;NA\u0026gt; Basment 2Types\rWith this, we could make an informed decision and create a new variable. Let’s create OutdoorGarage to indicate, say, homes that have any type of garage that requires the homeowner to walk outdoors after parking their car. (For those who aren’t familiar with different garage types, a car port is not insulated and is therefore considered outdoors. A detached garage presumably requires that the person walks outside after parking. The three other types are inside the main structure, and 2Types we can assume includes at least one attached garage of some sort). This is going to require a bit more coding and we will have to think through each step carefully.\nFirst, let’s create a new object that has indicator variables (that is, a variable whose values are either zero or one) for each of the GarageType values. As with everything in R, there’s a handy function to do this for us:\nGarageTemp = model.matrix( ~ GarageType - 1, data=ameslist )\rWe now have two separate objects living in our computer’s memory: ameslist and GarageTemp—so named to indicate that it is a temporary object.2 We now need to stitch it back onto our original data; we’ll use a simple concatenation and write over our old list with the new one:\nameslist \u0026lt;- cbind(ameslist, GarageTemp)\r\u0026gt; Error in data.frame(..., check.names = FALSE) :\rarguments imply differing number of rows: 1460, 1379\rHuh. What’s going on?\nTry it: Figure out what’s going on above. Fix this code so that you have a working version.\nNow that we’ve got that working (ha!) we can generate a new variable for our outdoor garage. We’ll use a somewhat gross version below because it is verbose; that said, this can be easily accomplished using logical indexing for those who like that approach.\nameslist$GarageOutside \u0026lt;- ifelse(ameslist$GarageTypeDetchd == 1 | ameslist$GarageTypeCarPort == 1, 1, 0)\runique(ameslist$GarageOutside)\r[1] 0 1 NA\rThis seems to have worked. The command above ifelse() does what it says: if some condition is met (here, either of two variables equals one) then it returns a one; else it returns a zero. Such functions are very handy, though as mentioned above, there are other ways of doing this. Also note, that while fixed the issue with NA above, we’ve got new issues: we definitely don’t want NA outputted from this operation. Accordingly, we’re going to need to deal with it somehow.\nTry it: Utilizing a similar approach to what you did above, fix this so that the only outputs are zero and one. This requires taking a stand on what the NA values mean. If you think they correspond to a detached garage (or something functionally equivalent, like “no parking whatsoever”), then change the NA values to zero. If you think they are mistakes, then we should drop all data with NA for the this column. State what you did and why.\nGenerally speaking, this is a persistent issue, and you will spend an extraordinary amount of time dealing with missing data or data that does not encode a variable exactly as you want it. This is expecially true if you deal with real-world data: you will need to learn how to handle NAs. There are a number of fixes (as always, Google is your friend) and anything that works is good. But you should spend some time thinking about this and learning at least one approach.\nEXERCISES\nPrune the data to 6-8 of the variables that are type = int about which you have some reasonable intuition for what they mean. Choose those that you believe are likely to be correlated with SalePrice. This must include the variable SalePrice and GrLivArea. Save this new dataset as Ames. Produce documentation for this object in the form of a Markdown table or see further documentation here. This must describe each of the preserved variables, the values it can take (e.g., can it be negative?) and your definition of the variable. Counting the variable name, this means your table should have three columns. Markdown tables are entered in the text body, not code chunks, of your .rmd, so your code creating Ames will be in a code chunk, and your table will be right after it.\n\rProduce a scatterplot matrix of the chosen variables3\n\rCompute a matrix of correlations between these variables using the function cor(). Do the correlations match your prior beliefs? Briefly discuss the correlation between the chosen variables and SalePrice and any correlations between these variables.\n\rProduce a scatterplot between SalePrice and GrLivArea. Run a linear model using lm() to explore the relationship. Finally, use the geom_abline() function to plot the relationship that you’ve found in the simple linear regression. You’ll need to extract the intercept and slope from your lm object. See coef(...) for information on this.4\n\rWhat is the largest outlier that is above the regression line? Produce the other information about this house.\r\r\r(Bonus) Create a visualization that shows the rise of air conditioning over time in homes in Ames.\n\r\r\r\rOf course, you could find out the defaults of the function by simply using the handy ? command. Don’t forget about this tool!↩︎\n\rIt’s not exactly true that these objects are in memory. They are… sort of. But how R handles memory is complicated and silly and blah blah who cares. It’s basically in memory.↩︎\n\rIf you are not familiar with this type of visualization, consult the book (Introduction to Statistical Learning), Chapters 2 and 3.↩︎\n\rWe could also use geom_smooth(method = 'lm') to add the regression line, but it’s good practice to work with lm objects.↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"7337e9261c3514039025dedd39df2948","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/05-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/05-assignment/","section":"assignment","summary":"Backstory and Set Up\r\rData Exploration and Processing\r\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 10th.\n\rBackstory and Set Up\rYou have been recently hired to Zillow’s Zestimate product team as a junior analyst. As a part of their regular hazing, they have given you access to a small subset of their historic sales data.","tags":null,"title":"Correlations and Simple Models","type":"docs"},{"authors":null,"categories":null,"content":"\r\rBackstory and Set Up\rBuilding a Model\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 17th. Remember, your Project 1 is due on Saturday the 15th.\n\rThis week’s lab will extend last week’s lab. The introduction is a direct repeat.\nBackstory and Set Up\rYou have been recently hired to Zillow’s Zestimate product team as a junior analyst. As a part of their regular hazing, they have given you access to a small subset of their historic sales data. Your job is to present some basic predictions for housing values in a small geographic area (Ames, IA) using this historical pricing.\nFirst, let’s load the data.\nameslist \u0026lt;- read.table(\u0026#39;https://raw.githubusercontent.com/ajkirkpatrick/FS20/postS21_rev/classdata/ames.csv\u0026#39;, header = TRUE,\rsep = \u0026#39;,\u0026#39;) \r\rBuilding a Model\rWe’re now ready to start playing with a model. We will start by using the lm() function to fit a simple linear regression\rmodel, with SalePrice as the response and lstat as the predictor.\nRecall that the basic lm() syntax is lm(y∼x,data), where y is the response, x is the predictor, and data is the data set in which these two variables are kept. Let’s quickly run this with two variables:\nlm.fit = lm(SalePrice ~ GrLivArea)\rThis yields:\rError in eval(expr, envir, enclos) : Object \"SalePrice\" not found\nThis command causes an error because R does not know where to find the variables. We can fix this by attaching the data:\nattach(Ames)\rlm.fit = lm(SalePrice ~ GrLivArea)\r# Alternatively...\rlm.fit = lm(SalePrice ~ GrLivArea, data=Ames)\rThe next line tells R that the variables are in the object known as Ames. If you haven’t created this object yet (as in the previous lab) you’ll get an error at this stage. But once we attach Ames, the first line works fine because R now recognizes the variables. Alternatively, we could specify this within the lm() call using data = Ames. We’ve presented this way because it may be new to you; choose whichever you find most reasonable.\nIf we type lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit). This gives us p-values and standard errors for the coefficients, as well as the \\(R^2\\) statistic and \\(F\\)-statistic for the entire model.1\nUtilizing these functions hels us see some interesting results. Note that we built (nearly) the simplest possible model:\n\\[\\text{SalePrice} = \\beta_0 + \\beta_1*(\\text{GrLivArea}) + \\epsilon.\\]\nBut even on its own, this model is instructive. It suggest that an increase in overall living area of 1 ft \\(^2\\) is correlated with an expected increase in sales price of $107. (Note that we cannot make causal claims!)\nSaving the model as we did above is useful because we can explore other pieces of information it stores. Specifically, we can use the names() function in order to find out what else is stored in lm.fit. Although we can extract these quan- tities by name—e.g. lm.fit$coefficients—it is safer to use the extractor functions like coef() to access them. We can also use a handy tool like plot() applied directly to lm.fit to see some interesting data that is automatically stored by the model.\nTry it: Use plot() to explore the model above. Do you suspect that some outliers have a large influence on the data? We will explore this point specifically in the future.\nWe can now go crazy adding variables to our model. It’s as simple as appending them to the previous code—though you should be careful executing this, as it will overwrite your previous output:\nlm.fit = lm(SalePrice ~ GrLivArea + LotArea)\rTry it: Does controlling for LotArea change the qualitative conclusions from the previous regression? What about the quantitative results? Does the direction of the change in the quantitative results make sense to you?\nEXERCISES\nUse the lm() function in a simple linear regression (e.g., with only one predictor) with SalePrice as the response to determine the value of a garage.\n\rUse the lm() function to perform a multiple linear regression with SalePrice as the response and all other variables from your Ames data as the predictors. Use the summary() function to print the results. Comment on the output. For instance:\n\rIs there a relationship between the predictors and the response?\rWhich predictors appear to have a statistically significant relationship to the response? (Hint: look for stars)\rWhat does the coefficient for the year variable suggest?\r\rThe : symbol allows you to create an interction term between two variables. Use the : symbols to fit a linear regression model with one well-chosen interaction effects plus your other variables. Why did you select the variables you did, and what was the result?\n\rTry a few (e.g., two) different transformations of the variables, such as \\(ln(x)\\), \\(x^2\\), \\(\\sqrt x\\). Do any of these make sense to include in a model of SalePrice? Comment on your findings.\n\r\r(Bonus; very very challenging) How might we build a model to estimate the elasticity of demand from this dataset?\n\r\r\rWhen we use the simple regression model with a single input, the \\(F\\)-stat includes the intercept term. Otherwise, it does not. See Lecture 5 for more detail.↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"e1ed0bbd55230066a650c8b68228a273","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/06-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/06-assignment/","section":"assignment","summary":"Backstory and Set Up\rBuilding a Model\r\r\rNOTE\nYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 17th. Remember, your Project 1 is due on Saturday the 15th.\n\rThis week’s lab will extend last week’s lab. The introduction is a direct repeat.\nBackstory and Set Up\rYou have been recently hired to Zillow’s Zestimate product team as a junior analyst.","tags":null,"title":"Model Building","type":"docs"},{"authors":null,"categories":null,"content":"\r\rBackstory and Set Up\rData Cleaning\r\rMany models do not like NA values\r\rLinear Models\r\rAssesing Model Accuracy\rModel Complexity\rTest-Train Split (Lab 8)\rAdding Flexibility to Linear Models\r\r\r\rYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 31st\n\rBackstory and Set Up\rYou still work for Zillow as a junior analyst (sorry). But you’re hunting a promotion. Your job is to present some more advanced predictions for housing values in a small geographic area (Ames, IA) using this historical pricing.\nAs always, let’s load the data.\nAmes \u0026lt;- read.table(\u0026#39;https://raw.githubusercontent.com/ajkirkpatrick/FS20/postS21_rev/classdata/ames.csv\u0026#39;, header = TRUE,\rsep = \u0026#39;,\u0026#39;) \r\rData Cleaning\rDo not skip this section. This isn’t your kitchen junk drawer – you can’t get away with not cleaning your data.\nOh, the Ames data yet again. It’s given us lots of trouble. Many of you have found a few variables (columns) that should be avoided. The main problem is that some columns have only one value in them, or they have only NA and one value, so once lm(...) drops the NA rows, they are left with only one value. Linear regression by OLS does not like variables that don’t vary! So, let’s be systematic about figuring out which columns in our data are to be avoided.\nThe skimr package is very helpful for seeing what our data contains. Install it, and then use skim(Ames) directly in the console (we’re just looking at data at the moment – do not put skim output into your RMarkdwon output - it will give you an error). Take a look at the “complete rate” column - this tells us the fraction of observations in that column that are NA. If it’s very small (see Alley), then that variable will be problematic. The “n_unique” column tells us if there are few or many different values - a “1” in “n_unique” is definitely going to be a problem and you must drop that variable.\nYou can make a note of those columns that have extremely low “complete rates” and drop them to start off. There are about 5-6 of them that will cause an error if we include them in a regression.\nMany models do not like NA values\rpredict has some unusual behavior that can give unexpected results. Thus far, we have mostly used predict(myOLS), which gives the predicted values from a model using the same data that estimated the model. When we ask lm (or, later, other machine learning models) to estimate a model, it will drop any rows of our data that contain a NA value for any of the variables used in the estimation. If your regression is SalePrice ~ GrLivArea, then it will check SalePrice and GrLivArea for NA’s. If you add another variable, then you add another possible set of NA values that can be dropped, and R will estimate the model on a subset of the data.\nThis will mess with your measure of \\(RMSE\\) - if you compare two models that use different sets of the data, then you aren’t really comparing the fit very well. Because of that, we need to take a moment to check our data.\nAmes has a lot of variables, and in this assignment, you’re going to be asked to construct 15 regressions of increasing complexity. So we’re going to choose 15 variables to be explanatory, one variable we want to be the target variable we predict (your choice for Lab 7), plus SalePrice, which will be our target variable for Lab 8. Make sure we have dropped any observation (row) that contains one or more NA value across the 17 columns. You should have already dropped any variable with a very low complete rate or small “n_unique” count.\nMake a character vector of the variables you think will best predict your chosen variable. Then, make a new version of Ames that contains only those 17 variables (you can use dplyr::select or any other method). Once you’ve done that, use na.omit to make a new, clean version of Ames that has (1) no NA’s in it, and (2) 16 variables of your choice (as long as one is SalePrice). This way, we know every model we make will have the same number of rows in it as none will be dropped due to NA values.\n\r\rLinear Models\rWhen exploring linear models in other classes, we often emphasize asymptotic results under distributional assumptions. That is, we make assumptions about the model in order to derive properties of large samples. This general approach is useful for creating and performing hypothesis tests. Frequently, when developing a linear regression model, part of the goal is to explain a relationship. However, this isn’t always the case. And it’s often not a valid approach, as we discussed in this week’s content.\nSo, we will ignore much of what we have learned in other classes (sorry, EC420) and instead simply use regression as a tool to predict. Instead of a model which supposedly explains relationships, we seek a model which minimizes errors.\nTo discuss linear models in the context of prediction, we return to the Ames data. Accordingly, you should utilize some of the early code from Lab 2 to hasten your progress in this lab.\nAssesing Model Accuracy\rThere are many metrics to assess the accuracy of a regression model. Most of these measure in some way the average error that the model makes. The metric that we will be most interested in is the root-mean-square error.\n\\[\r\\text{RMSE}(\\hat{f}, \\text{Data}) = \\sqrt{\\frac{1}{n}\\displaystyle\\sum_{i = 1}^{n}\\left(y_i - \\hat{f}(\\bf{x}_i)\\right)^2}\r\\]\nWhile for the sake of comparing models, the choice between RMSE and MSE is arbitrary, we have a preference for RMSE, as it has the same units as the response variable. Also, notice that in the prediction context MSE refers to an average, whereas in an ANOVA context, the denominator for MSE may not be \\(n\\).\nFor a linear model , the estimate of \\(f\\), \\(\\hat{f}\\), is given by the fitted regression line.\n\\[\r\\hat{y}({\\bf{x}_i}) = \\hat{f}({\\bf{x}_i})\r\\]\nWe can write an R function that will be useful for performing this calculation.\nrmse = function(actual, predicted) {\rsqrt(mean((actual - predicted) ^ 2))\r}\r\rModel Complexity\rAside from how well a model predicts, we will also be very interested in the complexity (flexibility) of a model. For now, we will only consider nested linear models for simplicity. Then in that case, the more predictors that a model has, the more complex the model. For the sake of assigning a numerical value to the complexity of a linear model, we will use the number of predictors, \\(p\\).\nWe write a simple R function to extract this information from a model.\nget_complexity = function(model) {\rlength(coef(model)) - 1\r}\rWhen deciding how complex of a model to use, we can utilize two techniques: forward selection or backward selection. Forward selection means that we start with the simplest model (with a single predictor) and then add one at a time until we decide to stop. Backward selection means that we start with the most complex model (with every available predictor) and then remove one at a time until we decide to stop. There are many criteria for “when to stop”. Below, we’ll try to give you some intuition on the model-building process.\nEXERCISE 1\nLoad the Ames data. Take a look at Utilities. Use the table function to see a tabulation of the values of Utilities. Do you see why this field is not likely to be useful to us, or even problematic?\n\rUsing skimr::skim, find the variables that have a complete rate of below 60% and drop them. 60% isn’t a magic number by any means, the “right” number is entirely dependent on your data. It is always standard practice to document the fields you have dropped from the data, so make sure you state which variables have been dropped. Also using skim, note the variables with values for “n_unique” equal to 1 and drop them.\n\rThen, choose one numeric variable to be your target variable (the variable you want to explain or predict), and the 15 variables you want to use to predict it - they can be numeric or categorical, both will work. Then, use na.omit to make a clean version of Ames where every variable is 100% complete. See the instructions above under “Data Cleaning”. Include SalePrice in your cleaning, but don’t use it yet – it will be the target variable for your Lab 8.\n\rUsing forward selection (that is, select one variable, then select another) create a series of models up to complexity length 15. While you can code each of the 15 regressions separately, if you really want to be efficient, try to use a loop along with a character vector of your 15 variables to “step” through the 15 regressions. Use a list object to hold your results, and use lapply along with your RMSE function(s) to get a list of the RMSE’s, one for each model.\n\rMake a data.frame or tibble of the RMSE results and the model complexity (the function unlist is helpful when you have a list of identical types, as should be the case with your measures of model complexity and RMSE). Create a chart plotting the model complexity as the \\(x\\)-axis variable and RMSE as the \\(y\\)-axis variable. Describe any patterns you see. Do you think you should use the full-size model? Why or why not? What criterion are you using to make this statement?\n\r\r\r\rTest-Train Split (Lab 8)\rHere, we will use SalePrice as our target variable. You can re-use your code for cleaning from above (you included SalePrice there, right?), and if you want to choose different predictors, feel free to do so.\nThere is an issue with fitting a model to all available data then using RMSE to determine how well the model predicts: it is essentially cheating. As a linear model becomes more complex, the RSS, thus RMSE, can never go up. It will only go down—or, in very specific cases where a new predictor is completely uncorrelated with the target, stay the same. This might seem to suggest that in order to predict well, we should use the largest possible model. However, in reality we have fit to a specific dataset, but as soon as we see new data, a large model may (in fact) predict poorly. This is called overfitting.\nThe most common approach to overfitting is to take a dataset of interest and split it in two. One part of the datasets will be used to fit (train) a model, which we will call the training data. The remainder of the original data will be used to assess how well the model is predicting, which we will call the test data. Test data should never be used to train a model—its pupose is to evaluate the fitted model once you’ve settled on something.1\nHere we use the sample() function to obtain a random sample of the rows of the original data. We then use those row numbers (and remaining row numbers) to split the data accordingly. Notice we used the set.seed() function to allow use to reproduce the same random split each time we perform this analysis. Sometimes we don’t want to do this; if we want to run lots of independent splits, then we do not need to set the initial seed.\nset.seed(9)\rnum_obs = nrow(Ames)\rtrain_index = sample(num_obs, size = trunc(0.50 * num_obs))\rtrain_data = Ames[train_index, ]\rtest_data = Ames[-train_index, ]\rWe will look at two measures that assess how well a model is predicting: train RMSE and test RMSE.\n\\[\r\\text{RMSE}_\\text{Train} = \\text{RMSE}(\\hat{f}, \\text{Train Data}) = \\sqrt{\\frac{1}{n_{\\text{Tr}}}\\sum_{i \\in \\text{Train}}\\left(y_i - \\hat{f}(\\bf{x}_i)\\right)^2}\r\\]\nHere \\(n_{Tr}\\) is the number of observations in the train set. Train RMSE will still always go down (or stay the same) as the complexity of a linear model increases. That means train RMSE will not be useful for comparing models, but checking that it decreases is a useful sanity check.\n\\[\r\\text{RMSE}_{\\text{Test}} = \\text{RMSE}(\\hat{f}, \\text{Test Data}) = \\sqrt{\\frac{1}{n_{\\text{Te}}}\\sum_{i \\in \\text{Test}} \\left ( y_i - \\hat{f}(\\bf{x}_i) \\right ) ^2}\r\\]\nHere \\(n_{Te}\\) is the number of observations in the test set. Test RMSE uses the model fit to the training data, but evaluated on the unused test data. This is a measure of how well the fitted model will predict in general, not simply how well it fits data used to train the model, as is the case with train RMSE. What happens to test RMSE as the size of the model increases? That is what we will investigate.\nWe will start with the simplest possible linear model, that is, a model with no predictors.\nfit_0 = lm(SalePrice ~ 1, data = train_data)\rget_complexity(fit_0)\r## [1] 0\r# train RMSE\rsqrt(mean((train_data$SalePrice - predict(fit_0, train_data)) ^ 2))\r## [1] 80875.98\r# test RMSE\rsqrt(mean((test_data$SalePrice - predict(fit_0, test_data)) ^ 2))\r## [1] 77928.62\rThe previous two operations obtain the train and test RMSE. Since these are operations we are about to use repeatedly, we should use the function that we happen to have already written.\n# train RMSE\rrmse(actual = train_data$SalePrice, predicted = predict(fit_0, train_data))\r## [1] 80875.98\r# test RMSE\rrmse(actual = test_data$SalePrice, predicted = predict(fit_0, test_data))\r## [1] 77928.62\rThis function can actually be improved for the inputs that we are using. We would like to obtain train and test RMSE for a fitted model, given a train or test dataset, and the appropriate response variable.\nget_rmse = function(model, data, response) {\rrmse(actual = subset(data, select = response, drop = TRUE),\rpredicted = predict(model, data))\r}\rBy using this function, our code becomes easier to read, and it is more obvious what task we are accomplishing.\nget_rmse(model = fit_0, data = train_data, response = \u0026quot;SalePrice\u0026quot;) # train RMSE\r## [1] 80875.98\rget_rmse(model = fit_0, data = test_data, response = \u0026quot;SalePrice\u0026quot;) # test RMSE\r## [1] 77928.62\rTry it: Apply this basic function with different arguments. Do you understand how we’ve nested functions within functions?\nTry it: Define a total of five models with increasing complexity (see Exercises 2, Question 1)\n\rAdding Flexibility to Linear Models\rEach successive model we fit will be more and more flexible using both interactions and polynomial terms. We will see the training error decrease each time the model is made more flexible. We expect the test error to decrease a number of times, then eventually start going up, as a result of overfitting. To better understand the relationship between train RMSE, test RMSE, and model complexity, we’ll explore the results from Exercise 1.\nHopefully, you tried the in-line excercise above. If so, we can create a list of the models fit.\nmodel_list = list(fit_1, fit_2, fit_3, fit_4, fit_5)\rWe then obtain train RMSE, test RMSE, and model complexity for each. In doing so, we’ll introduce a handy function from R called sapply(). You can likely intuit what it does by looking at the code below.\ntrain_rmse = sapply(model_list, get_rmse, data = train_data, response = \u0026quot;SalePrice\u0026quot;)\rtest_rmse = sapply(model_list, get_rmse, data = test_data, response = \u0026quot;SalePrice\u0026quot;)\rmodel_complexity = sapply(model_list, get_complexity)\rTry it: Run ?sapply() to understand what are valid arguments to the function. It’s just like lapply, but instead of outputting a list, it outputs a vector of results.\nOnce you’ve done this, you’ll notice the following:\n# This is the same as the apply command above\rtest_rmse = c(get_rmse(fit_1, test_data, \u0026quot;SalePrice\u0026quot;),\rget_rmse(fit_2, test_data, \u0026quot;SalePrice\u0026quot;),\rget_rmse(fit_3, test_data, \u0026quot;SalePrice\u0026quot;),\rget_rmse(fit_4, test_data, \u0026quot;SalePrice\u0026quot;),\rget_rmse(fit_5, test_data, \u0026quot;SalePrice\u0026quot;))\rWe can plot the results. If you execute the code below, you’ll see the train RMSE in blue, while the test RMSE is given in orange.2\nplot(model_complexity, train_rmse, type = \u0026quot;b\u0026quot;,\rylim = c(min(c(train_rmse, test_rmse)) - 0.02,\rmax(c(train_rmse, test_rmse)) + 0.02),\rcol = \u0026quot;dodgerblue\u0026quot;,\rxlab = \u0026quot;Model Size\u0026quot;,\rylab = \u0026quot;RMSE\u0026quot;)\rlines(model_complexity, test_rmse, type = \u0026quot;b\u0026quot;, col = \u0026quot;darkorange\u0026quot;)\rWe could also summarize the results as a table. fit_1 is the least flexible, and fit_5 is the most flexible. If we were to do this (see the exercise below) we would see that Train RMSE decreases as flexibility increases forever. However, this may not be the case for the Test RMSE.\n\r\r\r\rModel\rTrain RMSE\rTest RMSE\rPredictors\r\r\r\rfit_1\rRMSE\\(_{\\text{train}}\\) for model 1\rRMSE\\(_{\\text{test}}\\) for model 1\rput predictors here\r\r…\r…\r….\r…\r\rfit_5\rRMSE\\(_{\\text{train}}\\) for model 5\rRMSE\\(_{\\text{train}}\\) for model 5\r\\(p\\) predictors\r\r\r\rTo summarize:\n\rUnderfitting models: In general High Train RMSE, High Test RMSE.\rOverfitting models: In general Low Train RMSE, High Test RMSE.\r\rSpecifically, we say that a model is overfitting if there exists a less complex model with lower Test RMSE.3 Then a model is underfitting if there exists a more complex model with lower Test RMSE.\nEXERCISE 2\n(AKA Lab 8)\nUsing any method you choose and any number of regressors, predict SalePrice with no fewer than five models of increasing complexity. Complexity can be increased by adding variables or by adding interactions of existing variables. Put the five models into a list.\n\rCalculate the Train and Test RMSE. Your goal is to have a lower Test RMSE than others in the class.\n\rMake a table exactly like the table above for the 5 models you just fit. The first column should have the name of the model (e.g. fit_1). Hint: you can get the names of the entries in a list using names(model_list) provided you named the list items when you added them.\n\rIn a short paragraph, describe the resulting model. Discuss how you arrived at this model, what interactions you’re using (if any) and how confident you are that your prediction will perform well, relative to other people in the class.\n\rDifficult; extra credit: Visualize your final model in a sensible way and provide a two-paragraph interpretation.\n\r\r\rA final note on the analysis performed here; we paid no attention whatsoever to the “assumptions” of a linear model. We only sought a model that predicted well, and paid no attention to a model for explaination. Hypothesis testing did not play a role in deciding the model, only prediction accuracy. Collinearity? We don’t care. Assumptions? Still don’t care. Diagnostics? Never heard of them. (These statements are a little over the top, and not completely true, but just to drive home the point that we only care about prediction. Often we latch onto methods that we have seen before, even when they are not needed.)\n\r\r\rNote that sometimes the terms evaluation set and test set are used interchangeably. We will give somewhat specific definitions to these later. For now we will simply use a single test set for a training set.↩︎\n\rThe train RMSE is guaranteed to follow this non-increasing pattern as long as no data is being dropped when new variables are added (see Data Cleaning above). The same is not true of test RMSE. We often see a nice U-shaped curve. There are theoretical reasons why we should expect this, but that is on average. Because of the randomness of one test-train split, we may not always see this result. Re-perform this analysis with a different seed value and the pattern may not hold. We will discuss why we expect this next chapter. We will discuss how we can help create this U-shape much later. Also, we might intuitively expect train RMSE to be lower than test RMSE. Again, due to the randomness of the split, you may get (un)lucky and this will not be true.↩︎\n\rThe labels of under and overfitting are relative to the best model we see. Any model more complex with higher Test RMSE is overfitting. Any model less complex with higher Test RMSE is underfitting.↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c735ab8791b2fcb0101a39bcb2292ce0","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/08-assignment/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/assignment/08-assignment/","section":"assignment","summary":"Backstory and Set Up\rData Cleaning\r\rMany models do not like NA values\r\rLinear Models\r\rAssesing Model Accuracy\rModel Complexity\rTest-Train Split (Lab 8)\rAdding Flexibility to Linear Models\r\r\r\rYou must turn in a PDF document of your R Markdown code. Submit this to D2L by 11:59 PM Eastern Time on Monday, October 31st\n\rBackstory and Set Up\rYou still work for Zillow as a junior analyst (sorry).","tags":null,"title":"Least Absolute Shrinkage and Selection Operator","type":"docs"},{"authors":null,"categories":null,"content":"\r\rAccessibility\rColors\rFonts\rGraphic assets\rImages\rVectors\rVectors, photos, videos, and other assets\r\r\r\rAccessibility\r\rVischeck: Simulate how your images look for people with different forms of colorblindness (web-based)\rColor Oracle: Simulate how your images look for people with different forms of colorblindness (desktop-based, more types of colorblindness)\r\r\rColors\r\rAdobe Color: Create, share, and explore rule-based and custom color palettes.\rColourLovers: Like Facebook for color palettes.\rviridis: Percetually uniform color scales.\rScientific Colour-Maps: Perceptually uniform color scales like viridis. Use them in R with scico.\rColorBrewer: Sequential, diverging, and qualitative color palettes that take accessibility into account.\rColorgorical: Create color palettes based on fancy mathematical rules for perceptual distance.\rColorpicker for data: More fancy mathematical rules for color palettes (explanation).\riWantHue: Yet another perceptual distance-based color palette builder.\rPhotochrome: Word-based color pallettes.\rPolicyViz Design Color Tools: Large collection of useful color resources\r\r\rFonts\r\rGoogle Fonts: Huge collection of free, well-made fonts.\rThe Ultimate Collection of Google Font Pairings: A list of great, well-designed font pairings from all those fonts hosted by Google (for when you’re looking for good contrasting or complementary fonts).\r\r\rGraphic assets\rImages\r\rUse the Creative Commons filters on Google Images or Flickr\rUnsplash\rPexels\rPixabay\rStockSnap.io\rBurst\rfreephotos.cc\r\r\rVectors\r\rNoun Project: Thousands of free simple vector images\raiconica: 1,000+ vector icons\rVecteezy: Thousands of free vector images\r\r\rVectors, photos, videos, and other assets\r\rStockio\r\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641494647,"objectID":"16fd04c4714e3d096bffcf19e6c524ca","permalink":"https://ssc442kirkpatrick.netlify.app/resource/design/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resource/design/","section":"resource","summary":"Accessibility\rColors\rFonts\rGraphic assets\rImages\rVectors\rVectors, photos, videos, and other assets\r\r\r\rAccessibility\r\rVischeck: Simulate how your images look for people with different forms of colorblindness (web-based)\rColor Oracle: Simulate how your images look for people with different forms of colorblindness (desktop-based, more types of colorblindness)\r\r\rColors\r\rAdobe Color: Create, share, and explore rule-based and custom color palettes.\rColourLovers: Like Facebook for color palettes.","tags":null,"title":"Design","type":"docs"},{"authors":null,"categories":null,"content":"\r\rBasic Markdown formatting\rMath\rTables\rFootnotes\rFront matter\rCitations\rOther references\r\r\rMarkdown is a special kind of markup language that lets you format text with simple syntax. You can then use a converter program like pandoc to convert Markdown into whatever format you want: HTML, PDF, Word, PowerPoint, etc. (see the full list of output types here)\nBasic Markdown formatting\r\r\r\r\rType…\r…or…\r…to get\r\r\r\rSome text in a paragraph.\rMore text in the next paragraph. Always\ruse empty lines between paragraphs.\r\rSome text in a paragraph.\nMore text in the next paragraph. Always\ruse empty lines between paragraphs.\n\r\r*Italic*\r_Italic_\rItalic\r\r**Bold**\r__Bold__\rBold\r\r# Heading 1\r\rHeading 1\r\r\r## Heading 2\r\rHeading 2\r\r\r### Heading 3\r\rHeading 3\r\r\r(Go up to heading level 6 with ######)\r\r\r\r[Link text](http://www.example.com)\r\rLink text\r\r![Image caption](/path/to/image.png)\r\r\r\r`Inline code` with backticks\r\rInline code with backticks\r\r\u0026gt; Blockquote\r\r\rBlockquote\n\r\r- Things in\r- an unordered\r- list\r* Things in\r* an unordered\r* list\r\rThings in\ran unordered\rlist\r\r\r1. Things in\r2. an ordered\r3. list\r1) Things in\r2) an ordered\r3) list\rThings in\ran ordered\rlist\r\r\rHorizontal line\r---\rHorizontal line\r***\rHorizontal line\n\r\r\r\r\rMath\rMarkdown uses LaTeX to create fancy mathematical equations. There are like a billion little options and features available for math equations—you can find helpful examples of the the most common basic commands here.\nYou can use math in two different ways: inline or in a display block. To use math inline, wrap it in single dollar signs, like $y = mx + b$:\n\r\r\r\rType…\r…to get\r\r\r\rBased on the DAG, the regression model for\restimating the effect of education on wages\ris $\\hat{y} = \\beta_0 + \\beta_1 x_1 + \\epsilon$, or\r$\\text{Wages} = \\beta_0 + \\beta_1 \\text{Education} + \\epsilon$.\rBased on the DAG, the regression model for\restimating the effect of education on wages\ris \\(\\hat{y} = \\beta_0 + \\beta_1 x_1 + \\epsilon\\), or\r\\(\\text{Wages} = \\beta_0 + \\beta_1 \\text{Education} + \\epsilon\\).\r\r\r\rTo put an equation on its own line in a display block, wrap it in double dollar signs, like this:\nType…\nThe quadratic equation was an important part of high school math:\r$$\rx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\r$$\rBut now we just use computers to solve for $x$.\r…to get…\n\rThe quadratic equation was an important part of high school math:\n\\[\rx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\r\\]\nBut now we just use computers to solve for \\(x\\).\n\rBecause dollar signs are used to indicate math equations, you can’t just use dollar signs like normal if you’re writing about actual dollars. For instance, if you write This book costs $5.75 and this other costs $40, Markdown will treat everything that comes between the dollar signs as math, like so: “This book costs $5.75 and this other costs $40”.\nTo get around that, put a backslash (\\) in front of the dollar signs, so that This book costs \\$5.75 and this other costs \\$40 becomes “This book costs $5.75 and this other costs $40”.\n\rTables\rThere are 4 different ways to hand-create tables in Markdown—I say “hand-create” because it’s normally way easier to use R to generate these things with packages like pander (use pandoc.table()) or knitr (use kable()). The two most common are simple tables and pipe tables. You should look at the full documentation here.\nFor simple tables, type…\n Right Left Center Default\r------- ------ ---------- -------\r12 12 12 12\r123 123 123 123\r1 1 1 1\rTable: Caption goes here\r…to get…\n\rCaption goes here\r\rRight\rLeft\rCenter\rDefault\r\r\r\r12\r12\r12\r12\r\r123\r123\r123\r123\r\r1\r1\r1\r1\r\r\r\rFor pipe tables, type…\n| Right | Left | Default | Center |\r|------:|:-----|---------|:------:|\r| 12 | 12 | 12 | 12 |\r| 123 | 123 | 123 | 123 |\r| 1 | 1 | 1 | 1 |\rTable: Caption goes here\r…to get…\n\rCaption goes here\r\rRight\rLeft\rDefault\rCenter\r\r\r\r12\r12\r12\r12\r\r123\r123\r123\r123\r\r1\r1\r1\r1\r\r\r\r\rFootnotes\rThere are two different ways to add footnotes (see here for complete documentation): regular and inline.\nRegular notes need (1) an identifier and (2) the actual note. The identifier can be whatever you want. Some people like to use numbers like [^1], but if you ever rearrange paragraphs or add notes before #1, the numbering will be wrong (in your Markdown file, not in the output; everything will be correct in the output). Because of that, I prefer to use some sort of text label:\nType…\nHere is a footnote reference[^1] and here is another [^note-on-dags].\r[^1]: This is a note.\r[^note-on-dags]: DAGs are neat.\rAnd here\u0026#39;s more of the document.\r…to get…\n\rHere is a footnote reference1 and here is another.2\nAnd here’s more of the document.\n\r\rThis is a note.↩︎\r\r\rDAGs are neat.↩︎\r\r\r\r\rYou can also use inline footnotes with ^[Text of the note goes here], which are often easier because you don’t need to worry about identifiers:\nType…\nCausal inference is neat.^[But it can be hard too!]\r…to get…\n\rCausal inference is neat.1\n\r\rBut it can be hard too!↩︎\r\r\r\r\r\rFront matter\rYou can include a special section at the top of a Markdown document that contains metadata (or data about your document) like the title, date, author, etc. This section uses a special simple syntax named YAML (or “YAML Ain’t Markup Language”) that follows this basic outline: setting: value for setting. Here’s an example YAML metadata section. Note that it must start and end with three dashes (---).\n---\rtitle: Title of your document\rdate: \u0026quot;January 13, 2020\u0026quot;\rauthor: \u0026quot;Your name\u0026quot;\r---\rYou can put the values inside quotes (like the date and name in the example above), or you can leave them outside of quotes (like the title in the example above). I typically use quotes just to be safe—if the value you’re using has a colon (:) in it, it’ll confuse Markdown since it’ll be something like title: My cool title: a subtitle, which has two colons. It’s better to do this:\n---\rtitle: \u0026quot;My cool title: a subtitle\u0026quot;\r---\rIf you want to use quotes inside one of the values (e.g. your document is An evaluation of \"scare quotes\"), you can use single quotes instead:\n---\rtitle: \u0026#39;An evaluation of \u0026quot;scare quotes\u0026quot;\u0026#39;\r---\r\rCitations\rOne of the most powerful features of Markdown + pandoc is the ability to automatically cite things and generate bibliographies. to use citations, you need to create a BibTeX file (ends in .bib) that contains a database of the things you want to cite. You can do this with bibliography managers designed to work with BibTeX directly (like BibDesk on macOS), or you can use Zotero (macOS and Windows) to export a .bib file. You can download an example .bib file of all the readings from this class here.\nComplete details for using citations can be found here. In brief, you need to do three things:\nAdd a bibliography: entry to the YAML metadata:\n---\rtitle: Title of your document\rdate: \u0026quot;January 13, 2020\u0026quot;\rauthor: \u0026quot;Your name\u0026quot;\rbibliography: name_of_file.bib\r---\rChoose a citation style based on a CSL file. The default is Chicago author-date, but you can choose from 2,000+ at this repository. Download the CSL file, put it in your project folder, and add an entry to the YAML metadata (or provide a URL to the online version):\n---\rtitle: Title of your document\rdate: \u0026quot;January 13, 2020\u0026quot;\rauthor: \u0026quot;Your name\u0026quot;\rbibliography: name_of_file.bib\rcsl: \u0026quot;https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\u0026quot;\r---\rSome of the most common CSLs are:\n\rChicago author-date\rChicago note-bibliography\rChicago full note-bibliography (no shortened notes or ibids)\rAPA 7th edition\rMLA 8th edition\r\rCite things in your document. Check the documentation for full details of how to do this. Essentially, you use @citationkey inside square brackets ([]):\n\r\r\r\rType…\r…to get…\r\r\r\rCausal inference is neat [@Rohrer:2018; @AngristPischke:2015].\rCausal inference is neat (Rohrer 2018; Angrist and Pischke 2015).\r\rCausal inference is neat [see @Rohrer:2018, p. 34; also @AngristPischke:2015, chapter 1].\rCausal inference is neat (see Rohrer 2018, 34; also Angrist and Pischke 2015, chap. 1).\r\rAngrist and Pischke say causal inference is neat [-@AngristPischke:2015; see also @Rohrer:2018].\rAngrist and Pischke say causal inference is neat (2015; see also Rohrer 2018).\r\r@AngristPischke:2015 [chapter 1] say causal inference is neat, and @Rohrer:2018 agrees.\rAngrist and Pischke (2015, chap. 1) say causal inference is neat, and Rohrer (2018) agrees.\r\r\r\rAfter compiling, you should have a perfectly formatted bibliography added to the end of your document too:\n\rAngrist, Joshua D., and Jörn-Steffen Pischke. 2015. Mastering ’Metrics: The Path from Cause to Effect. Princeton, NJ: Princeton University Press.\nRohrer, Julia M. 2018. “Thinking Clearly About Correlations and Causation: Graphical Causal Models for Observational Data.” Advances in Methods and Practices in Psychological Science 1 (1): 27–42. https://doi.org/10.1177/2515245917745629.\n\r\r\rOther references\rThese websites have additional details and examples and practice tools:\n\rCommonMark’s Markdown tutorial: A quick interactive Markdown tutorial.\rMarkdown tutorial: Another interactive tutorial to practice using Markdown.\rMarkdown cheatsheet: Useful one-page reminder of Markdown syntax.\rThe Plain Person’s Guide to Plain Text Social Science: A comprehensive explanation and tutorial about why you should write data-based reports in Markdown.\r\r\r","date":1578873600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641494647,"objectID":"dcf6a5ae191a1cca4f4c8ff8ac114538","permalink":"https://ssc442kirkpatrick.netlify.app/resource/markdown/","publishdate":"2020-01-13T00:00:00Z","relpermalink":"/resource/markdown/","section":"resource","summary":"Basic Markdown formatting\rMath\rTables\rFootnotes\rFront matter\rCitations\rOther references\r\r\rMarkdown is a special kind of markup language that lets you format text with simple syntax. You can then use a converter program like pandoc to convert Markdown into whatever format you want: HTML, PDF, Word, PowerPoint, etc. (see the full list of output types here)\nBasic Markdown formatting\r\r\r\r\rType…\r…or…\r…to get\r\r\r\rSome text in a paragraph.","tags":null,"title":"Using Markdown","type":"docs"},{"authors":null,"categories":null,"content":"\r\rInteresting and excellent real world examples\rHow to select the appropriate chart type\rGeneral resources\rVisualization in Excel\rVisualization in Tableau\r\r\rInteresting and excellent real world examples\r\rThe Stories Behind a Line\rAustralia as 100 people: You can make something like this with d3 and the potato project.\rMarrying Later, Staying Single Longer\r\r\rHow to select the appropriate chart type\rMany people have created many useful tools for selecting the correct chart type for a given dataset or question. Here are some of the best:\n\rThe Data Visualisation Catalogue: Descriptions, explanations, examples, and tools for creating 60 different types of visualizations.\rThe Data Viz Project: Descriptions and examples for 150 different types of visualizations. Also allows you to search by data shape and chart function (comparison, correlation, distribution, geographical, part to whole, trend over time, etc.).\rFrom Data to Viz: A decision tree for dozens of chart types with links to R and Python code.\rThe Chartmaker Directory: Examples of how to create 51 different types of visualizations in 31 different software packages, including Excel, Tableau, and R.\rR Graph Catalog: R code for 124 ggplot graphs.\rEmery’s Essentials: Descriptions and examples of 26 different chart types.\r\r\rGeneral resources\r\rStorytelling with Data: Blog and site full of resources by Cole Nussbaumer Knaflic.\rAnn K. Emery’s blog: Blog and tutorials by Ann Emery.\rEvergreen Data: Helful resources by Stephanie Evergreen.\rPolicyViz: Regular podcast and site full of helpful resources by Jon Schwabisch.\rVisualising Data: Fantastic collection of visualization resources, articles, and tutorials by Andy Kirk.\rInfo We Trust: Detailed explorations of visualizations by RJ Andrews, including a beautiful visual history of the field.\rFlowingData: Blog by Nathan Yau.\rInformation is Beautiful: Blog by David McCandless.\rJunk Charts: Blog by Kaiser Fung.\rWTF Visualizations: Visualizations that make you ask “wtf?”\rThe Data Visualization Checklist: A helpful set of criteria for grading the effectiveness of a graphic.\rData Literacy Starter Kit: Compilation of resources to become data literate by Laura Calloway.\rSeeing Data: A series of research projects about perceptions and visualizations.\r\r\rVisualization in Excel\r\rHow to Build Data Visualizations in Excel: Detailed tutorials for creating 14 different visualizations in Excel.\rAnn Emery’s tutorials: Fantastic series of tutorials for creating charts in Excel.\r\r\rVisualization in Tableau\rBecause it is focused entirely on visualization (and because it’s a well-supported commercial product), Tableau has a phenomenal library of tutorials and training videos. There’s a helpful collections of videos here, as well.\n\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641494647,"objectID":"ca403ba352e0871f06b445d2470037b3","permalink":"https://ssc442kirkpatrick.netlify.app/resource/visualization/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resource/visualization/","section":"resource","summary":"Interesting and excellent real world examples\rHow to select the appropriate chart type\rGeneral resources\rVisualization in Excel\rVisualization in Tableau\r\r\rInteresting and excellent real world examples\r\rThe Stories Behind a Line\rAustralia as 100 people: You can make something like this with d3 and the potato project.\rMarrying Later, Staying Single Longer\r\r\rHow to select the appropriate chart type\rMany people have created many useful tools for selecting the correct chart type for a given dataset or question.","tags":null,"title":"Visualization","type":"docs"},{"authors":null,"categories":null,"content":"\r\rKey terms\rAdd chunks\rChunk names\rChunk options\rInline chunks\rOutput formats\r\r\rR Markdown is regular Markdown with R code and output sprinkled in. You can do everything you can with regular Markdown, but you can incorporate graphs, tables, and other R output directly in your document. You can create HTML, PDF, and Word documents, PowerPoint and HTML presentations, websites, books, and even interactive dashboards with R Markdown. This whole course website is created with R Markdown (and a package named blogdown).\nThe documentation for R Markdown is extremely comprehensive, and their tutorials and cheatsheets are excellent—rely on those.\nI have created a video walkthrough for using R Markdown for another course, but it is useful here. You can see it here ]\nHere are the most important things you’ll need to know about R Markdown in this class:\nKey terms\r\rDocument: A Markdown file where you type stuff\n\rChunk: A piece of R code that is included in your document. It looks like this:\n```{r}\r# Code goes here\r```\rThere must be an empty line before and after the chunk. The final three backticks must be the only thing on the line—if you add more text, or if you forget to add the backticks, or accidentally delete the backticks, your document will not knit correctly.\n\rKnit: When you “knit” a document, R runs each of the chunks sequentially and converts the output of each chunk into Markdown. R then runs the knitted document through pandoc to convert it to HTML or PDF or Word (or whatever output you’ve selected). We will always use PDF for this course.\nYou can knit by clicking on the “Knit” button at the top of the editor window, or by pressing ⌘⇧K on macOS or control + shift + K on Windows.\n\r\r\rAdd chunks\rThere are three ways to insert chunks:\n\rPress ⌘⌥I on macOS or control + alt + I on Windows\n\rClick on the “Insert” button at the top of the editor window\n\rManually type all the backticks and curly braces (don’t do this)\n\r\r\rChunk names\rYou can add names to chunks to make it easier to navigate your document. If you click on the little dropdown menu at the bottom of your editor in RStudio, you can see a table of contents that shows all the headings and chunks. If you name chunks, they’ll appear in the list. If you don’t include a name, the chunk will still show up, but you won’t know what it does.\nTo add a name, include it immediately after the {r in the first line of the chunk. Names cannot contain spaces, but they can contain underscores and dashes. All chunk names in your document must be unique.\n```{r name-of-this-chunk}\r# Code goes here\r```\r\rChunk options\rThere are a bunch of different options you can set for each chunk. You can see a complete list in the RMarkdown Reference Guide or at knitr’s website.\nOptions go inside the {r} section of the chunk:\n```{r name-of-this-chunk, warning=FALSE, message=FALSE}\r# Code goes here\r```\rThe most common chunk options are these:\n\rfig.width=5 and fig.height=3 (or whatever number you want): Set the dimensions for figures\recho=FALSE: The code is not shown in the final document, but the results are\rmessage=FALSE: Any messages that R generates (like all the notes that appear after you load a package) are omitted\rwarning=FALSE: Any warnings that R generates are omitted\rinclude=FALSE: The chunk still runs, but the code and results are not included in the final document\r\rYou can also set chunk options by clicking on the little gear icon in the top right corner of any chunk:\n\rInline chunks\rYou can also include R output directly in your text, which is really helpful if you want to report numbers from your analysis. To do this, use `r r_code_here`.\nIt’s generally easiest to calculate numbers in a regular chunk beforehand and then use an inline chunk to display the value in your text. For instance, this document…\n```{r find-avg-mpg, echo=FALSE}\ravg_mpg \u0026lt;- mean(mtcars$mpg)\r```\rThe average fuel efficiency for cars from 1974 was `r round(avg_mpg, 1)` miles per gallon.\r… would knit into this:\n\rThe average fuel efficiency for cars from 1974 was 20.1 miles per gallon.\n\r\rOutput formats\rYou can specify what kind of document you create when you knit in the YAML front matter.\ntitle: \u0026quot;My document\u0026quot;\routput:\rhtml_document: default\rpdf_document: default\rword_document: default\rYou can also click on the down arrow on the “Knit” button to choose the output and generate the appropriate YAML. If you click on the gear icon next to the “Knit” button and choose “Output options”, you change settings for each specific output type, like default figure dimensions or whether or not a table of contents is included.\nThe first output type listed under output: will be what is generated when you click on the “Knit” button or press the keyboard shortcut (⌘⇧K on macOS; control + shift + K on Windows). If you choose a different output with the “Knit” button menu, that output will be moved to the top of the output section.\nThe indentation of the YAML section matters, especially when you have settings nested under each output type. Here’s what a typical output section might look like:\n---\rtitle: \u0026quot;My document\u0026quot;\rauthor: \u0026quot;My name\u0026quot;\rdate: \u0026quot;January 13, 2020\u0026quot;\routput: html_document: toc: yes\rfig_caption: yes\rfig_height: 8\rfig_width: 10\rpdf_document: latex_engine: xelatex # More modern PDF typesetting engine\rtoc: yes\rword_document: toc: yes\rfig_caption: yes\rfig_height: 4\rfig_width: 5\r---\r\r","date":1578873600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661857285,"objectID":"00c0b36df90b91640842af65d1311657","permalink":"https://ssc442kirkpatrick.netlify.app/resource/rmarkdown/","publishdate":"2020-01-13T00:00:00Z","relpermalink":"/resource/rmarkdown/","section":"resource","summary":"Key terms\rAdd chunks\rChunk names\rChunk options\rInline chunks\rOutput formats\r\r\rR Markdown is regular Markdown with R code and output sprinkled in. You can do everything you can with regular Markdown, but you can incorporate graphs, tables, and other R output directly in your document. You can create HTML, PDF, and Word documents, PowerPoint and HTML presentations, websites, books, and even interactive dashboards with R Markdown.","tags":null,"title":"Using R Markdown","type":"docs"},{"authors":null,"categories":null,"content":"\r\rR style conventions\rMain style things to pay attention to for this class\rSpacing\rLong lines\rPipes (%\u0026gt;%) and ggplot layers (+)\rComments\r\r\r\rR style conventions\rR is fairly forgiving about how you type code (unlike other languages like Python, where miscounting spaces can ruin your code!). All of these things will do exactly the same thing:\nmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty\u0026gt;10, class==\u0026quot;compact\u0026quot;)\rfilter(mpg,cty\u0026gt;10,class==\u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rfilter ( mpg,cty\u0026gt;10, class==\u0026quot;compact\u0026quot; )\rBut you’ll notice that only a few of those iterations (the first three) are easily readable.\nTo help improve readability and make it easier to share code with others, there’s an unofficial style guide for writing R code. It’s fairly short and just has lots of examples of good and bad ways of writing code (naming variables, dealing with long lines, using proper indentation levels, etc.)—you should glance through it some time.\nRStudio has a built-in way of cleaning up your code. Select some code, press ctrl + i (on Windows) or ⌘ + i (on macOS), and R will reformat the code for you. It’s not always perfect, but it’s really helpful for getting indentation right without having to manually hit space a billion times.\n\rMain style things to pay attention to for this class\r\rImportant note: I won’t ever grade you on any of this! If you submit something like filter(mpg,cty\u0026gt;10,class==\"compact\"), I might recommend adding spaces, but it won’t affect your grade or points or anything.\n\rSpacing\r\rSee the “Spacing” section in the tidyverse style guide.\n\rPut spaces after commas (like in regular English):\n# Good\rfilter(mpg, cty \u0026gt; 10)\r# Bad\rfilter(mpg , cty \u0026gt; 10)\rfilter(mpg ,cty \u0026gt; 10)\rfilter(mpg,cty \u0026gt; 10)\rPut spaces around operators like +, -, \u0026gt;, =, etc.:\n# Good\rfilter(mpg, cty \u0026gt; 10)\r# Bad\rfilter(mpg, cty\u0026gt;10)\rfilter(mpg, cty\u0026gt; 10)\rfilter(mpg, cty \u0026gt;10)\rDon’t put spaces around parentheses that are parts of functions:\n# Good\rfilter(mpg, cty \u0026gt; 10)\r# Bad\rfilter (mpg, cty \u0026gt; 10)\rfilter ( mpg, cty \u0026gt; 10)\rfilter( mpg, cty \u0026gt; 10 )\r\rLong lines\r\rSee the “Long lines” section in the tidyverse style guide.\n\rIt’s generally good practice to not have really long lines of code. A good suggestion is to keep lines at a maximum of 80 characters. Instead of counting characters by hand (ew), in RStudio go to “Tools” \u0026gt; “Global Options” \u0026gt; “Code” \u0026gt; “Display” and check the box for “Show margin”. You should now see a really thin line indicating 80 characters. Again, you can go beyond this—that’s fine. It’s just good practice to avoid going too far past it.\nYou can add line breaks inside longer lines of code. Line breaks should come after commas, and things like function arguments should align within the function:\n# Good\rfilter(mpg, cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\r# Good\rfilter(mpg, cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\r# Good\rfilter(mpg,\rcty \u0026gt; 10,\rclass == \u0026quot;compact\u0026quot;)\r# Bad\rfilter(mpg, cty \u0026gt; 10, class %in% c(\u0026quot;compact\u0026quot;, \u0026quot;pickup\u0026quot;, \u0026quot;midsize\u0026quot;, \u0026quot;subcompact\u0026quot;, \u0026quot;suv\u0026quot;, \u0026quot;2seater\u0026quot;, \u0026quot;minivan\u0026quot;))\r# Good\rfilter(mpg, cty \u0026gt; 10, class %in% c(\u0026quot;compact\u0026quot;, \u0026quot;pickup\u0026quot;, \u0026quot;midsize\u0026quot;, \u0026quot;subcompact\u0026quot;, \u0026quot;suv\u0026quot;, \u0026quot;2seater\u0026quot;, \u0026quot;minivan\u0026quot;))\r\rPipes (%\u0026gt;%) and ggplot layers (+)\rPut each layer of a ggplot plot on separate lines, with the + at the end of the line, indented with two spaces:\n# Good\rggplot(mpg, aes(x = cty, y = hwy, color = class)) +\rgeom_point() +\rgeom_smooth() +\rtheme_bw()\r# Bad\rggplot(mpg, aes(x = cty, y = hwy, color = class)) +\rgeom_point() + geom_smooth() +\rtheme_bw()\r# Super bad\rggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\r# Super bad and won\u0026#39;t even work\rggplot(mpg, aes(x = cty, y = hwy, color = class))\r+ geom_point()\r+ geom_smooth() + theme_bw()\rPut each step in a dplyr pipeline on separate lines, with the %\u0026gt;% at the end of the line, indented with two spaces:\n# Good\rmpg %\u0026gt;% filter(cty \u0026gt; 10) %\u0026gt;% group_by(class) %\u0026gt;% summarize(avg_hwy = mean(hwy))\r# Bad\rmpg %\u0026gt;% filter(cty \u0026gt; 10) %\u0026gt;% group_by(class) %\u0026gt;% summarize(avg_hwy = mean(hwy))\r# Super bad\rmpg %\u0026gt;% filter(cty \u0026gt; 10) %\u0026gt;% group_by(class) %\u0026gt;% summarize(avg_hwy = mean(hwy))\r# Super bad and won\u0026#39;t even work\rmpg %\u0026gt;% filter(cty \u0026gt; 10)\r%\u0026gt;% group_by(class)\r%\u0026gt;% summarize(avg_hwy = mean(hwy))\r\rComments\r\rSee the “Comments” section in the tidyverse style guide.\n\rComments should start with a comment symbol and a single space: #\n# Good\r#Bad\r#Bad\rIf the comment is really short (and won’t cause you to go over 80 characters in the line), you can include it in the same line as the code, separated by at least two spaces (it works with one space, but using a couple can enhance readability):\nmpg %\u0026gt;% filter(cty \u0026gt; 10) %\u0026gt;% # Only rows where cty is 10 +\rgroup_by(class) %\u0026gt;% # Divide into class groups\rsummarize(avg_hwy = mean(hwy)) # Find the average hwy in each group\rYou can add extra spaces to get inline comments to align, if you want:\nmpg %\u0026gt;% filter(cty \u0026gt; 10) %\u0026gt;% # Only rows where cty is 10 +\rgroup_by(class) %\u0026gt;% # Divide into class groups\rsummarize(avg_hwy = mean(hwy)) # Find the average hwy in each group\rIf the comment is really long, you can break it into multiple lines. RStudio can do this for you if you go to “Code” \u0026gt; “Reflow comment”\n# Good\r# Happy families are all alike; every unhappy family is unhappy in its own way.\r# Everything was in confusion in the Oblonskys’ house. The wife had discovered\r# that the husband was carrying on an intrigue with a French girl, who had been\r# a governess in their family, and she had announced to her husband that she\r# could not go on living in the same house with him. This position of affairs\r# had now lasted three days, and not only the husband and wife themselves, but\r# all the members of their family and household, were painfully conscious of it.\r# Bad\r# Happy families are all alike; every unhappy family is unhappy in its own way. Everything was in confusion in the Oblonskys’ house. The wife had discovered that the husband was carrying on an intrigue with a French girl, who had been a governess in their family, and she had announced to her husband that she could not go on living in the same house with him. This position of affairs had now lasted three days, and not only the husband and wife themselves, but all the members of their family and household, were painfully conscious of it.\rThough, if you’re dealing with comments that are that long, consider putting the text in R Markdown instead and having it be actual prose.\n\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641494647,"objectID":"f4734e734c67442efdc8d228e91ad766","permalink":"https://ssc442kirkpatrick.netlify.app/resource/style/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resource/style/","section":"resource","summary":"R style conventions\rMain style things to pay attention to for this class\rSpacing\rLong lines\rPipes (%\u0026gt;%) and ggplot layers (+)\rComments\r\r\r\rR style conventions\rR is fairly forgiving about how you type code (unlike other languages like Python, where miscounting spaces can ruin your code!). All of these things will do exactly the same thing:\nmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty\u0026gt;10, class==\u0026quot;compact\u0026quot;)\rfilter(mpg,cty\u0026gt;10,class==\u0026quot;compact\u0026quot;)\rmpg %\u0026gt;% filter(cty \u0026gt; 10, class == \u0026quot;compact\u0026quot;)\rfilter ( mpg,cty\u0026gt;10, class==\u0026quot;compact\u0026quot; )\rBut you’ll notice that only a few of those iterations (the first three) are easily readable.","tags":null,"title":"R style suggestions","type":"docs"},{"authors":null,"categories":null,"content":"\rBecause RStudio projects typically consist of multiple files (R scripts, datasets, graphical output, etc.) the easiest way to distribute them to you for examples, assignments, and projects is to combine all the different files in to a single compressed collection called a zip file. When you unzip a zipped file, your operating system extracts all the files that are contained inside into a new folder on your computer.\nUnzipping files on macOS is trivial, but unzipping files on Windows can mess you up if you don’t pay careful attention. Here’s a helpful guide to unzipping files on both macOS and Windows.\nUnzipping files on macOS\rDouble click on the downloaded .zip file. macOS will automatically create a new folder with the same name as the .zip file, and all the file’s contents will be inside. Double click on the RStudio Project file (.Rproj) to get started.\n\rUnzipping files on Windows\rtl;dr: Right click on the .zip file, select “Extract All…”, and work with the resulting unzipped folder.\nUnlike macOS, Windows does not automatically unzip things for you. If you double click on the .zip file, Windows will show you what’s inside, but it will do so without actually extracting anything. This can be is incredibly confusing! Here’s what it looks like—the only clues that this folder is really a .zip file are that there’s a “Compressed Folder Tools” tab at the top, and there’s a “Ratio” column that shows how much each file is compressed.\nIt is very tempting to try to open files from this view. However, if you do, things will break and you won’t be able to correctly work with any of the files in the zipped folder. If you open the R Project file, for instance, RStudio will point to a bizarre working directory buried deep in some temporary folder:\nYou most likely won’t be able to open any data files or save anything, which will be frustrating.\nInstead, you need to right click on the .zip file and select “Extract All…”:\nThen choose where you want to unzip all the files and click on “Extract”\nYou should then finally have a real folder with all the contents of the zipped file. Open the R Project file and RStudio will point to the correct working directory and everything will work.\n\r","date":1588723200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641494647,"objectID":"c14c352fd4c4ab8c12a3cd60b30b9d8c","permalink":"https://ssc442kirkpatrick.netlify.app/resource/unzipping/","publishdate":"2020-05-06T00:00:00Z","relpermalink":"/resource/unzipping/","section":"resource","summary":"Because RStudio projects typically consist of multiple files (R scripts, datasets, graphical output, etc.) the easiest way to distribute them to you for examples, assignments, and projects is to combine all the different files in to a single compressed collection called a zip file. When you unzip a zipped file, your operating system extracts all the files that are contained inside into a new folder on your computer.\nUnzipping files on macOS is trivial, but unzipping files on Windows can mess you up if you don’t pay careful attention.","tags":null,"title":"Unzipping files","type":"docs"},{"authors":null,"categories":null,"content":"\rThere are a ton of places to find data related to public policy and administration (as well as data on pretty much any topic you want) online:\n\rData is Plural newsletter: Jeremy Singer-Vine sends a weekly newsletter of the most interesting public datasets he’s found. You should subscribe to it. He also has an archive of all the datasets he’s highlighted.\n\rGoogle Dataset Search: Google indexes thousands of public datasets; search for them here.\n\rKaggle: Kaggle hosts machine learning competitions where people compete to create the fastest, most efficient, most predictive algorithms. A byproduct of these competitions is a host of fascinating datasets that are generally free and open to the public. See, for example, the European Soccer Database, the Salem Witchcraft Dataset or results from an Oreo flavors taste test. Note: when you are asked in an assignment or project to find data, Kaggle is not a valid source. You learn nothing about farming by getting fruit from the market. Similarly, you learn nothing about data analysis by getting pre-packaged data from Kaggle.\n\r360Giving: Dozens of British foundations follow a standard file format for sharing grant data and have made that data available online.\n\rUS City Open Data Census: More than 100 US cities have committed to sharing dozens of types of data, including data about crime, budgets, campaign finance, lobbying, transit, and zoning. This site from the Sunlight Foundation and Code for America collects this data and rates cities by how well they’re doing.\n\rPolitical science and economics datasets: There’s a wealth of data available for political science- and economics-related topics:\n\rFrançois Briatte’s extensive curated lists: Includes data from/about intergovernmental organizations (IGOs), nongovernmental organizations (NGOs), public opinion surveys, parliaments and legislatures, wars, human rights, elections, and municipalities.\rThomas Leeper’s list of political science datasets: Good short list of useful datasets, divided by type of data (country-level data, survey data, social media data, event data, text data, etc.).\rErik Gahner’s list of political science datasets: Huge list of useful datasets, divided by topic (governance, elections, policy, political elites, etc.)\r\rGeospatial datasets: For our geospatial unit, many entities (government agencies, etc.) post repositories of spatial data via arcgis.com, which is owned by ESRI, the company that makes the predominant commercial GIS software. The data owner decides what data to post and how to present it, but arcgis.com provides the hosting. R has excellent geospatial functionalities, so we cover (when time permits) geospatial data. It is easy to find geospatial data to import into R. Here are a few:\n\rState of Michigan Open Data Portal\rHomeland Infrastructure Foundation-Level Data (HIFLD)\rCity of East Lansing Data Viewer\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661857285,"objectID":"2210aa8aeb5724b04bdf63d813d61030","permalink":"https://ssc442kirkpatrick.netlify.app/resource/data/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resource/data/","section":"resource","summary":"There are a ton of places to find data related to public policy and administration (as well as data on pretty much any topic you want) online:\n\rData is Plural newsletter: Jeremy Singer-Vine sends a weekly newsletter of the most interesting public datasets he’s found. You should subscribe to it. He also has an archive of all the datasets he’s highlighted.\n\rGoogle Dataset Search: Google indexes thousands of public datasets; search for them here.","tags":null,"title":"Data","type":"docs"},{"authors":null,"categories":null,"content":"\r\r\rReadings\r\rGuiding Question\r\rA Brief Introduction to SSC442\r\rAbout Me\rAbout You\rThis Course\rMore About This Course\rAnd finally…\r\rWhat is “Data Analytics”?\r\rStarting point for this course\r\rOutline of the Course\r\rNon-Social Science Approaches to Statistical Learning\rThe Pros and Cons of Correlation\rA Case Study in Prediction\rMore Recent Examples of Prediction\rAn Aside: Nomenclature\rLearning from Data\rCase study: US homicides by firearm\r\rR basics\r\rInstalling R and R Studio and Review Resources\rThe (very) basics of R\r\rObjects\rThe workspace\rFunctions\rOther prebuilt objects\rVariable names\rSaving your workspace\rMotivating scripts\rCommenting your code\r\rData types\r\rData frames\rExamining an object\rThe accessor: $\rVectors: numerics, characters, and logical\rFactors\rLists\rMatrices\r\rVectors\r\rCreating vectors\rNames\rSequences\rSubsetting\r\rCoercion\r\rNot availables (NA)\r\rSorting\r\rsort\rorder\rmax and which.max\rrank\rBeware of recycling\r\rVector arithmetics\r\rRescaling a vector\rTwo vectors\r\rIndexing\r\rSubsetting with logicals\rLogical operators\rwhich\r%in%\r\r\r\r\rReadings\rAs noted in the syllabus, your readings will be assigned each week in this area. For this initial week, please read the course content. Read closely the following:\n\rThe syllabus, content, examples, and labs pages for this class.\rThis page. Yes, the whole thing.\r\rGuiding Question\rFor future lectures, the guiding questions will be more pointed and at a higher level to help steer your thinking. Here, we want to ensure you remember some basics and accordingly the questions are straightforward.\n\rDo you remember anything about R?\rWhat are the different data types in R?\rHow do you index specific elements of a vector? Why might you want to do that?\r\r\r\rA Brief Introduction to SSC442\r\rI keep saying that the sexy job in the next 10 years will be statisticians. And I’m not kidding.\n\rHal Varian, Chief Economist, Google\r\rAbout Me\rMe: My primary area of expertise is environmental and energy (applied) economics.\nThis class is totally, unapologetically a work in progress. It was developed mainly by Prof. Bushong with refinements by myself.\nMaterial is a mish-mash of stuff from courses offered at Caltech, Stanford, Harvard, and Duke…so, yeah, it will be challenging. Hopefully, you’ll find it fun!\nMy research: occasionally touches the topics in the course, but mostly utilizes things in the course as tools.\n\rAbout You\rNew phone who dis? Please email me jkirk@msu.edu your\n\rname (with pronunciation guide)\n\rmajor\n\rdesired graduation year and semester\n\rinterest in this course on a 10-point scale (1: not at all interested; 10: helllllll yeah)\n\r\r\rYou must spend 5 minutes emailing me a little bit about your interests before the next class.\n\rThis Course\rThe syllabus is posted on the course website. I’ll walk through highlights now, but read it later – it’s long.\r- But eventually, please read it. It is “required.”\nSyllabus highlights:\n\rGrade is composed of weekly writings, labs, and projects (see syllabus page for exact points)\r\rWeekly writings: 19%\rParticipation: 4%\rLabs: 32%\rProjects: 45%\r\rThis structure is designed to give ~55% “for free”. Success on the projects will require real work.\rLabs consist of a practical implementation of something we’ve covered in the course (e.g., code your own Recommender System).\r\rGrading\rGrading: come to class.\nIf you complete all assignments and attend all class dates, I suspect you will do very well. Given the way the syllabus is structured, I conjecture that the following is a loose guide to grades:\n4.0 Turned in all assignments with good effort, worked hard on the projects and was proud of final product.\n3.5 Turned in all assignments with good effort, worked a bit on the projects and was indifferent to final product.\n3.0 Turned in all assignments with some effort, worked a bit on the projects and was shy about final product.\n\u0026lt; 3.0 Very little effort, or did not turn in all assignments, worked very little on the projects and was embarassed by final product.\n…of course, failing to turn in assignments can lead to a grade dramatically lower than just a 3.0.\n\r\rMore About This Course\rThere are sort of three texts for this course and sort of zero.\nThe “main text” is free and available online. The secondary text is substantially more difficult, but also free online. The third text costs about $25. Assigned readings can be found on the course website under “Content”.\nPlease please please please please: ask questions during class.\n\rMost ideas will be new.\n\rSometimes (often?) the material itself will be confusing or interesting—or both!\n\rTeaching online is incredibly challenging (no feedback) and chat is vital to success. We’re back in person!\n\rNote: If I find that attendance is terrible, I may have to start incorporating attendance into participation.\n\r\rReturn of the Please: If there is some topic that you really want to learn about, ask. If you are uncomfortable asking in front of the whole group, please see me during office hours.\nBecause this is a new-ish course:\n\rSome of the lectures will be way too long or too short.\n\rSome of the lectures won’t make sense at first\n\rSome of the time I’ll forget what I intended to say and awkwardly stare at you for a few moments (sorry).\n\r\rComment throughout the course, not just at the end.\nThe material will improve with time and feedback.\nI encourage measured feedback and thoughtful responses to questions. If I call on you and you don’t know immediately, don’t freak out. If you don’t know, it’s totally okay to say you don’t know.\nSUPER BIG IMPORTANT EXPLANATION OF THE COURSE\rI teach using “math”.\n…Don’t be afraid. The math won’t hurt you.\nI fundamentally believe that true knowledge of how we learn from data depends on a basic understanding of the underlying mathematics.\n-Good news: no black boxes.\n\rYou’ll actually learn stuff. (Probably. Hopefully?)\n\rAlso good news: level of required math is reasonably low. High-school algebra or equivalent should be fine.\n\r\r-Bad news: notation-heavy slides and reading.\n\r\rAnd finally…\rFinally: I cannot address field-specific questions in areas outside economics to any satisfying degree.\n\rGood news: I’m good at knowing what I don’t know and have a very small ego, which means that I’m much less likely to blow smoke up your ass than other professors.\n\rBad news: I can’t help with certain types of questions.\n\r\rThis course should be applicable broadly, but many of the examples will lean on my personal expertise (sorry).\nYour assignment: read syllabus, the content from Week 0, and the Example from Week 0 (we start on a Thursday so we have to get thru both in one day). Begin working on Lab 0 as it is due Monday.\nThings to stress from syllabus:\n\rE-mail isn’t the ideal solution for technical problems\rNo appointments necessary for regularly scheduled office hours; or by appointment.\rTA office hours are great as well. Our TA has experience in this course.\rNotify me immediately if you need accommodations because of RCPD or religious convictions; If you approach me at the last minute, I may not be able to help.\r\rDespite my hard-assness in these intro slides: I’m here to help and I am not in the business of giving bad grades for no reason.\n\r\rWhat is “Data Analytics”?\rHow do you define “data analytics”? (Not a rhetorical question!)\n\rThis course will avoid this nomenclature. It is confusing and imprecise. But you signed up (suckers) and I owe an explanation of what this course will cover.\r\rSome “data analytics” topics we will cover:\n\rLinear regression: il classico.\rModels of classification or discrete choice.\rAnalysis of ``wide’’ data.\rDecision trees and other non-linear models.\r\rStarting point for this course\rBetter utilizing existing data can improve our predictive power whilst providing interpretable outputs for considering new policies.\nWARNING: Causation is tough and we will spend the entire course warning you to avoid making causal claims!\n\r\rOutline of the Course\rNon-Social Science Approaches to Statistical Learning\rA Brief History\nSuppose you are a researcher and you want to teach a computer to recognize images of a tree.\nNote: this is an ``easy” problem. If you show pictures to a 3-year-old, that child will probably be able to tell you if there is a tree in the picture.\nComputer scientists spent about 20 years on this problem because they thought about the problem like nerds and tried to write down a series of rules.\nRules are difficult to form, and simply writing rules misses the key insight: the data can tell you something.\nSocial Science Approaches to Statistical Learning\rA Brief History\nSuppose you are a researcher and you want to know whether prisons reduce crime.\nfrom “A Call for a Moratorium on Prison Building” (1976)\n\rBetween 1955 and 1975, fifteen states increased the collective capacity of their adult prison systems by 56% (from, on average, 63,100 to 98,649).\rFifteen other states increased capacity by less than 4% (from 49,575 to 51,440).\rIn “heavy-construction” states the crime rate increased by 167%; in “low-construction” states the crime rate increased by 145%.\r\r\r\r\rPrison Capacity\rCrime Rate\r\r\r\rHigh construction\r\\(\\uparrow\\)~56%\r\\(\\uparrow\\)~167%\r\rLow construction\r\\(\\uparrow\\)~4%\r\\(\\uparrow\\)~145%\r\r\r\r\r\rThe Pros and Cons of Correlation\rPros:\r- Nature gives you correlations for free.\r- In principle, everyone can agree on the facts.\nCons:\r- Correlations are not very helpful.\r- They show what has happened, but not why.\r- For many things, we care about why.\nWhy a Correlation Exists Between X and Y\r\\(X \\rightarrow Y\\)\rX causes Y (causality)\n\r\\(X \\leftarrow Y\\)\rY causes X (reverse causality)\n\r\\(Z \\rightarrow X\\); \\(Z \\rightarrow Y\\)\rZ causes X and Y (common cause)\n\r\\(X \\rightarrow Y\\); \\(Y \\rightarrow X\\)\rX causes Y and Y causes X (simultaneous equations)\n\r\r\rUniting Social Science and Computer Science\rWe will start in this course by examining situations where we do not care about why something has happened, but instead we care about our ability to predict its occurrence from existing data.\n(But of course keep in back of mind that if you are making policy, you must care about why something happened).\nWe will also borrow a few other ideas from CS:\r- Anything is data\r+ Satellite data\r+ Unstructured text or audio\r+ Facial expressions or vocal intonations\r- Subtle improvements on existing techniques\r- An eye towards practical implementability over “cleanliness”\n\r\rA Case Study in Prediction\rExample: a firm wishes to predict user behavior based on previous purchases or interactions.\nSmall margins \\(\\rightarrow\\) huge payoffs when scaled up.\n\\(.01\\% \\rightarrow\\) $10 million.\nNot obvious why this was true for Netflix; quite obvious why this is true in financial markets.\n\rMore Recent Examples of Prediction\r\rIdentify the risk factors for prostate cancer.\rClassify a tissue sample into one of several cancer classes, based on a gene expression profile.\rClassify a recorded phoneme based on a log-periodogram.\rPredict whether someone will have a heart attack on the basis of demographic, diet and clinical measurements.\rCustomize an email spam detection system.\rIdentify a hand-drawn object.\rDetermine which oscillations of stellar luminosity are likely due to exoplanets.\rIdentify food combinations that cause spikes in blood glucose level for an individual.\rEstablish the relationship between salary and demographic variables in population survey data.\r\r\rAn Aside: Nomenclature\rMachine learning arose as a subfield of Artificial Intelligence.\nStatistical learning arose as a subfield of Statistics.\nThere is much overlap; however, a few points of distinction:\n\rMachine learning has a greater emphasis on large scale applications and prediction accuracy.\n\rStatistical learning emphasizes models and their interpretability, and precision and uncertainty.\n\rBut the distinction has become more and more blurred, and there is a great deal of “cross-fertilization”.\r\r\rObviously true: machine learning has the upper hand in marketing.\n\rLearning from Data\rThe following are the basic requirements for statistical learning:\nA pattern exists.\rThis pattern is not easily expressed in a closed mathematical form.\rYou have data.\r\r\rCase study: US homicides by firearm\rImagine you live in Europe (if only!) and are offered a job in a US company with many locations in every state. It is a great job, but headlines such as US Gun Homicide Rate Higher Than Other Developed Countries1 have you worried. Fox News runs a scary looking graphic, and charts like the one below only add to that concern:\nOr even worse, this version from everytown.org:\rBut then you remember that (1) this is a hypothetical exercise; (2) you’ll take literally any job at this point; and (3) Geographic diversity matters – the United States is a large and diverse country with 50 very different states (plus the District of Columbia and some lovely territories).2\nCalifornia, for example, has a larger population than Canada, and 20 US states have populations larger than that of Norway. In some respects, the variability across states in the US is akin to the variability across countries in Europe. Furthermore, although not included in the charts above, the murder rates in Lithuania, Ukraine, and Russia are higher than 4 per 100,000. So perhaps the news reports that worried you are too superficial.\nThis is a relatively simple and straightforward problem in social science: you have options of where to live, and want to determine the safety of the various states. Your “research” is clearly policy-relevant: you will eventually have to live somewhere. We will begin to tackle the problem by examining data related to gun homicides in the US during 2010 using R.\nBefore we get started with our example, we need to cover logistics as well as some of the very basic building blocks that are required to gain more advanced R skills. Ideally, this is a refresher. However, we are aware that your preparation in previously courses varies greatly from student to student. Moreover, we want you to be aware that the usefulness of some of these early building blocks may not be immediately obvious. Later in the class you will appreciate having these skills. Mastery will be rewarded both in this class and (of course) in life.\nLet’s pause here for questions\r\r\r\rR basics\rALERT\nThe course content below should be considered a prerequisite for success. For those concerned about basics of R, you absolutely must read this content and attempt the coding exercises. If you struggle to follow the content, please contact the professor or TA.\n\rIn this class, we will be using R software environment for all our analyses. You will learn R and data analysis techniques simultaneously. To follow along you will therefore need access to R. We also recommend the use of an integrated development environment (IDE), such as RStudio, to save your work.\rNote that it is common for a course or workshop to offer access to an R environment and an IDE through your web browser, as done by RStudio cloud3. If you have access to such a resource, you don’t need to install R and RStudio. However, if you intend on becoming a practicing data analyst, we highly recommend installing these tools on your computer4. This is not hard.\nInstalling R and R Studio and Review Resources\rBoth R and RStudio are free and available online. If you have not yet done so, you’ll need to install both R and RStudio. See the Installing page of our course resources for instructions. This will be part of your assignment for this week.\nI have created a video walkthrough for the basics of using R for another course, but it is useful here. You can see part A here (labeled “Part 2a”) here ] and part B here (labeled “Part 2b”) . You should already be at this level of familiarity with R, but if you need a review, this is a good place to start.\n\rThe (very) basics of R\rBefore we get started with the motivating dataset, we need to cover the very basics of R.\nObjects\rSuppose a relatively math unsavvy student asks us for help solving several quadratic equations of the form \\(ax^2+bx+c = 0\\). You—a savvy student—recall that the quadratic formula gives us the solutions:\n\\[\r\\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\,\\, \\mbox{ and } \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\r\\]\nwhich of course depend on the values of \\(a\\), \\(b\\), and \\(c\\). That is, the quadratic equation represents a function with three arguments.\nOne advantage of programming languages is that we can define variables and write expressions with these variables, similar to how we do so in math, but obtain a numeric solution. We will write out general code for the quadratic equation below, but if we are asked to solve \\(x^2 + x -1 = 0\\), then we define:\na \u0026lt;- 1\rb \u0026lt;- 1\rc \u0026lt;- -1\rwhich stores the values for later use. We use \u0026lt;- to assign values to the variables.\nWe can also assign values using = instead of \u0026lt;-, but we recommend against using = to avoid confusion.5\nTRY IT\nCopy and paste the code above into your console to define the three variables. Note that R does not print anything when we make this assignment. This means the objects were defined successfully. Had you made a mistake, you would have received an error message. Throughout these written notes, you’ll have the most success if you continue to copy code into your own console.\n\rTo see the value stored in a variable, we simply ask R to evaluate a and it shows the stored value:\na\r## [1] 1\rA more explicit way to ask R to show us the value stored in a is using print like this:\nprint(a)\r## [1] 1\rWe use the term object to describe stuff that is stored in R. Variables are examples, but objects can also be more complicated entities such as functions, which are described later.\n\rThe workspace\rAs we define objects in the console, we are actually changing the workspace. You can see all the variables saved in your workspace by typing:\nls()\r## [1] \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot; \u0026quot;dat\u0026quot; \u0026quot;filter\u0026quot; \u0026quot;murders\u0026quot; \u0026quot;select\u0026quot;\r(Note that one of my variables listed above comes from generating the graphs above). In RStudio, the Environment tab shows the values:\nWe should see a, b, and c. If you try to recover the value of a variable that is not in your workspace, you receive an error. For example, if you type x you will receive the following message: Error: object 'x' not found.\nNow since these values are saved in variables, to obtain a solution to our equation, we use the quadratic formula:\n(-b + sqrt(b^2 - 4*a*c) ) / ( 2*a )\r## [1] 0.618034\r(-b - sqrt(b^2 - 4*a*c) ) / ( 2*a )\r## [1] -1.618034\r\rFunctions\rOnce you define variables, the data analysis process can usually be described as a series of functions applied to the data. R includes several zillion predefined functions and most of the analysis pipelines we construct make extensive use of the built-in functions. But R’s power comes from its scalability. We have access to (nearly) infinite functions via install.packages and library. As we go through the course, we will carefully note new functions we bring to each problem. For now, though, we will stick to the basics.\nNote that you’ve used a function already: you used the function sqrt to solve the quadratic equation above. These functions do not appear in the workspace because you did not define them, but they are available for immediate use.\nIn general, we need to use parentheses to evaluate a function. If you type ls, the function is not evaluated and instead R shows you the code that defines the function. If you type ls() the function is evaluated and, as seen above, we see objects in the workspace.\nUnlike ls, most functions require one or more arguments. Below is an example of how we assign an object to the argument of the function log. Remember that we earlier defined a to be 1:\nlog(8)\r## [1] 2.079442\rlog(a)\r## [1] 0\rYou can find out what the function expects and what it does by reviewing the very useful manuals included in R. You can get help by using the help function like this:\nhelp(\u0026quot;log\u0026quot;)\rFor most functions, we can also use this shorthand:\n?log\rThe help page will show you what arguments the function is expecting. For example, log needs x and base to run. However, some arguments are required and others are optional. You can determine which arguments are optional by noting in the help document that a default value is assigned with =. Defining these is optional.6 For example, the base of the function log defaults to base = exp(1)—that is, log evaluates the natural log by default.\nIf you want a quick look at the arguments without opening the help system, you can type:\nargs(log)\r## function (x, base = exp(1)) ## NULL\rYou can change the default values by simply assigning another object:\nlog(8, base = 2)\r## [1] 3\rNote that we have not been specifying the argument x as such:\nlog(x = 8, base = 2)\r## [1] 3\rThe above code works, but we can save ourselves some typing: if no argument name is used, R assumes you are entering arguments in the order shown in the help file or by args. So by not using the names, it assumes the arguments are x followed by base:\nlog(8,2)\r## [1] 3\rIf using the arguments’ names, then we can include them in whatever order we want:\nlog(base = 2, x = 8)\r## [1] 3\rTo specify arguments, we must use =, and cannot use \u0026lt;-.\nThere are some exceptions to the rule that functions need the parentheses to be evaluated. Among these, the most commonly used are the arithmetic and relational operators. For example:\n2 ^ 3\r## [1] 8\rYou can see the arithmetic operators by typing:\nhelp(\u0026quot;+\u0026quot;)\ror\n?\u0026quot;+\u0026quot;\rand the relational operators by typing:\nhelp(\u0026quot;\u0026gt;\u0026quot;)\ror\n?\u0026quot;\u0026gt;\u0026quot;\r\rOther prebuilt objects\rThere are several datasets that are included for users to practice and test out functions. You can see all the available datasets by typing:\ndata()\rThis shows you the object name for these datasets. These datasets are objects that can be used by simply typing the name. For example, if you type:\nco2\rR will show you Mauna Loa atmospheric \\(CO^2\\) concentration data.\nOther prebuilt objects are mathematical quantities, such as the constant \\(\\pi\\) and \\(\\infty\\):\npi\r## [1] 3.141593\rInf+1\r## [1] Inf\r\rVariable names\rWe have used the letters a, b, and c as variable names, but variable names can be almost anything. Some basic rules in R are that variable names have to start with a letter, can’t contain spaces, and should not be variables that are predefined in R. For example, don’t name one of your variables install.packages by typing something like install.packages \u0026lt;- 2. Usually, R is smart enough to prevent you from doing such nonsense, but it’s important to develop good habits.\nA nice convention to follow is to use meaningful words that describe what is stored, use only lower case, and use underscores as a substitute for spaces. For the quadratic equations, we could use something like this:\nsolution_1 \u0026lt;- (-b + sqrt(b^2 - 4*a*c)) / (2*a)\rsolution_2 \u0026lt;- (-b - sqrt(b^2 - 4*a*c)) / (2*a)\rFor more advice, we highly recommend studying (Hadley Wickham’s style guide)[http://adv-r.had.co.nz/Style.html].\n\rSaving your workspace\rValues remain in the workspace until you end your session or erase them with the function rm. But workspaces also can be saved for later use. In fact, when you quit R, the program asks you if you want to save your workspace. If you do save it, the next time you start R, the program will restore the workspace.\nWe actually recommend against saving the workspace this way because, as you start working on different projects, it will become harder to keep track of what is saved. Instead, we recommend you assign the workspace a specific name. You can do this by using the function save or save.image. To load, use the function load. When saving a workspace, we recommend the suffix rda or RData. In RStudio, you can also do this by navigating to the Session tab and choosing Save Workspace as. You can later load it using the Load Workspace options in the same tab.\rYou can read the help pages on save, save.image, and load to learn more.\n\rMotivating scripts\rTo solve another equation such as \\(3x^2 + 2x -1\\), we can copy and paste the code above and then redefine the variables and recompute the solution:\na \u0026lt;- 3\rb \u0026lt;- 2\rc \u0026lt;- -1\r(-b + sqrt(b^2 - 4*a*c)) / (2*a)\r(-b - sqrt(b^2 - 4*a*c)) / (2*a)\rBy creating and saving a script with the code above, we would not need to retype everything each time and, instead, simply change the variable names. Try writing the script above into an editor and notice how easy it is to change the variables and receive an answer.\n\rCommenting your code\rIf a line of R code starts with the symbol #, it is not evaluated. We can use this to write reminders of why we wrote particular code. For example, in the script above we could add:\n## Code to compute solution to quadratic equation of the form ax^2 + bx + c\r## define the variables\ra \u0026lt;- 3\rb \u0026lt;- 2\rc \u0026lt;- -1\r## now compute the solution\r(-b + sqrt(b^2 - 4*a*c)) / (2*a)\r(-b - sqrt(b^2 - 4*a*c)) / (2*a)\rTRY IT\nWhat is the sum of the first 100 positive integers? The formula for the sum of integers \\(1\\) through \\(n\\) is \\(n(n+1)/2\\). Define \\(n=100\\) and then use R to compute the sum of \\(1\\) through \\(100\\) using the formula. What is the sum?\n\rNow use the same formula to compute the sum of the integers from 1 through 1,000.\n\rLook at the result of typing the following code into R:\n\r\rn \u0026lt;- 1000\rx \u0026lt;- seq(1, n)\rsum(x)\rBased on the result, what do you think the functions seq and sum do? You can use help.\nsum creates a list of numbers and seq adds them up.\rseq creates a list of numbers and sum adds them up.\rseq creates a random list and sum computes the sum of 1 through 1,000.\rsum always returns the same number.\r\rIn math and programming, we say that we evaluate a function when we replace the argument with a given number. So if we type sqrt(4), we evaluate the sqrt function. In R, you can evaluate a function inside another function. The evaluations happen from the inside out. Use one line of code to compute the log, in base 10, of the square root of 100.\n\rWhich of the following will always return the numeric value stored in x? You can try out examples and use the help system if you want.\n\r\rlog(10^x)\rlog10(x^10)\rlog(exp(x))\rexp(log(x, base = 2))\r\r\r\r\rData types\rVariables in R can be of different types. For example, we need to distinguish numbers from character strings and tables from simple lists of numbers. The function class helps us determine what type of object we have:\na \u0026lt;- 2\rclass(a)\r## [1] \u0026quot;numeric\u0026quot;\rTo work efficiently in R, it is important to learn the different types of variables and what we can do with these.\nData frames\rUp to now, the variables we have defined are just one number. This is not very useful for storing data. The most common way of storing a dataset in R is in a data frame. Conceptually, we can think of a data frame as a table with rows representing observations and the different variables reported for each observation defining the columns. Data frames are particularly useful for datasets because we can combine different data types into one object.\nA large proportion of data analysis challenges start with data stored in a data frame. For example, we stored the data for our motivating example in a data frame. You can access this dataset by loading the dslabs library and loading the murders dataset using the data function:\nlibrary(dslabs)\rdata(murders)\rTo see that this is in fact a data frame, we type:\nclass(murders)\r## [1] \u0026quot;data.frame\u0026quot;\r\rExamining an object\rThe function str is useful for finding out more about the structure of an object:\nstr(murders)\r## \u0026#39;data.frame\u0026#39;: 51 obs. of 5 variables:\r## $ state : chr \u0026quot;Alabama\u0026quot; \u0026quot;Alaska\u0026quot; \u0026quot;Arizona\u0026quot; \u0026quot;Arkansas\u0026quot; ...\r## $ abb : chr \u0026quot;AL\u0026quot; \u0026quot;AK\u0026quot; \u0026quot;AZ\u0026quot; \u0026quot;AR\u0026quot; ...\r## $ region : Factor w/ 4 levels \u0026quot;Northeast\u0026quot;,\u0026quot;South\u0026quot;,..: 2 4 4 2 4 4 1 2 2 2 ...\r## $ population: num 4779736 710231 6392017 2915918 37253956 ...\r## $ total : num 135 19 232 93 1257 ...\rThis tells us much more about the object. We see that the table has 51 rows (50 states plus DC) and five variables. We can show the first six lines using the function head:\nhead(murders)\r## state abb region population total\r## 1 Alabama AL South 4779736 135\r## 2 Alaska AK West 710231 19\r## 3 Arizona AZ West 6392017 232\r## 4 Arkansas AR South 2915918 93\r## 5 California CA West 37253956 1257\r## 6 Colorado CO West 5029196 65\rIn this dataset, each state is considered an observation and five variables are reported for each state.\nBefore we go any further in answering our original question about different states, let’s learn more about the components of this object.\n\rThe accessor: $\rFor our analysis, we will need to access the different variables represented by columns included in this data frame. To do this, we use the accessor operator $ in the following way:\nmurders$population\r## [1] 4779736 710231 6392017 2915918 37253956 5029196 3574097 897934\r## [9] 601723 19687653 9920000 1360301 1567582 12830632 6483802 3046355\r## [17] 2853118 4339367 4533372 1328361 5773552 6547629 9883640 5303925\r## [25] 2967297 5988927 989415 1826341 2700551 1316470 8791894 2059179\r## [33] 19378102 9535483 672591 11536504 3751351 3831074 12702379 1052567\r## [41] 4625364 814180 6346105 25145561 2763885 625741 8001024 6724540\r## [49] 1852994 5686986 563626\rBut how did we know to use population? Previously, by applying the function str to the object murders, we revealed the names for each of the five variables stored in this table. We can quickly access the variable names using:\nnames(murders)\r## [1] \u0026quot;state\u0026quot; \u0026quot;abb\u0026quot; \u0026quot;region\u0026quot; \u0026quot;population\u0026quot; \u0026quot;total\u0026quot;\rIt is important to know that the order of the entries in murders$population preserves the order of the rows in our data table. This will later permit us to manipulate one variable based on the results of another. For example, we will be able to order the state names by the number of murders.\nTip: R comes with a very nice auto-complete functionality that saves us the trouble of typing out all the names. Try typing murders$p then hitting the tab key on your keyboard. This functionality and many other useful auto-complete features are available when working in RStudio.\n\rVectors: numerics, characters, and logical\rThe object murders$population is not one number but several. We call these types of objects vectors. A single number is technically a vector of length 1, but in general we use the term vectors to refer to objects with several entries. The function length tells you how many entries are in the vector:\npop \u0026lt;- murders$population\rlength(pop)\r## [1] 51\rThis particular vector is numeric since population sizes are numbers:\nclass(pop)\r## [1] \u0026quot;numeric\u0026quot;\rIn a numeric vector, every entry must be a number.\nTo store character strings, vectors can also be of class character. For example, the state names are characters:\nclass(murders$state)\r## [1] \u0026quot;character\u0026quot;\rAs with numeric vectors, all entries in a character vector need to be a character.\nAnother important type of vectors are logical vectors. These must be either TRUE or FALSE.\nz \u0026lt;- 3 == 2\rz\r## [1] FALSE\rclass(z)\r## [1] \u0026quot;logical\u0026quot;\rHere the == is a relational operator asking if 3 is equal to 2. In R, if you just use one =, you actually assign a variable, but if you use two == you test for equality. Yet another reason to avoid assigning via =… it can get confusing and typos can really mess things up.\nYou can see the other relational operators by typing:\n?Comparison\rIn future sections, you will see how useful relational operators can be.\nWe discuss more important features of vectors after the next set of exercises.\nAdvanced: Mathematically, the values in pop are integers and there is an integer class in R. However, by default, numbers are assigned class numeric even when they are round integers. For example, class(1) returns numeric. You can turn them into class integer with the as.integer() function or by adding an L like this: 1L. Note the class by typing: class(1L)\n\rFactors\rIn the murders dataset, we might expect the region to also be a character vector. However, it is not:\nclass(murders$region)\r## [1] \u0026quot;factor\u0026quot;\rIt is a factor. Factors are useful for storing categorical data. We can see that there are only 4 regions by using the levels function:\nlevels(murders$region)\r## [1] \u0026quot;Northeast\u0026quot; \u0026quot;South\u0026quot; \u0026quot;North Central\u0026quot; \u0026quot;West\u0026quot;\rIn the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters. It is also useful for computational reasons we’ll explore later.\nNote that the levels have an order that is different from the order of appearance in the factor object. The default in R is for the levels to follow alphabetical order. However, often we want the levels to follow a different order. You can specify an order through the levels argument when creating the factor with the factor function. For example, in the murders dataset regions are ordered from east to west. The function reorder lets us change the order of the levels of a factor variable based on a summary computed on a numeric vector. We will demonstrate this with a simple example, and will see more advanced ones in the Data Visualization part of the book.\nSuppose we want the levels of the region by the total number of murders rather than alphabetical order. If there are values associated with each level, we can use the reorder and specify a data summary to determine the order. The following code takes the sum of the total murders in each region, and reorders the factor following these sums.\nregion \u0026lt;- murders$region\rvalue \u0026lt;- murders$total\rregion \u0026lt;- reorder(region, value, FUN = sum)\rlevels(region)\r## [1] \u0026quot;Northeast\u0026quot; \u0026quot;North Central\u0026quot; \u0026quot;West\u0026quot; \u0026quot;South\u0026quot;\rThe new order is in agreement with the fact that the Northeast has the least murders and the South has the most.\nWarning: Factors can be a source of confusion since sometimes they behave like characters and sometimes they do not. As a result, confusing factors and characters are a common source of bugs.\n\rLists\rData frames are a special case of lists. We will cover lists in more detail later, but know that they are useful because you can store any combination of different types. Below is an example of a list we created for you:\nrecord\r## $name\r## [1] \u0026quot;John Doe\u0026quot;\r## ## $student_id\r## [1] 1234\r## ## $grades\r## [1] 95 82 91 97 93\r## ## $final_grade\r## [1] \u0026quot;A\u0026quot;\rclass(record)\r## [1] \u0026quot;list\u0026quot;\rAs with data frames, you can extract the components of a list with the accessor $. In fact, data frames are a type of list.\nrecord$student_id\r## [1] 1234\rWe can also use double square brackets ([[) like this:\nrecord[[\u0026quot;student_id\u0026quot;]]\r## [1] 1234\rYou should get used to the fact that in R there are often several ways to do the same thing. such as accessing entries.7\nYou might also encounter lists without variable names.\nrecord2\r## [[1]]\r## [1] \u0026quot;John Doe\u0026quot;\r## ## [[2]]\r## [1] 1234\rIf a list does not have names, you cannot extract the elements with $, but you can still use the brackets method and instead of providing the variable name, you provide the list index, like this:\nrecord2[[1]]\r## [1] \u0026quot;John Doe\u0026quot;\rWe won’t be using lists until later, but you might encounter one in your own exploration of R. For this reason, we show you some basics here.\n\rMatrices\rMatrices are another type of object that are common in R. Matrices are similar to data frames in that they are two-dimensional: they have rows and columns. However, like numeric, character and logical vectors, entries in matrices have to be all the same type. For this reason data frames are much more useful for storing data, since we can have characters, factors, and numbers in them.\nYet matrices have a major advantage over data frames: we can perform matrix algebra operations, a powerful type of mathematical technique. We do not describe these operations in this class, but much of what happens in the background when you perform a data analysis involves matrices. We describe them briefly here since some of the functions we will learn return matrices.\nWe can define a matrix using the matrix function. We need to specify the number of rows and columns.\nmat \u0026lt;- matrix(1:12, 4, 3)\rmat\r## [,1] [,2] [,3]\r## [1,] 1 5 9\r## [2,] 2 6 10\r## [3,] 3 7 11\r## [4,] 4 8 12\rYou can access specific entries in a matrix using square brackets ([). If you want the second row, third column, you use:\nmat[2, 3]\r## [1] 10\rIf you want the entire second row, you leave the column spot empty:\nmat[2, ]\r## [1] 2 6 10\rNotice that this returns a vector, not a matrix.\nSimilarly, if you want the entire third column, you leave the row spot empty:\nmat[, 3]\r## [1] 9 10 11 12\rThis is also a vector, not a matrix.\nYou can access more than one column or more than one row if you like. This will give you a new matrix.\nmat[, 2:3]\r## [,1] [,2]\r## [1,] 5 9\r## [2,] 6 10\r## [3,] 7 11\r## [4,] 8 12\rYou can subset both rows and columns:\nmat[1:2, 2:3]\r## [,1] [,2]\r## [1,] 5 9\r## [2,] 6 10\rWe can convert matrices into data frames using the function as.data.frame:\nas.data.frame(mat)\r## V1 V2 V3\r## 1 1 5 9\r## 2 2 6 10\r## 3 3 7 11\r## 4 4 8 12\rYou can also use single square brackets ([) to access rows and columns of a data frame:\ndata(\u0026quot;murders\u0026quot;)\rmurders[25, 1]\r## [1] \u0026quot;Mississippi\u0026quot;\rmurders[2:3, ]\r## state abb region population total\r## 2 Alaska AK West 710231 19\r## 3 Arizona AZ West 6392017 232\rTRY IT\nLoad the US murders dataset.\r\rlibrary(dslabs)\rdata(murders)\rUse the function str to examine the structure of the murders object. Which of the following best describes the variables represented in this data frame?\nThe 51 states.\rThe murder rates for all 50 states and DC.\rThe state name, the abbreviation of the state name, the state’s region, and the state’s population and total number of murders for 2010.\rstr shows no relevant information.\r\rWhat are the column names used by the data frame for these five variables?\n\rUse the accessor $ to extract the state abbreviations and assign them to the object a. What is the class of this object?\n\rNow use the square brackets to extract the state abbreviations and assign them to the object b. Use the identical function to determine if a and b are the same.\n\rWe saw that the region column stores a factor. You can corroborate this by typing:\n\r\rclass(murders$region)\rWith one line of code, use the function levels and length to determine the number of regions defined by this dataset.\nThe function table takes a vector and returns the frequency of each element. You can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of states per region.\r\r\r\r\rVectors\rIn R, the most basic objects available to store data are vectors. As we have seen, complex datasets can usually be broken down into components that are vectors. For example, in a data frame, each column is a vector. Here we learn more about this important class.\nCreating vectors\rWe can create vectors using the function c, which stands for concatenate. We use c to concatenate entries in the following way:\ncodes \u0026lt;- c(380, 124, 818)\rcodes\r## [1] 380 124 818\rWe can also create character vectors. We use the quotes to denote that the entries are characters rather than variable names.\ncountry \u0026lt;- c(\u0026quot;italy\u0026quot;, \u0026quot;canada\u0026quot;, \u0026quot;egypt\u0026quot;)\rIn R you can also use single quotes:\ncountry \u0026lt;- c(\u0026#39;italy\u0026#39;, \u0026#39;canada\u0026#39;, \u0026#39;egypt\u0026#39;)\rBut be careful not to confuse the single quote ’ with the back quote, which shares a keyboard key with ~.\nBy now you should know that if you type:\ncountry \u0026lt;- c(italy, canada, egypt)\ryou receive an error because the variables italy, canada, and egypt are not defined. If we do not use the quotes, R looks for variables with those names and returns an error.\n\rNames\rSometimes it is useful to name the entries of a vector. For example, when defining a vector of country codes, we can use the names to connect the two:\ncodes \u0026lt;- c(italy = 380, canada = 124, egypt = 818)\rcodes\r## italy canada egypt ## 380 124 818\rThe object codes continues to be a numeric vector:\nclass(codes)\r## [1] \u0026quot;numeric\u0026quot;\rbut with names:\nnames(codes)\r## [1] \u0026quot;italy\u0026quot; \u0026quot;canada\u0026quot; \u0026quot;egypt\u0026quot;\rIf the use of strings without quotes looks confusing, know that you can use the quotes as well:\ncodes \u0026lt;- c(\u0026quot;italy\u0026quot; = 380, \u0026quot;canada\u0026quot; = 124, \u0026quot;egypt\u0026quot; = 818)\rcodes\r## italy canada egypt ## 380 124 818\rThere is no difference between this function call and the previous one. This is one of the many ways in which R is quirky compared to other languages.\nWe can also assign names using the names functions:\ncodes \u0026lt;- c(380, 124, 818)\rcountry \u0026lt;- c(\u0026quot;italy\u0026quot;,\u0026quot;canada\u0026quot;,\u0026quot;egypt\u0026quot;)\rnames(codes) \u0026lt;- country\rcodes\r## italy canada egypt ## 380 124 818\r\rSequences\rAnother useful function for creating vectors generates sequences:\nseq(1, 10)\r## [1] 1 2 3 4 5 6 7 8 9 10\rThe first argument defines the start, and the second defines the end which is included. The default is to go up in increments of 1, but a third argument lets us tell it how much to jump by:\nseq(1, 10, 2)\r## [1] 1 3 5 7 9\rIf we want consecutive integers, we can use the following shorthand:\n1:10\r## [1] 1 2 3 4 5 6 7 8 9 10\rWhen we use these functions, R produces integers, not numerics, because they are typically used to index something:\nclass(1:10)\r## [1] \u0026quot;integer\u0026quot;\rHowever, if we create a sequence including non-integers, the class changes:\nclass(seq(1, 10, 0.5))\r## [1] \u0026quot;numeric\u0026quot;\r\rSubsetting\rWe use square brackets to access specific elements of a vector. For the vector codes we defined above, we can access the second element using:\ncodes[2]\r## canada ## 124\rYou can get more than one entry by using a multi-entry vector as an index:\ncodes[c(1,3)]\r## italy egypt ## 380 818\rThe sequences defined above are particularly useful if we want to access, say, the first two elements:\ncodes[1:2]\r## italy canada ## 380 124\rIf the elements have names, we can also access the entries using these names. Below are two examples.\ncodes[\u0026quot;canada\u0026quot;]\r## canada ## 124\rcodes[c(\u0026quot;egypt\u0026quot;,\u0026quot;italy\u0026quot;)]\r## egypt italy ## 818 380\r\r\rCoercion\rIn general, coercion is an attempt by R to be flexible with data types. When an entry does not match the expected, some of the prebuilt R functions try to guess what was meant before throwing an error. This can also lead to confusion. Failing to understand coercion can drive programmers crazy when attempting to code in R since it behaves quite differently from most other languages in this regard. Let’s learn about it with some examples.\nWe said that vectors must be all of the same type. So if we try to combine, say, numbers and characters, you might expect an error:\nx \u0026lt;- c(1, \u0026quot;canada\u0026quot;, 3)\rBut we don’t get one, not even a warning! What happened? Look at x and its class:\nx\r## [1] \u0026quot;1\u0026quot; \u0026quot;canada\u0026quot; \u0026quot;3\u0026quot;\rclass(x)\r## [1] \u0026quot;character\u0026quot;\rR coerced the data into characters. It guessed that because you put a character string in the vector, you meant the 1 and 3 to actually be character strings \"1\" and “3”. The fact that not even a warning is issued is an example of how coercion can cause many unnoticed errors in R.\nR also offers functions to change from one type to another. For example, you can turn numbers into characters with:\nx \u0026lt;- 1:5\ry \u0026lt;- as.character(x)\ry\r## [1] \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;5\u0026quot;\rYou can turn it back with as.numeric:\nas.numeric(y)\r## [1] 1 2 3 4 5\rThis function is actually quite useful since datasets that include numbers as character strings are common.\nNot availables (NA)\rThis “topic” seems to be wholly unappreciated and it has been our experience that students often panic when encountering an NA. This often happens when a function tries to coerce one type to another and encounters an impossible case. In such circumstances, R usually gives us a warning and turns the entry into a special value called an NA (for “not available”). For example:\nx \u0026lt;- c(\u0026quot;1\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;3\u0026quot;)\ras.numeric(x)\r## Warning: NAs introduced by coercion\r## [1] 1 NA 3\rR does not have any guesses for what number you want when you type b, so it does not try.\nWhile coercion is a common case leading to NAs, you’ll see them in nearly every real-world dataset. Most often, you will encounter the NAs as a stand-in for missing data. Again, this a common problem in real-world datasets and you need to be aware that it will come up.\n\r\rSorting\rNow that we have mastered some basic R knowledge (ha!), let’s try to gain some insights into the safety of different states in the context of gun murders.\nsort\rSay we want to rank the states from least to most gun murders. The function sort sorts a vector in increasing order. We can therefore see the largest number of gun murders by typing:\nlibrary(dslabs)\rdata(murders)\rsort(murders$total)\r## [1] 2 4 5 5 7 8 11 12 12 16 19 21 22 27 32\r## [16] 36 38 53 63 65 67 84 93 93 97 97 99 111 116 118\r## [31] 120 135 142 207 219 232 246 250 286 293 310 321 351 364 376\r## [46] 413 457 517 669 805 1257\rHowever, this does not give us information about which states have which murder totals. For example, we don’t know which state had 1257.\n\rorder\rThe function order is closer to what we want. It takes a vector as input and returns the vector of indexes that sorts the input vector. This may sound confusing so let’s look at a simple example. We can create a vector and sort it:\nx \u0026lt;- c(31, 4, 15, 92, 65)\rsort(x)\r## [1] 4 15 31 65 92\rRather than sort the input vector, the function order returns the index that sorts input vector:\nindex \u0026lt;- order(x)\rx[index]\r## [1] 4 15 31 65 92\rThis is the same output as that returned by sort(x). If we look at this index, we see why it works:\nx\r## [1] 31 4 15 92 65\rorder(x)\r## [1] 2 3 1 5 4\rThe second entry of x is the smallest, so order(x) starts with 2. The next smallest is the third entry, so the second entry is 3 and so on.\nHow does this help us order the states by murders? First, remember that the entries of vectors you access with $ follow the same order as the rows in the table. For example, these two vectors containing state names and abbreviations, respectively, are matched by their order:\nmurders$state[1:6]\r## [1] \u0026quot;Alabama\u0026quot; \u0026quot;Alaska\u0026quot; \u0026quot;Arizona\u0026quot; \u0026quot;Arkansas\u0026quot; \u0026quot;California\u0026quot;\r## [6] \u0026quot;Colorado\u0026quot;\rmurders$abb[1:6]\r## [1] \u0026quot;AL\u0026quot; \u0026quot;AK\u0026quot; \u0026quot;AZ\u0026quot; \u0026quot;AR\u0026quot; \u0026quot;CA\u0026quot; \u0026quot;CO\u0026quot;\rThis means we can order the state names by their total murders. We first obtain the index that orders the vectors according to murder totals and then index the state names vector:\nind \u0026lt;- order(murders$total)\rmurders$abb[ind]\r## [1] \u0026quot;VT\u0026quot; \u0026quot;ND\u0026quot; \u0026quot;NH\u0026quot; \u0026quot;WY\u0026quot; \u0026quot;HI\u0026quot; \u0026quot;SD\u0026quot; \u0026quot;ME\u0026quot; \u0026quot;ID\u0026quot; \u0026quot;MT\u0026quot; \u0026quot;RI\u0026quot; \u0026quot;AK\u0026quot; \u0026quot;IA\u0026quot; \u0026quot;UT\u0026quot; \u0026quot;WV\u0026quot; \u0026quot;NE\u0026quot;\r## [16] \u0026quot;OR\u0026quot; \u0026quot;DE\u0026quot; \u0026quot;MN\u0026quot; \u0026quot;KS\u0026quot; \u0026quot;CO\u0026quot; \u0026quot;NM\u0026quot; \u0026quot;NV\u0026quot; \u0026quot;AR\u0026quot; \u0026quot;WA\u0026quot; \u0026quot;CT\u0026quot; \u0026quot;WI\u0026quot; \u0026quot;DC\u0026quot; \u0026quot;OK\u0026quot; \u0026quot;KY\u0026quot; \u0026quot;MA\u0026quot;\r## [31] \u0026quot;MS\u0026quot; \u0026quot;AL\u0026quot; \u0026quot;IN\u0026quot; \u0026quot;SC\u0026quot; \u0026quot;TN\u0026quot; \u0026quot;AZ\u0026quot; \u0026quot;NJ\u0026quot; \u0026quot;VA\u0026quot; \u0026quot;NC\u0026quot; \u0026quot;MD\u0026quot; \u0026quot;OH\u0026quot; \u0026quot;MO\u0026quot; \u0026quot;LA\u0026quot; \u0026quot;IL\u0026quot; \u0026quot;GA\u0026quot;\r## [46] \u0026quot;MI\u0026quot; \u0026quot;PA\u0026quot; \u0026quot;NY\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;TX\u0026quot; \u0026quot;CA\u0026quot;\rAccording to the above, California had the most murders.\n\rmax and which.max\rIf we are only interested in the entry with the largest value, we can use max for the value:\nmax(murders$total)\r## [1] 1257\rand which.max for the index of the largest value:\ni_max \u0026lt;- which.max(murders$total)\rmurders$state[i_max]\r## [1] \u0026quot;California\u0026quot;\rFor the minimum, we can use min and which.min in the same way.\nDoes this mean California is the most dangerous state? In an upcoming section, we argue that we should be considering rates instead of totals. Before doing that, we introduce one last order-related function: rank.\n\rrank\rAlthough not as frequently used as order and sort, the function rank is also related to order and can be useful.\rFor any given vector it returns a vector with the rank of the first entry, second entry, etc., of the input vector. Here is a simple example:\nx \u0026lt;- c(31, 4, 15, 92, 65)\rrank(x)\r## [1] 3 1 2 5 4\rTo summarize, let’s look at the results of the three functions we have introduced:\n\r\roriginal\r\rsort\r\rorder\r\rrank\r\r\r\r\r\r31\r\r4\r\r2\r\r3\r\r\r\r4\r\r15\r\r3\r\r1\r\r\r\r15\r\r31\r\r1\r\r2\r\r\r\r92\r\r65\r\r5\r\r5\r\r\r\r65\r\r92\r\r4\r\r4\r\r\r\r\r\rBeware of recycling\rAnother common source of unnoticed errors in R is the use of recycling. We saw that vectors are added elementwise. So if the vectors don’t match in length, it is natural to assume that we should get an error. But we don’t. Notice what happens:\nx \u0026lt;- c(1,2,3)\ry \u0026lt;- c(10, 20, 30, 40, 50, 60, 70)\rx+y\r## Warning in x + y: longer object length is not a multiple of shorter object\r## length\r## [1] 11 22 33 41 52 63 71\rWe do get a warning, but no error. For the output, R has recycled the numbers in x. Notice the last digit of numbers in the output.\nTRY IT\nFor these exercises we will use the US murders dataset. Make sure you load it prior to starting.\nlibrary(dslabs)\rdata(\u0026quot;murders\u0026quot;)\rUse the $ operator to access the population size data and store it as the object pop. Then use the sort function to redefine pop so that it is sorted. Finally, use the [ operator to report the smallest population size.\n\rNow instead of the smallest population size, find the index of the entry with the smallest population size. Hint: use order instead of sort.\n\rWe can actually perform the same operation as in the previous exercise using the function which.min. Write one line of code that does this.\n\rNow we know how small the smallest state is and we know which row represents it. Which state is it? Define a variable states to be the state names from the murders data frame. Report the name of the state with the smallest population.\n\rYou can create a data frame using the data.frame function. Here is a quick example:\n\r\rtemp \u0026lt;- c(35, 88, 42, 84, 81, 30)\rcity \u0026lt;- c(\u0026quot;Beijing\u0026quot;, \u0026quot;Lagos\u0026quot;, \u0026quot;Paris\u0026quot;, \u0026quot;Rio de Janeiro\u0026quot;,\r\u0026quot;San Juan\u0026quot;, \u0026quot;Toronto\u0026quot;)\rcity_temps \u0026lt;- data.frame(name = city, temperature = temp)\rUse the rank function to determine the population rank of each state from smallest population size to biggest. Save these ranks in an object called ranks, then create a data frame with the state name and its rank. Call the data frame my_df.\nRepeat the previous exercise, but this time order my_df so that the states are ordered from least populous to most populous. Hint: create an object ind that stores the indexes needed to order the population values. Then use the bracket operator [ to re-order each column in the data frame.\n\rThe na_example vector represents a series of counts. You can quickly examine the object using:\n\r\rdata(\u0026quot;na_example\u0026quot;)\rstr(na_example)\r## int [1:1000] 2 1 3 2 1 3 1 4 3 2 ...\rHowever, when we compute the average with the function mean, we obtain an NA:\nmean(na_example)\r## [1] NA\rThe is.na function returns a logical vector that tells us which entries are NA. Assign this logical vector to an object called ind and determine how many NAs does na_example have.\nNow compute the average again, but only for the entries that are not NA. Hint: remember the ! operator.\r\r\r\r\rVector arithmetics\rCalifornia had the most murders, but does this mean it is the most dangerous state? What if it just has many more people than any other state? We can quickly confirm that California indeed has the largest population:\nlibrary(dslabs)\rdata(\u0026quot;murders\u0026quot;)\rmurders$state[which.max(murders$population)]\r## [1] \u0026quot;California\u0026quot;\rwith over 37 million inhabitants. It is therefore unfair to compare the totals if we are interested in learning how safe the state is. What we really should be computing is the murders per capita. The reports we describe in the motivating section used murders per 100,000 as the unit. To compute this quantity, the powerful vector arithmetic capabilities of R come in handy.\nRescaling a vector\rIn R, arithmetic operations on vectors occur element-wise. For a quick example, suppose we have height in inches:\ninches \u0026lt;- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)\rand want to convert to centimeters. Notice what happens when we multiply inches by 2.54:\ninches * 2.54\r## [1] 175.26 157.48 167.64 177.80 177.80 185.42 170.18 185.42 170.18 177.80\rIn the line above, we multiplied each element by 2.54. Similarly, if for each entry we want to compute how many inches taller or shorter than 69 inches, the average height for males, we can subtract it from every entry like this:\ninches - 69\r## [1] 0 -7 -3 1 1 4 -2 4 -2 1\r\rTwo vectors\rIf we have two vectors of the same length, and we sum them in R, they will be added entry by entry as follows:\n\\[\r\\begin{pmatrix}\ra\\\\\rb\\\\\rc\\\\\rd\r\\end{pmatrix}\r+\r\\begin{pmatrix}\re\\\\\rf\\\\\rg\\\\\rh\r\\end{pmatrix}\r=\r\\begin{pmatrix}\ra +e\\\\\rb + f\\\\\rc + g\\\\\rd + h\r\\end{pmatrix}\r\\]\nThe same holds for other mathematical operations, such as -, * and /.\nThis implies that to compute the murder rates we can simply type:\nmurder_rate \u0026lt;- murders$total / murders$population * 100000\rOnce we do this, we notice that California is no longer near the top of the list. In fact, we can use what we have learned to order the states by murder rate:\nmurders$abb[order(murder_rate)]\r## [1] \u0026quot;VT\u0026quot; \u0026quot;NH\u0026quot; \u0026quot;HI\u0026quot; \u0026quot;ND\u0026quot; \u0026quot;IA\u0026quot; \u0026quot;ID\u0026quot; \u0026quot;UT\u0026quot; \u0026quot;ME\u0026quot; \u0026quot;WY\u0026quot; \u0026quot;OR\u0026quot; \u0026quot;SD\u0026quot; \u0026quot;MN\u0026quot; \u0026quot;MT\u0026quot; \u0026quot;CO\u0026quot; \u0026quot;WA\u0026quot;\r## [16] \u0026quot;WV\u0026quot; \u0026quot;RI\u0026quot; \u0026quot;WI\u0026quot; \u0026quot;NE\u0026quot; \u0026quot;MA\u0026quot; \u0026quot;IN\u0026quot; \u0026quot;KS\u0026quot; \u0026quot;NY\u0026quot; \u0026quot;KY\u0026quot; \u0026quot;AK\u0026quot; \u0026quot;OH\u0026quot; \u0026quot;CT\u0026quot; \u0026quot;NJ\u0026quot; \u0026quot;AL\u0026quot; \u0026quot;IL\u0026quot;\r## [31] \u0026quot;OK\u0026quot; \u0026quot;NC\u0026quot; \u0026quot;NV\u0026quot; \u0026quot;VA\u0026quot; \u0026quot;AR\u0026quot; \u0026quot;TX\u0026quot; \u0026quot;NM\u0026quot; \u0026quot;CA\u0026quot; \u0026quot;FL\u0026quot; \u0026quot;TN\u0026quot; \u0026quot;PA\u0026quot; \u0026quot;AZ\u0026quot; \u0026quot;GA\u0026quot; \u0026quot;MS\u0026quot; \u0026quot;MI\u0026quot;\r## [46] \u0026quot;DE\u0026quot; \u0026quot;SC\u0026quot; \u0026quot;MD\u0026quot; \u0026quot;MO\u0026quot; \u0026quot;LA\u0026quot; \u0026quot;DC\u0026quot;\rTRY IT\nPreviously we created this data frame:\r\rtemp \u0026lt;- c(35, 88, 42, 84, 81, 30)\rcity \u0026lt;- c(\u0026quot;Beijing\u0026quot;, \u0026quot;Lagos\u0026quot;, \u0026quot;Paris\u0026quot;, \u0026quot;Rio de Janeiro\u0026quot;,\r\u0026quot;San Juan\u0026quot;, \u0026quot;Toronto\u0026quot;)\rcity_temps \u0026lt;- data.frame(name = city, temperature = temp)\rRemake the data frame using the code above, but add a line that converts the temperature from Fahrenheit to Celsius. The conversion is \\(C = \\frac{5}{9} \\times (F - 32)\\).\nWrite code to compute the following sum \\(1+1/2^2 + 1/3^2 + \\dots 1/100^2\\)? Hint: thanks to Euler, we know it should be close to \\(\\pi^2/6\\).\n\rCompute the per 100,000 murder rate for each state and store it in the object murder_rate. Then compute the average murder rate for the US using the function mean. What is the average?\n\r\r\r\r\rIndexing\rIndexing is a boring name for an important tool. R provides a powerful and convenient way of referencing specific elements of vectors. We can, for example, subset a vector based on properties of another vector. In this section, we continue working with our US murders example, which we can load like this:\nlibrary(dslabs)\rdata(\u0026quot;murders\u0026quot;)\rSubsetting with logicals\rWe have now calculated the murder rate using:\nmurder_rate \u0026lt;- murders$total / murders$population * 100000\rImagine you are moving from Italy where, according to an ABC news report, the murder rate is only 0.71 per 100,000. You would prefer to move to a state with a similar murder rate. Another powerful feature of R is that we can use logicals to index vectors. If we compare a vector to a single number, it actually performs the test for each entry. The following is an example related to the question above:\nind \u0026lt;- murder_rate \u0026lt; 0.71\rIf we instead want to know if a value is less or equal, we can use:\nind \u0026lt;- murder_rate \u0026lt;= 0.71\rNote that we get back a logical vector with TRUE for each entry smaller than or equal to 0.71. To see which states these are, we can leverage the fact that vectors can be indexed with logicals.\nmurders$state[ind]\r## [1] \u0026quot;Hawaii\u0026quot; \u0026quot;Iowa\u0026quot; \u0026quot;New Hampshire\u0026quot; \u0026quot;North Dakota\u0026quot; ## [5] \u0026quot;Vermont\u0026quot;\rIn order to count how many are TRUE, the function sum returns the sum of the entries of a vector and logical vectors get coerced to numeric with TRUE coded as 1 and FALSE as 0. Thus we can count the states using:\nsum(ind)\r## [1] 5\r\rLogical operators\rSuppose we like the mountains and we want to move to a safe state in the western region of the country. We want the murder rate to be at most 1. In this case, we want two different things to be true. Here we can use the logical operator and, which in R is represented with \u0026amp;. This operation results in TRUE only when both logicals are TRUE. To see this, consider this example:\nTRUE \u0026amp; TRUE\r## [1] TRUE\rTRUE \u0026amp; FALSE\r## [1] FALSE\rFALSE \u0026amp; FALSE\r## [1] FALSE\rFor our example, we can form two logicals:\nwest \u0026lt;- murders$region == \u0026quot;West\u0026quot;\rsafe \u0026lt;- murder_rate \u0026lt;= 1\rand we can use the \u0026amp; to get a vector of logicals that tells us which states satisfy both conditions:\nind \u0026lt;- safe \u0026amp; west\rmurders$state[ind]\r## [1] \u0026quot;Hawaii\u0026quot; \u0026quot;Idaho\u0026quot; \u0026quot;Oregon\u0026quot; \u0026quot;Utah\u0026quot; \u0026quot;Wyoming\u0026quot;\r\rwhich\rSuppose we want to look up California’s murder rate. For this type of operation, it is convenient to convert vectors of logicals into indexes instead of keeping long vectors of logicals. The function which tells us which entries of a logical vector are TRUE. So we can type:\nind \u0026lt;- which(murders$state == \u0026quot;California\u0026quot;)\rmurder_rate[ind]\r## [1] 3.374138\r\r%in%\rIf rather than an index we want a logical that tells us whether or not each element of a first vector is in a second, we can use the function %in%. Let’s imagine you are not sure if Boston, Dakota, and Washington are states. You can find out like this:\nc(\u0026quot;Boston\u0026quot;, \u0026quot;Dakota\u0026quot;, \u0026quot;Washington\u0026quot;) %in% murders$state\r## [1] FALSE FALSE TRUE\rNote that we will be using %in% often throughout the course\nEXERCISES\nStart by loading the library and data.\nlibrary(dslabs)\rdata(murders)\rCompute the per 100,000 murder rate for each state and store it in an object called murder_rate. Then use logical operators to create a logical vector named low that tells us which entries of murder_rate are lower than 1.\n\rNow use the results from the previous exercise and the function which to determine the indices of murder_rate associated with values lower than 1.\n\rUse the results from the previous exercise to report the names of the states with murder rates lower than 1.\n\rNow extend the code from exercises 2 and 3 to report the states in the Northeast with murder rates lower than 1. Hint: use the previously defined logical vector low and the logical operator \u0026amp;.\n\rIn a previous exercise we computed the murder rate for each state and the average of these numbers. How many states are below the average?\n\rUse the match function to identify the states with abbreviations AK, MI, and IA. Hint: start by defining an index of the entries of murders$abb that match the three abbreviations, then use the [ operator to extract the states.\n\rUse the %in% operator to create a logical vector that answers the question: which of the following are actual abbreviations: MA, ME, MI, MO, MU?\n\rExtend the code you used in exercise 7 to report the one entry that is not an actual abbreviation. Hint: use the ! operator, which turns FALSE into TRUE and vice versa, then which to obtain an index.\n\r\r\r\r\r\r\rhttp://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership-homicide-rate-higher-than-other-developed-countries/↩︎\n\rI’m especially partial to Puerto Rico.↩︎\n\rhttps://rstudio.cloud↩︎\n\rhttps://rafalab.github.io/dsbook/installing-r-rstudio.html↩︎\n\rThis is, without a doubt, my least favorite aspect of R. I’d even venture to call it stupid. The logic behind this pesky \u0026lt;- is a total mystery to me, but there is logic to avoiding =. But, you do you.↩︎\n\rThis equals sign is the reasons we assign values with \u0026lt;-; then when arguments of a function are assigned values, we don’t end up with multiple equals signs. But… who cares.↩︎\n\rWhether you view this as a feature or a bug is a good indicator whether you’ll enjoy working with R.↩︎\n\r\r\r","date":1661817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661859108,"objectID":"9be773bd8dbb1773f9326846c039d666","permalink":"https://ssc442kirkpatrick.netlify.app/content/00-content/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/content/00-content/","section":"content","summary":"Readings\r\rGuiding Question\r\rA Brief Introduction to SSC442\r\rAbout Me\rAbout You\rThis Course\rMore About This Course\rAnd finally…\r\rWhat is “Data Analytics”?\r\rStarting point for this course\r\rOutline of the Course\r\rNon-Social Science Approaches to Statistical Learning\rThe Pros and Cons of Correlation\rA Case Study in Prediction\rMore Recent Examples of Prediction\rAn Aside: Nomenclature\rLearning from Data\rCase study: US homicides by firearm\r\rR basics\r\rInstalling R and R Studio and Review Resources\rThe (very) basics of R\r\rObjects\rThe workspace\rFunctions\rOther prebuilt objects\rVariable names\rSaving your workspace\rMotivating scripts\rCommenting your code\r\rData types\r\rData frames\rExamining an object\rThe accessor: $\rVectors: numerics, characters, and logical\rFactors\rLists\rMatrices\r\rVectors\r\rCreating vectors\rNames\rSequences\rSubsetting\r\rCoercion\r\rNot availables (NA)\r\rSorting\r\rsort\rorder\rmax and which.","tags":null,"title":"Welcome Back to R","type":"docs"},{"authors":null,"categories":null,"content":"\r\rPart 1: Rats, rats, rats.\r\rInstructions\rStarter code\r\rPart 2: Data Hunting\rEvaluations\r\r\rOne member of each group should turn in the group’s work on D2L. The turned-in copy should have the group member’s names at the top.\nTurn in your copies by 11:59 on the date listed on the Schedule\n\rPart 1: Rats, rats, rats.\rNew York City is full of urban wildlife, and rats are one of the city’s most infamous animal mascots. Rats in NYC are plentiful, but they also deliver food, so they’re useful too.\n   NYC keeps incredibly detailed data regarding animal sightings, including rats, and it makes this data publicly available.\nFor this first project, pretend that you are an analyst with the NYC Mayor’s office, and you have been tasked with getting a better understanding of the rat problem. Your job is to use R and ggplot2 to tell an interesting story hidden in the data. You must create a story by looking carefully at the data, finding some insight into where or when rat sightings occur, and describing to the Mayor how this insight may inform a strategy to address the rats. Your assignment will take the form of a memo that presents the data and insights along with appropriate visualizations that communicate the story in-line. Your memo should be approximately 2-4 pages (including plots) and, of course, will use Rmarkdown rendered to PDF using LaTeX.\nInstructions\rHere’s what you need to do:\nDownload New York City’s database of rat sightings since 2010:\n\r Rat_sightings.csv\r\rSummarize the data somehow. The raw data has more than 100,000 rows, which means you’ll need to aggregate the data (filter(), group_by(), and summarize() will be your friends). Consider looking at the number of sightings per borough, per year, per dwelling type, etc., or a combination of these, like the change in the number sightings across the 5 boroughs between 2010 and 2016.\n\rCreate an appropriate visualization based on the data you summarized.\n\rWrite a polished, professional memo presenting your analysis. We are specifically looking for a discussion of the following:\n\rWhat story are you telling with your new graphic?\rHow have you applied reasonable standards in visual storytelling?\rWhat policy implication is there (if any)?\r\rUpload the following outputs to D2L:\n\rA PDF file of your memo with your graphics embedded in it.1 This means you’ll need to do all your coding in an R Markdown file and embed your code in chunks.\rNote that Part 2 of this project should be included in this PDF in it’s own section (see below).\rNothing else. No .Rmd, no code, nothing but your clean, polished memo with Part 1 and Part 2.\r\r\rSome important notes on your assignment\n\rYour assignment should be clean and polished as if you were a city employee and you were turning in a work product. It should should flow nicely and use subsections (using ### at the start of the line) as appropriate.\rDo not “annotate” your thought process (e.g. do not write “we tried X but there were too many NA’s, so we did Y instead”). This should be a polished memo suitable for turning in as a work product.\rYour code should not appear in your output - it should be only your plots and memo writing.\r\rTo turn off code echoing, add echo = FALSE in each of your code chunk options (e.g. {r setup, echo = FALSE}), or set it globally in the first code chunk inside the knitr::opts_chunk$set function.\r\r\r\rStarter code\rI’ve provided some starter code below. A couple comments about it:\n\rBy default, read_csv() treats cells that are empty or “NA” as missing values. This rat dataset uses “N/A” to mark missing values, so we need to add that as a possible marker of missingness (hence na = c(\"\", \"NA\", \"N/A\"))\rTo make life easier, I’ve renamed some of the key variables you might work with. You can rename others if you want.\rI’ve also created a few date-related variables (sighting_year, sighting_month, sighting_day, and sighting_weekday). You don’t have to use them, but they’re there if you need them. The functions that create these, like year() and wday() are part of the lubridate library.\rThe date/time variables are formatted like 04/03/2017 12:00:00 AM, which R is not able to automatically parse as a date when reading the CSV file. You can use the mdy_hms() function in the lubridate library to parse dates that are structured as “month-day-year-hour-minute”. There are also a bunch of other iterations of this function, like ymd(), dmy(), etc., for other date formats.\rThere’s one row with an unspecified borough, so I filter that out.\r\rlibrary(tidyverse)\rlibrary(lubridate)\rrats_raw \u0026lt;- read_csv(\u0026quot;data/Rat_Sightings.csv\u0026quot;, na = c(\u0026quot;\u0026quot;, \u0026quot;NA\u0026quot;, \u0026quot;N/A\u0026quot;))\r# If you get an error that says \u0026quot;All formats failed to parse. No formats\r# found\u0026quot;, it\u0026#39;s because the mdy_hms function couldn\u0026#39;t parse the date. The date\r# variable *should* be in this format: \u0026quot;04/03/2017 12:00:00 AM\u0026quot;, but in some\r# rare instances, it might load without the seconds as \u0026quot;04/03/2017 12:00 AM\u0026quot;.\r# If there are no seconds, use mdy_hm() instead of mdy_hms().\rrats_clean \u0026lt;- rats_raw %\u0026gt;%\rrename(created_date = `Created Date`,\rlocation_type = `Location Type`,\rborough = Borough) %\u0026gt;%\rmutate(created_date = mdy_hms(created_date)) %\u0026gt;%\rmutate(sighting_year = year(created_date),\rsighting_month = month(created_date),\rsighting_day = day(created_date),\rsighting_weekday = wday(created_date, label = TRUE, abbr = FALSE)) %\u0026gt;%\rfilter(borough != \u0026quot;Unspecified\u0026quot;)\rYou’ll summarize the data with functions from dplyr, including stuff like count(), arrange(), filter(), group_by(), summarize(), and mutate(). Here are some examples of ways to summarize the data:\n# See the count of rat sightings by weekday\rrats_clean %\u0026gt;%\rcount(sighting_weekday)\r# Assign a summarized data frame to an object to use it in a plot\rrats_by_weekday \u0026lt;- rats_clean %\u0026gt;%\rcount(sighting_weekday, sighting_year)\rggplot(rats_by_weekday, aes(x = fct_rev(sighting_weekday), y = n)) +\rgeom_col() +\rcoord_flip() +\rfacet_wrap(~ sighting_year)\r# See the count of rat sightings by weekday and borough\rrats_clean %\u0026gt;%\rcount(sighting_weekday, borough, sighting_year)\r# An alternative to count() is to specify the groups with group_by() and then\r# be explicit about how you\u0026#39;re summarizing the groups, such as calculating the\r# mean, standard deviation, or number of observations (we do that here with\r# `n()`).\rrats_clean %\u0026gt;%\rgroup_by(sighting_weekday, borough) %\u0026gt;%\rsummarize(n = n())\r\r\rPart 2: Data Hunting\rFor the second part of the project, your task is simple. Your group must identify three different data sources2 for potential use in your final project. You are not bound to this decision.\nDo not use Kaggle data. While Kaggle is useful for learning data science, part of this assignment is learning how to find actual data in the wild.\nFor each dataset, you must write a single short paragraph about what about this data interests you. Add this to the memo from Part 1, using ## to make a new header in Rmarkdown for this section.\n\rEvaluations\rI will evaluate these projects (not the TA). I will only give top marks to those groups showing initiative and cleverness. I will use the following weights for final scores:\nPart 1\nTechnical difficulty: Does the final project show mastery of the skills we’ve discussed thus far? Are axes and legends appropriately labeled? (12 points)\n\rAppropriateness of visuals: Do the visualizations tell a clear story? Have we learned something? (10 points)\n\rStorytelling: Does your memo clearly convey what you’re doing and why? (10 points)\n\r\rPart 2\nEach piece of data (and description) is worth 6 points. (18 points total)\n.small[Updated 4-4-2022]\n\r\rYou can approach this in a couple different ways—you can write the memo and then include the full figure and code at the end, similar to this blog post, or you can write the memo in an incremental way, describing the different steps of creating the figure, ultimately arriving at a clean final figure, like this blog post.↩︎\n\rThe three different sources need not be different websites or from different organizations. For example, three different tables from the US Census would be sufficient↩︎\n\r\r\r","date":1661817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661859684,"objectID":"1ee2ebbd4938399d5199cb912763ad52","permalink":"https://ssc442kirkpatrick.netlify.app/assignment/project1/","publishdate":"2022-08-30T00:00:00Z","relpermalink":"/assignment/project1/","section":"assignment","summary":"Part 1: Rats, rats, rats.\r\rInstructions\rStarter code\r\rPart 2: Data Hunting\rEvaluations\r\r\rOne member of each group should turn in the group’s work on D2L. The turned-in copy should have the group member’s names at the top.\nTurn in your copies by 11:59 on the date listed on the Schedule\n\rPart 1: Rats, rats, rats.\rNew York City is full of urban wildlife, and rats are one of the city’s most infamous animal mascots.","tags":null,"title":"Project 1","type":"docs"},{"authors":null,"categories":null,"content":"\r\rReadings\r\rGuiding Question\r\rGroup Projects\r\rTeams\r\rRandomness and Data Analytics\r\rLearning From Data\rFormalization\rThe Target Function\rWhy Estimate an Unknown Function?\rThe Parable of the Marbles\rOutside the Data\rHoeffding’s Inequality\rAn example of Hoeffding’s Inequality\r\rThe tidyverse\r\rTidy data\rManipulating data frames\r\rAdding a column with mutate\rSubsetting with filter\rSelecting columns with select\r\rThe pipe: %\u0026gt;%\rSummarizing data\r\rsummarize\rpull\rGroup then summarize with group_by\r\rSorting data frames\r\rNested sorting\rThe top \\(n\\)\r\rTibbles\r\rTibbles display better\rSubsets of tibbles are tibbles\rTibbles can have complex entries\rTibbles can be grouped\rCreate a tibble using tibble instead of data.frame\r\rThe dot operator\rdo\rThe purrr package\rTidyverse conditionals\r\rcase_when\rbetween\r\r\r\r\rReadings\r\rThis page.\rChapter 1 of Introduction to Statistical Learning, available here.\rOptional: The “Tidy Your Data” tutorial on Rstudio Clould Primers\r\rGuiding Question\rFor future lectures, the guiding questions will be more pointed and at a higher level to help steer your thinking. Here, we want to ensure you remember some basics and accordingly the questions are straightforward.\n\rWhy do we want tidy data?\rWhat are the challenges associated with shaping things into a tidy format?\r\rOverview\r\r\r\r\r\r\r--\r\r\rGroup Projects\rYour final is a group project.\nYou need to start planning soon.\nTo aid in your planning, here are the required elements of your project (note: the project assignment that currently exists on this site, if you find it, is old and will change a lot between now and next week).\nYou must find existing data to analyze. Aggregating and merging data from multiple sources is encouraged.\n\rYou must visualize 3 intersting features of that data.\n\rYou must come up with some analysis—using tools from this course—which relates your data to either a prediction or a policy conclusion.\n\rYou must think critically about your analysis and be able to identify potential issues/\n\rYou must present your analysis as if presenting to a C-suite executive.\n\r\rTeams\rPlease form teams of 2-4 people. Once all agree to be on a team, have one person email our TA, Xueshi, wangxu36@msu.edu and cc all of the members of the team so that nobody is surprised to be included on a team. Title the email [SSC442] - Group Formation. Tell us your team name, and list in the email the names of all of the team members and their email address (in addition to cc-ing those team members on the email).\nIf you opt to not form a team, you will be automatically added to the “willing to be randomly assigned” pool and will be paired with another 2-3 persons.\nSend this email by Sunday Jan 23rd and I will assign un-teamed folks at the beginning of next week.\nMore on your team\r\rYou should strongly consider coordinating your work via Github\n\rYour team will earn the same scores on all projects\n\rTeams will submit only one write-up for the mini-projects and the final\n\r\rTo combat additional freeloading, we will use a reporting system for work contributed. More details will follow.\n\r\r\rRandomness and Data Analytics\rAnd the fabulous importance of probabilistic inference…\nThis lecture is very “high-level,” which means it is talking about abstract concepts. It is also quite important.\nWe want to discuss why we eventually will need ot utilize tons of difficult mathematics. Why do we care so much about hypothesis tests and the like?\nMoreover, we can highlight why we want our data structured to behave nicely.\nLearning From Data\rThe following are the baisc requirements for statistical learning\nA pattern exists\n\rThis pattern is not easily expressed in a closed mathematical form\n\rYou have data\n\r\r\rFormalization\rWe think of our outcome-of-interest as a reponse or target that we wish to predict or wish to learn something about.\nWe generically refer to the response as \\(Y\\)\nOther aspects of the data are known as features, inputs, predictors, or regressors. We call one of these \\(X_i\\).\n\rThe subscript \\(i\\) indicates that we have an \\(X\\) realized for every individual in our data\r\rWe can refer to the input vector collectively as:\n\\[X = \\begin{bmatrix} x_{11} \u0026amp; x_{12} \\\\\rx_{21} \u0026amp; x_{22} \\\\\r\\vdots \u0026amp; \\vdots \\\\\rx_{N1} \u0026amp; x_{N2}\r\\end{bmatrix}\\]\nWe are seeking some unknown function that maps \\(X\\) to \\(Y\\)\nPut another way, we are seeking to explain \\(Y\\) as follows:\n\\[Y = f(X) + e\\]\n\rThe Target Function\rWe call the function \\(f: \\mathcal{X} \\rightarrow \\mathcal{Y}\\) the target function\nHow do we find the function? We don’t! We get as close as we can, though:\n\rObserve data \\((\\mathbf{x}_1, y_1), \\cdots, (\\mathbf{x}_N, y_N)\\)\n\rUse some algorithm to approximate \\(f\\)\n\rProduce final hypothesis function \\(g \\approx f\\)\n\rEvaluate how well \\(g\\) approximates \\(f\\) and iterate as needed.\n\r\r\rWhy Estimate an Unknown Function?\rWith a good estimate of \\(f\\) we can make predictions of \\(Y\\) at new points \\(X = x\\)\nWe can also understand which components of \\(X = (X_1, X_2, \\cdots, X_m)\\) are important in explaining \\(Y\\), and which are (potentially) irrelevant\n\re.g. GDP and yearsindustrialized have a big impact on emissions but hydroutilization typically does not.\r\rDepending on the complexity of \\(f\\), we may be able to meaningfully understand how each component of \\(X\\) affects \\(Y\\).\n(But we should be careful about assigning causal interpretations, more on this later)\n\rThe Parable of the Marbles\r(Courtesy of Prof. Bushong)\nImagine a bag of marbles with two types of marbles: ♣️ and ♦️.\nWe are going to pick a sample of \\(n\\) marbles (with replacement).\nWe want to learn something about \\(\\mu\\), the objective probability to pick a ♣️.\nIn addition to defining the objective probability of picking a ♣️, we have an observed fraction \\(\\eta\\), which will define as the fraction of ♣️ in the sample.\nQuestion: Can we say anything exact and for-sure about \\(\\mu\\) (outside the data) after observing \\(\\eta\\) (the data)?\n\rNo. It is possible for the sample to be all ♣️, ♣️, ♣️, ♣️, ♣️ even when the bag is is 50/50 ♦️\n\rNo matter what we draw, we can’t (based on that draw alone) eliminate the possibility of drawing a ♦️.\n\rAnd unless we assume that the only two values in the world are ♦️ and ♣️, we can’t rule out 💩1\n\r\r\rQuestion: Then why do we do things like polling (e.g. to predict the outcome of a presidential election)?\n\rThe bad case, that we draw something that has is completely misleading, is possible but not probable.\r\r\rOutside the Data\rPut another way, since \\(f\\) is unknown, it can take on any value outside the data we have, no matter how large the data.\n\rThis is called No Free Lunch\r\rYou cannot know anything for sure about \\(f\\) outside the data without making assumptions.\nIs there any hope to know anything about \\(f\\) outside the data set without making assumptions about \\(f\\)?\nYes, if we are willing to give up the “for sure”\n\rHoeffding’s Inequality\rHoeffding’s Inequality states, loosely, that \\(\\eta\\) cannot be too far from \\(\\mu\\).\n\\[\\mathbb{P}\\left[|\\eta - \\mu| \u0026gt; \\epsilon \\right] \\leq 2e^{-2\\epsilon^2n}\\]\r\\(\\eta \\approx \\mu\\) is called probably approximately correct (PAC) learning.\n\rAn example of Hoeffding’s Inequality\rExample: n = 1,000. Draw a sample and observe \\(\\eta\\)\n\r\\(\\sim\\) 99% of the time, \\(\\mu - .05 \\leq \\eta \\leq \\mu+.05\\)\n\rThis is implied by setting \\(\\epsilon = 0.05\\) and using \\(n=1,000\\)\r\r99.9999996% of the time \\(\\mu - .10 \\leq \\eta \\leq \\mu + .10\\)\n\r\rWhat does this mean?\nIf I repeatedly pick a sample of size 1,000, observe \\(\\eta\\) and claim that \\(\\mu \\in \\left[\\eta - .05, \\eta + .05\\right]\\) (or that the error bar is \\(\\pm 0.05\\)), I will be right 99% of the time.\nOn any particular sample you may be wrong, but not often.\nNOTE\nThis week’s content is split into two “halves”: the critical data manipulation information contained below and a more-entertaining discussion of visualization included in the Exercises.\n\r\r\rThe tidyverse\rIn the first weeks’ content, we demonstrated how to manipulate vectors by reordering and subsetting them through indexing. However, once we start more advanced analyses, the preferred unit for data storage is not the vector but the data frame. In this lecture, we learn to work directly with data frames, which greatly facilitate the organization of information. We will be using data frames for the majority of this class and you will use them for the majority of your data science life (however long that might be). We will focus on a specific data format referred to as tidy and on specific collection of packages that are particularly helpful for working with tidy data referred to as the tidyverse.\nWe can load all the tidyverse packages at once by installing and loading the tidyverse package:2\nlibrary(tidyverse)\rWe will learn how to implement the tidyverse approach throughout the book, but before delving into the details, in this chapter we introduce some of the most widely used tidyverse functionality, starting with the dplyr package for manipulating data frames and the purrr package for working with functions. Note that the tidyverse also includes a graphing package, ggplot2, the readr package, and many others. In this lesson, we first introduce the concept of tidy data and then demonstrate how we use the tidyverse to work with data frames in this format.\nTidy data\rWe say that a data table is in tidy format if each row represents one observation and columns represent the different variables available for each of these observations. The murders dataset is an example of a tidy data frame.\nlibrary(dslabs)\rdata(murders)\rhead(murders)\r## state abb region population total\r## 1 Alabama AL South 4779736 135\r## 2 Alaska AK West 710231 19\r## 3 Arizona AZ West 6392017 232\r## 4 Arkansas AR South 2915918 93\r## 5 California CA West 37253956 1257\r## 6 Colorado CO West 5029196 65\rEach row represent a state with each of the five columns providing a different variable related to these states: name, abbreviation, region, population, and total murders.\nTo see how the same information can be provided in different formats, consider the following example:\nlibrary(dslabs)\rdata(\u0026quot;gapminder\u0026quot;)\rtidy_data \u0026lt;- gapminder %\u0026gt;%\rfilter(country %in% c(\u0026quot;South Korea\u0026quot;, \u0026quot;Germany\u0026quot;) \u0026amp; !is.na(fertility)) %\u0026gt;%\rselect(country, year, fertility)\rhead(tidy_data, 6)\r## country year fertility\r## 1 Germany 1960 2.41\r## 2 South Korea 1960 6.16\r## 3 Germany 1961 2.44\r## 4 South Korea 1961 5.99\r## 5 Germany 1962 2.47\r## 6 South Korea 1962 5.79\rThis tidy dataset provides fertility rates for two countries across the years. This is a tidy dataset because each row presents one observation with the three variables being country, year, and fertility rate. However, this dataset originally came in another format and was reshaped for the dslabs package. Originally, the data was in the following format:\n## country 1960 1961 1962\r## 1 Germany 2.41 2.44 2.47\r## 2 South Korea 6.16 5.99 5.79\rThe same information is provided, but there are two important differences in the format: 1) each row includes several observations and 2) one of the variables, year, is stored in the header. For the tidyverse packages to be optimally used, data need to be reshaped into tidy format, which you will learn to do throughout this course. For starters, though, we will use example datasets that are already in tidy format.\nAlthough not immediately obvious, as you go through the book you will start to appreciate the advantages of working in a framework in which functions use tidy formats for both inputs and outputs. You will see how this permits the data analyst to focus on more important aspects of the analysis rather than the format of the data.\nTRY IT\nExamine the built-in dataset co2. Which of the following is true:\r\rco2 is tidy data: it has one year for each row.\rco2 is not tidy: we need at least one column with a character vector.\rco2 is not tidy: it is a matrix instead of a data frame.\rco2 is not tidy: to be tidy we would have to wrangle it to have three columns (year, month and value), then each co2 observation would have a row.\r\rExamine the built-in dataset ChickWeight. Which of the following is true:\r\rChickWeight is not tidy: each chick has more than one row.\rChickWeight is tidy: each observation (a weight) is represented by one row. The chick from which this measurement came is one of the variables.\rChickWeight is not tidy: we are missing the year column.\rChickWeight is tidy: it is stored in a data frame.\r\rExamine the built-in dataset BOD. Which of the following is true:\r\rBOD is not tidy: it only has six rows.\rBOD is not tidy: the first column is just an index.\rBOD is tidy: each row is an observation with two values (time and demand)\rBOD is tidy: all small datasets are tidy by definition.\r\rWhich of the following built-in datasets is tidy (you can pick more than one):\r\rBJsales\rEuStockMarkets\rDNase\rFormaldehyde\rOrange\rUCBAdmissions\r\r\r\rManipulating data frames\rThe dplyr package from the tidyverse introduces functions that perform some of the most common operations when working with data frames and uses names for these functions that are relatively easy to remember. For instance, to change the data table by adding a new column, we use mutate. To filter the data table to a subset of rows, we use filter. Finally, to subset the data by selecting specific columns, we use select.\nAdding a column with mutate\rWe want all the necessary information for our analysis to be included in the data table. So the first task is to add the murder rates to our murders data frame. The function mutate takes the data frame as a first argument and the name and values of the variable as a second argument using the convention name = values. So, to add murder rates, we use:\nlibrary(dslabs)\rdata(\u0026quot;murders\u0026quot;)\rmurders \u0026lt;- mutate(murders, rate = total / population * 100000)\rNotice that here we used total and population inside the function, which are objects that are not defined in our workspace. But why don’t we get an error?\nThis is one of dplyr’s main features. Functions in this package, such as mutate, know to look for variables in the data frame provided in the first argument. In the call to mutate above, total will have the values in murders$total. This approach makes the code much more readable.\nWe can see that the new column is added:\nhead(murders)\r## state abb region population total rate\r## 1 Alabama AL South 4779736 135 2.824424\r## 2 Alaska AK West 710231 19 2.675186\r## 3 Arizona AZ West 6392017 232 3.629527\r## 4 Arkansas AR South 2915918 93 3.189390\r## 5 California CA West 37253956 1257 3.374138\r## 6 Colorado CO West 5029196 65 1.292453\rAlthough we have overwritten the original murders object, this does not change the object that loaded with data(murders). If we load the murders data again, the original will overwrite our mutated version.\n\rSubsetting with filter\rNow suppose that we want to filter the data table to only show the entries for which the murder rate is lower than 0.71. To do this we use the filter function, which takes the data table as the first argument and then the conditional statement as the second. Like mutate, we can use the unquoted variable names from murders inside the function and it will know we mean the columns and not objects in the workspace.\nfilter(murders, rate \u0026lt;= 0.71)\r## state abb region population total rate\r## 1 Hawaii HI West 1360301 7 0.5145920\r## 2 Iowa IA North Central 3046355 21 0.6893484\r## 3 New Hampshire NH Northeast 1316470 5 0.3798036\r## 4 North Dakota ND North Central 672591 4 0.5947151\r## 5 Vermont VT Northeast 625741 2 0.3196211\r\rSelecting columns with select\rAlthough our data table only has six columns, some data tables include hundreds. If we want to view just a few, we can use the dplyr select function. In the code below we select three columns, assign this to a new object and then filter the new object:\nnew_table \u0026lt;- select(murders, state, region, rate)\rfilter(new_table, rate \u0026lt;= 0.71)\r## state region rate\r## 1 Hawaii West 0.5145920\r## 2 Iowa North Central 0.6893484\r## 3 New Hampshire Northeast 0.3798036\r## 4 North Dakota North Central 0.5947151\r## 5 Vermont Northeast 0.3196211\rIn the call to select, the first argument murders is an object, but state, region, and rate are variable names.\nTRY IT\nLoad the dplyr package and the murders dataset.\r\rlibrary(dplyr)\rlibrary(dslabs)\rdata(murders)\rYou can add columns using the dplyr function mutate. This function is aware of the column names and inside the function you can call them unquoted:\nmurders \u0026lt;- mutate(murders, population_in_millions = population / 10^6)\rWe can write population rather than murders$population. The function mutate knows we are grabbing columns from murders.\nUse the function mutate to add a murders column named rate with the per 100,000 murder rate as in the example code above. Make sure you redefine murders as done in the example code above ( murders \u0026lt;- [your code]) so we can keep using this variable.\nIf rank(x) gives you the ranks of x from lowest to highest, rank(-x) gives you the ranks from highest to lowest. Use the function mutate to add a column rank containing the rank, from highest to lowest murder rate. Make sure you redefine murders so we can keep using this variable.\n\rWith dplyr, we can use select to show only certain columns. For example, with this code we would only show the states and population sizes:\n\r\rselect(murders, state, population) %\u0026gt;% head()\rUse select to show the state names and abbreviations in murders. Do not redefine murders, just show the results.\nThe dplyr function filter is used to choose specific rows of the data frame to keep. Unlike select which is for columns, filter is for rows. For example, you can show just the New York row like this:\r\rfilter(murders, state == \u0026quot;New York\u0026quot;)\rYou can use other logical vectors to filter rows.\nUse filter to show the top 5 states with the highest murder rates. After we add murder rate and rank, do not change the murders dataset, just show the result. Remember that you can filter based on the rank column.\nWe can remove rows using the != operator. For example, to remove Florida, we would do this:\r\rno_florida \u0026lt;- filter(murders, state != \u0026quot;Florida\u0026quot;)\rCreate a new data frame called no_south that removes states from the South region. How many states are in this category? You can use the function nrow for this.\nWe can also use %in% to filter with dplyr. You can therefore see the data from New York and Texas like this:\r\rfilter(murders, state %in% c(\u0026quot;New York\u0026quot;, \u0026quot;Texas\u0026quot;))\rCreate a new data frame called murders_nw with only the states from the Northeast and the West. How many states are in this category?\nSuppose you want to live in the Northeast or West and want the murder rate to be less than 1. We want to see the data for the states satisfying these options. Note that you can use logical operators with filter. Here is an example in which we filter to keep only small states in the Northeast region.\r\rfilter(murders, population \u0026lt; 5000000 \u0026amp; region == \u0026quot;Northeast\u0026quot;)\rMake sure murders has been defined with rate and rank and still has all states. Create a table called my_states that contains rows for states satisfying both the conditions: it is in the Northeast or West and the murder rate is less than 1. Use select to show only the state name, the rate, and the rank.\n\r\r\rThe pipe: %\u0026gt;%\rWith dplyr we can perform a series of operations, for example select and then filter, by sending the results of one function to another using what is called the pipe operator: %\u0026gt;%. Some details are included below.\nWe wrote code above to show three variables (state, region, rate) for states that have murder rates below 0.71. To do this, we defined the intermediate object new_table. In dplyr we can write code that looks more like a description of what we want to do without intermediate objects:\n\\[ \\mbox{original data }\r\\rightarrow \\mbox{ select }\r\\rightarrow \\mbox{ filter } \\]\nFor such an operation, we can use the pipe %\u0026gt;%. The code looks like this:\nmurders %\u0026gt;% select(state, region, rate) %\u0026gt;% filter(rate \u0026lt;= 0.71)\r## state region rate\r## 1 Hawaii West 0.5145920\r## 2 Iowa North Central 0.6893484\r## 3 New Hampshire Northeast 0.3798036\r## 4 North Dakota North Central 0.5947151\r## 5 Vermont Northeast 0.3196211\rThis line of code is equivalent to the two lines of code above. What is going on here?\nIn general, the pipe sends the result of the left side of the pipe to be the first argument of the function on the right side of the pipe. Here is a very simple example:\n16 %\u0026gt;% sqrt()\r## [1] 4\rWe can continue to pipe values along:\n16 %\u0026gt;% sqrt() %\u0026gt;% log2()\r## [1] 2\rThe above statement is equivalent to log2(sqrt(16)).\nRemember that the pipe sends values to the first argument, so we can define other arguments as if the first argument is already defined:\n16 %\u0026gt;% sqrt() %\u0026gt;% log(base = 2)\r## [1] 2\rTherefore, when using the pipe with data frames and dplyr, we no longer need to specify the required first argument since the dplyr functions we have described all take the data as the first argument. In the code we wrote:\nmurders %\u0026gt;% select(state, region, rate) %\u0026gt;% filter(rate \u0026lt;= 0.71)\rmurders is the first argument of the select function, and the new data frame (formerly new_table) is the first argument of the filter function.\nNote that the pipe works well with functions where the first argument is the input data. Functions in tidyverse packages like dplyr have this format and can be used easily with the pipe. It’s worth noting that as of R 4.1, there is a base-R version of the pipe |\u0026gt;, though this has its disadvantages. We’ll stick with %\u0026gt;% for now.\nTRY IT\nThe pipe %\u0026gt;% can be used to perform operations sequentially without having to define intermediate objects. Start by redefining murder to include rate and rank.\r\rmurders \u0026lt;- mutate(murders, rate = total / population * 100000,\rrank = rank(-rate))\rIn the solution to the previous exercise, we did the following:\nmy_states \u0026lt;- filter(murders, region %in% c(\u0026quot;Northeast\u0026quot;, \u0026quot;West\u0026quot;) \u0026amp;\rrate \u0026lt; 1)\rselect(my_states, state, rate, rank)\rThe pipe %\u0026gt;% permits us to perform both operations sequentially without having to define an intermediate variable my_states. We therefore could have mutated and selected in the same line like this:\nmutate(murders, rate = total / population * 100000,\rrank = rank(-rate)) %\u0026gt;%\rselect(state, rate, rank)\rNotice that select no longer has a data frame as the first argument. The first argument is assumed to be the result of the operation conducted right before the %\u0026gt;%.\nRepeat the previous exercise, but now instead of creating a new object, show the result and only include the state, rate, and rank columns. Use a pipe %\u0026gt;% to do this in just one line.\nReset murders to the original table by using data(murders). Use a pipe to create a new data frame called my_states that considers only states in the Northeast or West which have a murder rate lower than 1, and contains only the state, rate and rank columns. The pipe should also have four components separated by three %\u0026gt;%. The code should look something like this:\r\rmy_states \u0026lt;- murders %\u0026gt;%\rmutate SOMETHING %\u0026gt;%\rfilter SOMETHING %\u0026gt;%\rselect SOMETHING\r\r\rSummarizing data\rAn important part of exploratory data analysis is summarizing data. The average and standard deviation are two examples of widely used summary statistics. More informative summaries can often be achieved by first splitting data into groups. In this section, we cover two new dplyr verbs that make these computations easier: summarize and group_by. We learn to access resulting values using the pull function.\nsummarize\rThe summarize function in dplyr provides a way to compute summary statistics with intuitive and readable code. We start with a simple example based on heights. The heights dataset includes heights and sex reported by students in an in-class survey.\nlibrary(dplyr)\rlibrary(dslabs)\rdata(heights)\rThe following code computes the average and standard deviation for females:\ns \u0026lt;- heights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rsummarize(average = mean(height), standard_deviation = sd(height))\rs\r## average standard_deviation\r## 1 64.93942 3.760656\rThis takes our original data table as input, filters it to keep only females, and then produces a new summarized table with just the average and the standard deviation of heights. We get to choose the names of the columns of the resulting table. For example, above we decided to use average and standard_deviation, but we could have used other names just the same.\nBecause the resulting table stored in s is a data frame, we can access the components with the accessor $:\ns$average\r## [1] 64.93942\rs$standard_deviation\r## [1] 3.760656\rAs with most other dplyr functions, summarize is aware of the variable names and we can use them directly. So when inside the call to the summarize function we write mean(height), the function is accessing the column with the name “height” and then computing the average of the resulting numeric vector. We can compute any other summary that operates on vectors and returns a single value. For example, we can add the median, minimum, and maximum heights like this:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rsummarize(median = median(height), minimum = min(height),\rmaximum = max(height))\r## median minimum maximum\r## 1 64.98031 51 79\rWe can obtain these three values with just one line using the quantile function: for example, quantile(x, c(0,0.5,1)) returns the min (0th percentile), median (50th percentile), and max (100th percentile) of the vector x. However, if we attempt to use a function like this that returns two or more values inside summarize:\nheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rsummarize(range = quantile(height, c(0, 0.5, 1)))\rwe will receive an error: Error: expecting result of length one, got : 2. With the function summarize, we can only call functions that return a single value. In later sections, we will learn how to deal with functions that return more than one value.\nFor another example of how we can use the summarize function, let’s compute the average murder rate for the United States. Remember our data table includes total murders and population size for each state and we have already used dplyr to add a murder rate column:\nmurders \u0026lt;- murders %\u0026gt;% mutate(rate = total/population*100000)\rRemember that the US murder rate is not the average of the state murder rates:\nsummarize(murders, mean(rate))\r## mean(rate)\r## 1 2.779125\rThis is because in the computation above the small states are given the same weight as the large ones. The US murder rate is the total number of murders in the US divided by the total US population. So the correct computation is:\nus_murder_rate \u0026lt;- murders %\u0026gt;%\rsummarize(rate = sum(total) / sum(population) * 100000)\rus_murder_rate\r## rate\r## 1 3.034555\rThis computation counts larger states proportionally to their size which results in a larger value.\n\rpull\rThe us_murder_rate object defined above represents just one number. Yet we are storing it in a data frame:\nclass(us_murder_rate)\r## [1] \u0026quot;data.frame\u0026quot;\rsince, as most dplyr functions, summarize always returns a data frame.\nThis might be problematic if we want to use this result with functions that require a numeric value. Here we show a useful trick for accessing values stored in data when using pipes: when a data object is piped that object and its columns can be accessed using the pull function. To understand what we mean take a look at this line of code:\nus_murder_rate %\u0026gt;% pull(rate)\r## [1] 3.034555\rThis returns the value in the rate column of us_murder_rate making it equivalent to us_murder_rate$rate.\nTo get a number from the original data table with one line of code we can type:\nus_murder_rate \u0026lt;- murders %\u0026gt;%\rsummarize(rate = sum(total) / sum(population) * 100000) %\u0026gt;%\rpull(rate)\rus_murder_rate\r## [1] 3.034555\rwhich is now a numeric:\nclass(us_murder_rate)\r## [1] \u0026quot;numeric\u0026quot;\r\rGroup then summarize with group_by\rA common operation in data exploration is to first split data into groups and then compute summaries for each group. For example, we may want to compute the average and standard deviation for men’s and women’s heights separately. The group_by function helps us do this.\nIf we type this:\nheights %\u0026gt;% group_by(sex)\r## # A tibble: 1,050 × 2\r## # Groups: sex [2]\r## sex height\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Male 75\r## 2 Male 70\r## 3 Male 68\r## 4 Male 74\r## 5 Male 61\r## 6 Female 65\r## 7 Female 66\r## 8 Female 62\r## 9 Female 66\r## 10 Male 67\r## # … with 1,040 more rows\rThe result does not look very different from heights, except we see Groups: sex [2] when we print the object. Although not immediately obvious from its appearance, this is now a special data frame called a grouped data frame, and dplyr functions, in particular summarize, will behave differently when acting on this object. Conceptually, you can think of this table as many tables, with the same columns but not necessarily the same number of rows, stacked together in one object. When we summarize the data after grouping, this is what happens:\nheights %\u0026gt;%\rgroup_by(sex) %\u0026gt;%\rsummarize(average = mean(height), standard_deviation = sd(height))\r## # A tibble: 2 × 3\r## sex average standard_deviation\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Female 64.9 3.76\r## 2 Male 69.3 3.61\rThe summarize function applies the summarization to each group separately.\nFor another example, let’s compute the median murder rate in the four regions of the country:\nmurders %\u0026gt;%\rgroup_by(region) %\u0026gt;%\rsummarize(median_rate = median(rate))\r## # A tibble: 4 × 2\r## region median_rate\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Northeast 1.80\r## 2 South 3.40\r## 3 North Central 1.97\r## 4 West 1.29\r\r\rSorting data frames\rWhen examining a dataset, it is often convenient to sort the table by the different columns. We know about the order and sort function, but for ordering entire tables, the dplyr function arrange is useful. For example, here we order the states by population size:\nmurders %\u0026gt;%\rarrange(population) %\u0026gt;%\rhead()\r## state abb region population total rate\r## 1 Wyoming WY West 563626 5 0.8871131\r## 2 District of Columbia DC South 601723 99 16.4527532\r## 3 Vermont VT Northeast 625741 2 0.3196211\r## 4 North Dakota ND North Central 672591 4 0.5947151\r## 5 Alaska AK West 710231 19 2.6751860\r## 6 South Dakota SD North Central 814180 8 0.9825837\rWith arrange we get to decide which column to sort by. To see the states by murder rate, from lowest to highest, we arrange by rate instead:\nmurders %\u0026gt;%\rarrange(rate) %\u0026gt;%\rhead()\r## state abb region population total rate\r## 1 Vermont VT Northeast 625741 2 0.3196211\r## 2 New Hampshire NH Northeast 1316470 5 0.3798036\r## 3 Hawaii HI West 1360301 7 0.5145920\r## 4 North Dakota ND North Central 672591 4 0.5947151\r## 5 Iowa IA North Central 3046355 21 0.6893484\r## 6 Idaho ID West 1567582 12 0.7655102\rNote that the default behavior is to order in ascending order. In dplyr, the function desc transforms a vector so that it is in descending order. To sort the table in descending order, we can type:\nmurders %\u0026gt;%\rarrange(desc(rate))\rNested sorting\rIf we are ordering by a column with ties, we can use a second column to break the tie. Similarly, a third column can be used to break ties between first and second and so on. Here we order by region, then within region we order by murder rate:\nmurders %\u0026gt;%\rarrange(region, rate) %\u0026gt;%\rhead()\r## state abb region population total rate\r## 1 Vermont VT Northeast 625741 2 0.3196211\r## 2 New Hampshire NH Northeast 1316470 5 0.3798036\r## 3 Maine ME Northeast 1328361 11 0.8280881\r## 4 Rhode Island RI Northeast 1052567 16 1.5200933\r## 5 Massachusetts MA Northeast 6547629 118 1.8021791\r## 6 New York NY Northeast 19378102 517 2.6679599\r\rThe top \\(n\\)\rIn the code above, we have used the function head to avoid having the page fill up with the entire dataset. If we want to see a larger proportion, we can use the top_n function. This function takes a data frame as it’s first argument, the number of rows to show in the second, and the variable to filter by in the third. Here is an example of how to see the top 5 rows:\nmurders %\u0026gt;% top_n(5, rate)\r## state abb region population total rate\r## 1 District of Columbia DC South 601723 99 16.452753\r## 2 Louisiana LA South 4533372 351 7.742581\r## 3 Maryland MD South 5773552 293 5.074866\r## 4 Missouri MO North Central 5988927 321 5.359892\r## 5 South Carolina SC South 4625364 207 4.475323\rNote that rows are not sorted by rate, only filtered. If we want to sort, we need to use arrange.\rNote that if the third argument is left blank, top_n filters by the last column.\nTRY IT\nFor these exercises, we will be using the data from the survey collected by the United States National Center for Health Statistics (NCHS). This center has conducted a series of health and nutrition surveys since the 1960’s. Starting in 1999, about 5,000 individuals of all ages have been interviewed every year and they complete the health examination component of the survey. Part of the data is made available via the NHANES package. Once you install the NHANES package, you can load the data like this:\nlibrary(NHANES)\rdata(NHANES)\rThe NHANES data has many missing values. The mean and sd functions in R will return NA if any of the entries of the input vector is an NA. Here is an example:\nlibrary(dslabs)\rdata(na_example)\rmean(na_example)\r## [1] NA\rsd(na_example)\r## [1] NA\rTo ignore the NAs we can use the na.rm argument:\nmean(na_example, na.rm = TRUE)\r## [1] 2.301754\rsd(na_example, na.rm = TRUE)\r## [1] 1.22338\rLet’s now explore the NHANES data.\nWe will provide some basic facts about blood pressure. First let’s select a group to set the standard. We will use 20-to-29-year-old females. AgeDecade is a categorical variable with these ages. Note that the category is coded like ” 20-29”, with a space in front! What is the average and standard deviation of systolic blood pressure as saved in the BPSysAve variable? Save it to a variable called ref.\r\rHint: Use filter and summarize and use the na.rm = TRUE argument when computing the average and standard deviation. You can also filter the NA values using filter.\nUsing a pipe, assign the average to a numeric variable ref_avg. Hint: Use the code similar to above and then pull.\n\rNow report the min and max values for the same group.\n\rCompute the average and standard deviation for females, but for each age group separately rather than a selected decade as in question 1. Note that the age groups are defined by AgeDecade. Hint: rather than filtering by age and gender, filter by Gender and then use group_by.\n\rRepeat exercise 4 for males.\n\rWe can actually combine both summaries for exercises 4 and 5 into one line of code. This is because group_by permits us to group by more than one variable. Obtain one big summary table using group_by(AgeDecade, Gender).\n\rFor males between the ages of 40-49, compare systolic blood pressure across race as reported in the Race1 variable. Order the resulting table from lowest to highest average systolic blood pressure.\n\r\r\r\r\rTibbles\rTidy data must be stored in data frames. We introduced the data frame in Section ?? and have been using the murders data frame throughout the book. In Section ?? we introduced the group_by function, which permits stratifying data before computing summary statistics. But where is the group information stored in the data frame?\nmurders %\u0026gt;% group_by(region)\r## # A tibble: 51 × 6\r## # Groups: region [4]\r## state abb region population total rate\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Alabama AL South 4779736 135 2.82\r## 2 Alaska AK West 710231 19 2.68\r## 3 Arizona AZ West 6392017 232 3.63\r## 4 Arkansas AR South 2915918 93 3.19\r## 5 California CA West 37253956 1257 3.37\r## 6 Colorado CO West 5029196 65 1.29\r## 7 Connecticut CT Northeast 3574097 97 2.71\r## 8 Delaware DE South 897934 38 4.23\r## 9 District of Columbia DC South 601723 99 16.5 ## 10 Florida FL South 19687653 669 3.40\r## # … with 41 more rows\rNotice that there are no columns with this information. But, if you look closely at the output above, you see the line A tibble followd by dimensions. We can learn the class of the returned object using:\nmurders %\u0026gt;% group_by(region) %\u0026gt;% class()\r## [1] \u0026quot;grouped_df\u0026quot; \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\rThe tbl, pronounced tibble, is a special kind of data frame. The functions group_by and summarize always return this type of data frame. The group_by function returns a special kind of tbl, the grouped_df. We will say more about these later. For consistency, the dplyr manipulation verbs (select, filter, mutate, and arrange) preserve the class of the input: if they receive a regular data frame they return a regular data frame, while if they receive a tibble they return a tibble. But tibbles are the preferred format in the tidyverse and as a result tidyverse functions that produce a data frame from scratch return a tibble. For example, in Chapter ?? we will see that tidyverse functions used to import data create tibbles.\nTibbles are very similar to data frames. In fact, you can think of them as a modern version of data frames. Nonetheless there are three important differences which we describe next.\nTibbles display better\rThe print method for tibbles is more readable than that of a data frame. To see this, compare the outputs of typing murders and the output of murders if we convert it to a tibble. We can do this using as_tibble(murders). If using RStudio, output for a tibble adjusts to your window size. To see this, change the width of your R console and notice how more/less columns are shown.\n\rSubsets of tibbles are tibbles\rIf you subset the columns of a data frame, you may get back an object that is not a data frame, such as a vector or scalar. For example:\nclass(murders[,4])\r## [1] \u0026quot;numeric\u0026quot;\ris not a data frame. With tibbles this does not happen:\nclass(as_tibble(murders)[,4])\r## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\rThis is useful in the tidyverse since functions require data frames as input.\nWith tibbles, if you want to access the vector that defines a column, and not get back a data frame, you need to use the accessor $:\nclass(as_tibble(murders)$population)\r## [1] \u0026quot;numeric\u0026quot;\rA related feature is that tibbles will give you a warning if you try to access a column that does not exist. If we accidentally write Population instead of population this:\nmurders$Population\r## NULL\rreturns a NULL with no warning, which can make it harder to debug. In contrast, if we try this with a tibble we get an informative warning:\nas_tibble(murders)$Population\r## Warning: Unknown or uninitialised column: `Population`.\r## NULL\r\rTibbles can have complex entries\rWhile data frame columns need to be vectors of numbers, strings, or logical values, tibbles can have more complex objects, such as lists or functions. Also, we can create tibbles with functions:\ntibble(id = c(1, 2, 3), func = c(mean, median, sd))\r## # A tibble: 3 × 2\r## id func ## \u0026lt;dbl\u0026gt; \u0026lt;list\u0026gt;\r## 1 1 \u0026lt;fn\u0026gt; ## 2 2 \u0026lt;fn\u0026gt; ## 3 3 \u0026lt;fn\u0026gt;\r\rTibbles can be grouped\rThe function group_by returns a special kind of tibble: a grouped tibble. This class stores information that lets you know which rows are in which groups. The tidyverse functions, in particular the summarize function, are aware of the group information.\n\rCreate a tibble using tibble instead of data.frame\rIt is sometimes useful for us to create our own data frames. To create a data frame in the tibble format, you can do this by using the tibble function.\ngrades \u0026lt;- tibble(names = c(\u0026quot;John\u0026quot;, \u0026quot;Juan\u0026quot;, \u0026quot;Jean\u0026quot;, \u0026quot;Yao\u0026quot;),\rexam_1 = c(95, 80, 90, 85),\rexam_2 = c(90, 85, 85, 90))\rNote that base R (without packages loaded) has a function with a very similar name, data.frame, that can be used to create a regular data frame rather than a tibble. One other important difference is that by default data.frame coerces characters into factors without providing a warning or message:\ngrades \u0026lt;- data.frame(names = c(\u0026quot;John\u0026quot;, \u0026quot;Juan\u0026quot;, \u0026quot;Jean\u0026quot;, \u0026quot;Yao\u0026quot;),\rexam_1 = c(95, 80, 90, 85),\rexam_2 = c(90, 85, 85, 90))\rclass(grades$names)\r## [1] \u0026quot;character\u0026quot;\rTo avoid this, we use the rather cumbersome argument stringsAsFactors:\ngrades \u0026lt;- data.frame(names = c(\u0026quot;John\u0026quot;, \u0026quot;Juan\u0026quot;, \u0026quot;Jean\u0026quot;, \u0026quot;Yao\u0026quot;),\rexam_1 = c(95, 80, 90, 85),\rexam_2 = c(90, 85, 85, 90),\rstringsAsFactors = FALSE)\rclass(grades$names)\r## [1] \u0026quot;character\u0026quot;\rTo convert a regular data frame to a tibble, you can use the as_tibble function.\nas_tibble(grades) %\u0026gt;% class()\r## [1] \u0026quot;tbl_df\u0026quot; \u0026quot;tbl\u0026quot; \u0026quot;data.frame\u0026quot;\r\r\rThe dot operator\rOne of the advantages of using the pipe %\u0026gt;% is that we do not have to keep naming new objects as we manipulate the data frame. As a quick reminder, if we want to compute the median murder rate for states in the southern states, instead of typing:\ntab_1 \u0026lt;- filter(murders, region == \u0026quot;South\u0026quot;)\rtab_2 \u0026lt;- mutate(tab_1, rate = total / population * 10^5)\rrates \u0026lt;- tab_2$rate\rmedian(rates)\r## [1] 3.398069\rWe can avoid defining any new intermediate objects by instead typing:\nfilter(murders, region == \u0026quot;South\u0026quot;) %\u0026gt;%\rmutate(rate = total / population * 10^5) %\u0026gt;%\rsummarize(median = median(rate)) %\u0026gt;%\rpull(median)\r## [1] 3.398069\rWe can do this because each of these functions takes a data frame as the first argument. But what if we want to access a component of the data frame. For example, what if the pull function was not available and we wanted to access tab_2$rate? What data frame name would we use? The answer is the dot operator.\nFor example to access the rate vector without the pull function we could use\nrates \u0026lt;- filter(murders, region == \u0026quot;South\u0026quot;) %\u0026gt;%\rmutate(rate = total / population * 10^5) %\u0026gt;%\r.$rate\rmedian(rates)\r## [1] 3.398069\rIn the next section, we will see other instances in which using the . is useful.\n\rdo\rThe tidyverse functions know how to interpret grouped tibbles. Furthermore, to facilitate stringing commands through the pipe %\u0026gt;%, tidyverse functions consistently return data frames, since this assures that the output of a function is accepted as the input of another. But most R functions do not recognize grouped tibbles nor do they return data frames. The quantile function is an example we described earlier. The do function serves as a bridge between R functions such as quantile and the tidyverse. The do function understands grouped tibbles and always returns a data frame.\nIn the summarize section (above), we noted that if we attempt to use quantile to obtain the min, median and max in one call, we will receive an error: Error: expecting result of length one, got : 2.\ndata(heights)\rheights %\u0026gt;%\rfilter(sex == \u0026quot;Female\u0026quot;) %\u0026gt;%\rsummarize(range = quantile(height, c(0, 0.5, 1)))\rWe can use the do function to fix this.\nFirst we have to write a function that fits into the tidyverse approach: that is, it receives a data frame and returns a data frame. Note that it returns a single-row data frame.\nmy_summary \u0026lt;- function(dat){\rx \u0026lt;- quantile(dat$height, c(0, 0.5, 1))\rtibble(min = x[1], median = x[2], max = x[3])\r}\rWe can now apply the function to the heights dataset to obtain the summaries:\nheights %\u0026gt;%\rgroup_by(sex) %\u0026gt;%\rmy_summary\r## # A tibble: 1 × 3\r## min median max\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 50 68.5 82.7\rBut this is not what we want. We want a summary for each sex and the code returned just one summary. This is because my_summary is not part of the tidyverse and does not know how to handled grouped tibbles. do makes this connection:\nheights %\u0026gt;%\rgroup_by(sex) %\u0026gt;%\rdo(my_summary(.))\r## # A tibble: 2 × 4\r## # Groups: sex [2]\r## sex min median max\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Female 51 65.0 79 ## 2 Male 50 69 82.7\rNote that here we need to use the dot operator. The tibble created by group_by is piped to do. Within the call to do, the name of this tibble is . and we want to send it to my_summary. If you do not use the dot, then my_summary has no argument and returns an error telling us that argument \"dat\" is missing. You can see the error by typing:\nheights %\u0026gt;%\rgroup_by(sex) %\u0026gt;%\rdo(my_summary())\rIf you do not use the parenthesis, then the function is not executed and instead do tries to return the function. This gives an error because do must always return a data frame. You can see the error by typing:\nheights %\u0026gt;%\rgroup_by(sex) %\u0026gt;%\rdo(my_summary)\r\rThe purrr package\rIn previous sections (and labs) we learned about the sapply function, which permitted us to apply the same function to each element of a vector. We constructed a function and used sapply to compute the sum of the first n integers for several values of n like this:\ncompute_s_n \u0026lt;- function(n){\rx \u0026lt;- 1:n\rsum(x)\r}\rn \u0026lt;- 1:25\rs_n \u0026lt;- sapply(n, compute_s_n)\rs_n\r## [1] 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190\r## [20] 210 231 253 276 300 325\rThis type of operation, applying the same function or procedure to elements of an object, is quite common in data analysis. The purrr package includes functions similar to sapply but that better interact with other tidyverse functions. The main advantage is that we can better control the output type of functions. In contrast, sapply can return several different object types; for example, we might expect a numeric result from a line of code, but sapply might convert our result to character under some circumstances. purrr functions will never do this: they will return objects of a specified type or return an error if this is not possible.\nThe first purrr function we will learn is map, which works very similar to sapply but always, without exception, returns a list:\nlibrary(purrr) # or library(tidyverse)\rn \u0026lt;- 1:25\rs_n \u0026lt;- map(n, compute_s_n)\rclass(s_n)\r## [1] \u0026quot;list\u0026quot;\rIf we want a numeric vector, we can instead use map_dbl which always returns a vector of numeric values.\ns_n \u0026lt;- map_dbl(n, compute_s_n)\rclass(s_n)\r## [1] \u0026quot;numeric\u0026quot;\rThis produces the same results as the sapply call shown above.\nA particularly useful purrr function for interacting with the rest of the tidyverse is map_df, which always returns a tibble data frame. However, the function being called needs to return a vector or a list with names. For this reason, the following code would result in a Argument 1 must have names error:\ns_n \u0026lt;- map_df(n, compute_s_n)\rWe need to change the function to make this work:\ncompute_s_n \u0026lt;- function(n){\rx \u0026lt;- 1:n\rtibble(sum = sum(x))\r}\rs_n \u0026lt;- map_df(n, compute_s_n)\rhead(s_n)\r## # A tibble: 6 × 1\r## sum\r## \u0026lt;int\u0026gt;\r## 1 1\r## 2 3\r## 3 6\r## 4 10\r## 5 15\r## 6 21\rThe purrr package provides much more functionality not covered here. For more details you can consult this online resource.\n\rTidyverse conditionals\rA typical data analysis will often involve one or more conditional operations. In the section on Conditionals, we described the ifelse function, which we will use extensively in this book. In this section we present two dplyr functions that provide further functionality for performing conditional operations.\ncase_when\rThe case_when function is useful for vectorizing conditional statements. It is similar to ifelse but can output any number of values, as opposed to just TRUE or FALSE. Here is an example splitting numbers into negative, positive, and 0:\nx \u0026lt;- c(-2, -1, 0, 1, 2)\rcase_when(x \u0026lt; 0 ~ \u0026quot;Negative\u0026quot;,\rx \u0026gt; 0 ~ \u0026quot;Positive\u0026quot;,\rx == 0 ~ \u0026quot;Zero\u0026quot;)\r## [1] \u0026quot;Negative\u0026quot; \u0026quot;Negative\u0026quot; \u0026quot;Zero\u0026quot; \u0026quot;Positive\u0026quot; \u0026quot;Positive\u0026quot;\rA common use for this function is to define categorical variables based on existing variables. For example, suppose we want to compare the murder rates in four groups of states: New England, West Coast, South, and other. For each state, we need to ask if it is in New England, if it is not we ask if it is in the West Coast, if not we ask if it is in the South, and if not we assign other. Here is how we use case_when to do this:\nmurders %\u0026gt;%\rmutate(group = case_when(\rabb %in% c(\u0026quot;ME\u0026quot;, \u0026quot;NH\u0026quot;, \u0026quot;VT\u0026quot;, \u0026quot;MA\u0026quot;, \u0026quot;RI\u0026quot;, \u0026quot;CT\u0026quot;) ~ \u0026quot;New England\u0026quot;,\rabb %in% c(\u0026quot;WA\u0026quot;, \u0026quot;OR\u0026quot;, \u0026quot;CA\u0026quot;) ~ \u0026quot;West Coast\u0026quot;,\rregion == \u0026quot;South\u0026quot; ~ \u0026quot;South\u0026quot;,\rTRUE ~ \u0026quot;Other\u0026quot;)) %\u0026gt;%\rgroup_by(group) %\u0026gt;%\rsummarize(rate = sum(total) / sum(population) * 10^5)\r## # A tibble: 4 × 2\r## group rate\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 New England 1.72\r## 2 Other 2.71\r## 3 South 3.63\r## 4 West Coast 2.90\r\rbetween\rA common operation in data analysis is to determine if a value falls inside an interval. We can check this using conditionals. For example, to check if the elements of a vector x are between a and b we can type\nx \u0026gt;= a \u0026amp; x \u0026lt;= b\rHowever, this can become cumbersome, especially within the tidyverse approach. The between function performs the same operation.\nbetween(x, a, b)\rTRY IT\nLoad the murders dataset. Which of the following is true?\r\rmurders is in tidy format and is stored in a tibble.\rmurders is in tidy format and is stored in a data frame.\rmurders is not in tidy format and is stored in a tibble.\rmurders is not in tidy format and is stored in a data frame.\r\rUse as_tibble to convert the murders data table into a tibble and save it in an object called murders_tibble.\n\rUse the group_by function to convert murders into a tibble that is grouped by region.\n\rWrite tidyverse code that is equivalent to this code:\n\r\rexp(mean(log(murders$population)))\rWrite it using the pipe so that each function is called without arguments. Use the dot operator to access the population. Hint: The code should start with murders %\u0026gt;%.\nUse the map_df to create a data frame with three columns named n, s_n, and s_n_2. The first column should contain the numbers 1 through 100. The second and third columns should each contain the sum of 1 through \\(n\\) with \\(n\\) the row number.\r\r\r  ```\r--\r\r\r\r\rI discovered the emo::ji() function at 8:55am. My wife joked that I would find a way to use the poop emoji by 9:00am. It is now 8:59am. She was right.↩︎\n\rIf you have not installed this package already, you must use install.packages(\"tidyverse\") prior to the library() call you see below.↩︎\n\r\r\r","date":1661731200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661815238,"objectID":"fbbae951c935dd3d35f82710943d5efd","permalink":"https://ssc442kirkpatrick.netlify.app/content/01-content/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/content/01-content/","section":"content","summary":"Readings\r\rGuiding Question\r\rGroup Projects\r\rTeams\r\rRandomness and Data Analytics\r\rLearning From Data\rFormalization\rThe Target Function\rWhy Estimate an Unknown Function?\rThe Parable of the Marbles\rOutside the Data\rHoeffding’s Inequality\rAn example of Hoeffding’s Inequality\r\rThe tidyverse\r\rTidy data\rManipulating data frames\r\rAdding a column with mutate\rSubsetting with filter\rSelecting columns with select\r\rThe pipe: %\u0026gt;%\rSummarizing data\r\rsummarize\rpull\rGroup then summarize with group_by\r\rSorting data frames\r\rNested sorting\rThe top \\(n\\)\r\rTibbles\r\rTibbles display better\rSubsets of tibbles are tibbles\rTibbles can have complex entries\rTibbles can be grouped\rCreate a tibble using tibble instead of data.","tags":null,"title":"Introduction to the tidyverse","type":"docs"},{"authors":null,"categories":null,"content":"\r\rReadings\r\rGuiding Questions\rStarting up\r\rScales and transformations\r\rLog transformations\rTransforming data vs. transforming using scale_...\r\rAxis labels, legends, and titles\r\rChanging axis titles\rTitles\r\rAxis ticks\rAdditional geometries\r\rgeom_line\rUsing different data with different geometries\rMultiple geometries\r\rTry it!\r\r\rReadings\r\rThis page.\r\rGuiding Questions\r\rNo guiding questions today as we’re mostly learning some technical aspects of ggplot\rWe have largely reversed our content and example lectures for data viz.\r\r\rStarting up\rLoad up our murders data\nlibrary(dslabs)\rlibrary(ggplot2)\rlibrary(dplyr)\rdata(murders)\rp \u0026lt;- ggplot(data = murders, aes(x = population, y = total, label = abb))\r\r\rScales and transformations\rLog transformations\rLast lecture, we re-scaled our population by 10^6 (millions), but still had a lot of variation because some states are tiny and some are huge. Sometimes, we want to have one (or both) of our axes scaled non-linearly. For instance, if we wanted to have our x-axis be in log base 10, then each major tick would represent a factor of 10 over the last. This is not the default, so this change needs to be added through a scales layer. A quick look at the cheat sheet reveals the scale_x_continuous function lets us control the behavior of scales. We use them like this:\np + geom_point(size = 3) +\rgeom_text(nudge_x = 0.05) +\rscale_x_continuous(trans = \u0026quot;log10\u0026quot;) +\rscale_y_continuous(trans = \u0026quot;log10\u0026quot;)\rA couple of things here: adding things like scale_x_continuous(...) operates on the whole plot. In some cases, order matters, but it doesn’t here, so we can throw scale_x_continuous anywhere. Because we have altered the whole plot’s scale to be in the log-scale now, the nudge must be made smaller. It is in log-base-10 units. Using ?scale_x_continuous brings us to the help for both scale_x_continuous and scale_y_continuous, which shows us the options for transformations trans = ...\nThis particular transformation is so common that ggplot2 provides the specialized functions scale_x_log10 and scale_y_log10 which “inherit” (take the place of) the scale_x_continuous functions but have log base 10 as default. We can use these to rewrite the code like this:\np + geom_point(size = 3) +\rgeom_text(nudge_x = 0.05) +\rscale_x_log10() +\rscale_y_log10()\rThis can make a plot much easier to read, though one has to be sure to pay attention to the values on the axes. Plotting anything with very large outliers will almost always be better if done in log-scale. Adding the scale layer is an easy way to fix this.\nWe can also use one of many built-in transformations. Of note: reverse just inverts the scale, which can be helpful, log uses the natural log, sqrt takes the square root (dropping anything with a negative value), reciprocal takes 1/x. If your x-axis is in a date format, you can also scale to hms (hour-minute-second) or date.\n\rTransforming data vs. transforming using scale_...\rWe could simply take the log of population and log of total in the call and we’d get something very similar. Note that we had to override the aesthetic mapping set in p in each of the geometries:\np + geom_point(aes(x = log(population, base=10), y = log(total, base=10)), size = 3) +\rgeom_text(aes(x = log(population, base=10), y = log(total, base=10)), nudge_x = 0.05) \rThis avoids using scale_x_continuous or it’s child function scale_x_log10. One advantage to using scale_x... is that the axes are correctly labeled. When we transform the data directly, the axis labels only show the transformed values, so 7,000,000 becomes 7.0. This could be confusing! We could update the axis labels to say “total murders (log base 10)” and “total population (log base 10)”, but that’s cumbersome. Using scale_x... is a lot more refined and easy.\n\r\rAxis labels, legends, and titles\rBut let’s say we did want to re-name our x-axis label. Or maybe we don’t like that the variable column name is lower-case “p”.\nAs with many things in ggplot, there are many ways to get the same result. We’ll go over one way of changing titles and labels, but know that there are many more.\nChanging axis titles\rWe’ll use the labs(...) annotation layer to do this, which is pretty straightforward. ?labs shows us what we can change, and while it looks pretty basic, the real meat is in the ... argument, which the help says is “A list of new name-value pairs”. This means we can re-define the label on anything that is an aesthetic mapping. X and Y are aesthetic mappings, so…\np + geom_point(size = 3) +\rgeom_text(nudge_x = 0.05) +\rscale_x_log10() +\rscale_y_log10() + labs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;)\rNow, let’s use an aesthetic mapping that generates a legend, like color, and see what labs renames:\np + geom_point(aes(color = region), size = 3) +\rgeom_text(nudge_x = 0.05) +\rscale_x_log10() +\rscale_y_log10() + labs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;)\rWe can rename the aesthetic mapping-relevant label using labs. Even if there are multiple mapped aesthetics:\np + geom_point(aes(color = region, size = total/population)) +\rgeom_text(nudge_x = 0.05) +\rscale_x_log10() +\rscale_y_log10() + labs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;, size = \u0026#39;Murder rate\u0026#39;)\r\rTitles\rIn ?labs, we also see some things that look like titles and captions. We can include those:\np + geom_point(aes(color = region, size = total/population)) +\rgeom_text(nudge_x = 0.05) +\rscale_x_log10() +\rscale_y_log10() + labs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;, size = \u0026#39;Murder rate\u0026#39;,\rtitle = \u0026#39;This is a title\u0026#39;, subtitle = \u0026#39;This is a subtitle\u0026#39;, caption = \u0026#39;This is a caption\u0026#39;, tag = \u0026#39;This is a tag\u0026#39;)\rNow that you know how, always label your plots with at least a title and have meaningful axis and legend labels.\n\r\rAxis ticks\rIn addition to the axis labels, we may want to format or change the axis tick labels (like “1e+06” above) or even where the tick marks and lines are drawn. If we don’t specify anything, the axis labels and tick marks are drawn as best as ggplot can do, but we can change this. This might be especially useful if our data has some meaningful cutoffs that aren’t found by the default, or we just don’t like where the marks fall or how they are labeled. This is easy to fix with ggplot.\nTo change the tick mark labels, we have to set the tick mark locations. Then we can set a label for each tick mark. Let’s go back to our murders data and, for simplicity, take the log transformation off the Y axis. We’ll use scale_y_continuous to tell R where to put the breaks (breaks =) and what to label the breaks. We have to give it one label for every break. Let’s say we just want a line at the 500’s and let’s say we want to (absurdly) use written numerics for each of the Y-axis lines. Since scale_y_log10 inherits from scale_y_continuous, we can just use that and add the breaks and labels:\np + geom_point(aes(color = region), size = 3) +\rgeom_text(nudge_x = .05) +\rscale_x_log10() +\rscale_y_log10(breaks = c(0,50, 100, 500,1000,1500), labels = c(\u0026#39;Zero\u0026#39;,\u0026#39;Fifty\u0026#39;,\u0026#39;One hundred\u0026#39;,\u0026#39;Five hundred\u0026#39;,\u0026#39;One thousand\u0026#39;,\u0026#39;Fifteen hundred\u0026#39;)) +\rlabs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;)\rWe have manually set both the location and the label for the y-axis. Note that R filled in the in-between “minor” tick lines, but we can take those out. Since we are setting the location of the lines, we can do anything we want:\np + geom_point(aes(color = region), size = 3) +\rgeom_text(nudge_x = .05) +\rscale_x_log10() +\rscale_y_log10(breaks = c(0,50, 100, 721, 1000,1500), labels = c(\u0026#39;Zero\u0026#39;,\u0026#39;Fifty\u0026#39;,\u0026#39;One hundred\u0026#39;,\u0026#39;Seven hundred twenty one\u0026#39;,\u0026#39;One thousand\u0026#39;,\u0026#39;Fifteen hundred\u0026#39;),\rminor_breaks = NULL) +\rlabs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;)\rSo we can now define where axis tick lines should lie and how they should be labeled.\n\rAdditional geometries\rLet’s say we are happy with our axis tick locations, but we want to add a single additional line. Maybe we want to divide at 1,000,000 population (a vertical line at 1,000,000) becuase we think those over 1,000,000 are somehow different, and we want to call attention to the data around that point. As a more general example, if we were to plot, say, car accidents by age, we would maybe want to label age 21, when people can legally purchase alcohol (and subsequently cause car accidents).\nThis brings us to our first additional geometry beyond geom_point (OK, we used geom_text, but that’s more of an annotation). geom_vline lets us add a single vertical line (without aesthetic mappings). If we look at ?geom_vline we see that it requires ones aesthetic:xintercept. It also takes aesthetics like color and size, and introduces the linetype aesthetic:\np + geom_point(aes(color = region), size = 3) +\rgeom_text(nudge_x = .05) +\rgeom_vline(aes(xintercept = 1000000), col = \u0026#39;red\u0026#39;, size = 2, linetype = 2) +\rscale_x_log10() +\rscale_y_log10(breaks = c(0,50, 100, 721, 1000,1500), labels = c(\u0026#39;Zero\u0026#39;,\u0026#39;Fifty\u0026#39;,\u0026#39;One hundred\u0026#39;,\u0026#39;Seven hundred twenty one\u0026#39;,\u0026#39;One thousand\u0026#39;,\u0026#39;Fifteen hundred\u0026#39;),\rminor_breaks = NULL) +\rlabs(x = \u0026#39;Population\u0026#39;, y = \u0026#39;Total murders\u0026#39;, color = \u0026#39;US Region\u0026#39;)\rCombining geometries is as easy as adding the layers with +.\ngeom_line\rFor a good old line plot, we use the line geometry at geom_line. The help for ?geom_line tells us that we need an x and a y aesthetic (much like geom_points). Since our murders data isn’t really suited to a line graph, we’ll use a daily stock price. We’ll get this using tidyquant, which pulls stock prices from Yahoo Finance and maintains the “tidy” format. You’ll need to install.packages('tidyquant') before you run this the first time.\nlibrary(tidyquant)\rAAPL = tq_get(\u0026quot;AAPL\u0026quot;, from = \u0026#39;2009-01-01\u0026#39;, to = \u0026#39;2021-08-01\u0026#39;, get = \u0026#39;stock.prices\u0026#39;)\rhead(AAPL)\r## # A tibble: 6 × 8\r## symbol date open high low close volume adjusted\r## \u0026lt;chr\u0026gt; \u0026lt;date\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 AAPL 2009-01-02 3.07 3.25 3.04 3.24 746015200 2.77\r## 2 AAPL 2009-01-05 3.33 3.44 3.31 3.38 1181608400 2.88\r## 3 AAPL 2009-01-06 3.43 3.47 3.30 3.32 1289310400 2.84\r## 4 AAPL 2009-01-07 3.28 3.30 3.22 3.25 753048800 2.78\r## 5 AAPL 2009-01-08 3.23 3.33 3.22 3.31 673500800 2.83\r## 6 AAPL 2009-01-09 3.33 3.34 3.22 3.24 546845600 2.76\rNow, we can plot a line graph of the Apple closing stock price over the requested date range. We want this to be a time series, so the x-axis will be the date and the y-axis will be the closing price.\nggplot(AAPL, aes(x = date, y = close)) +\rgeom_line() +\rlabs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple stock price\u0026#39;)\rIn geom_line, R will automatically sort on the x-variable. If you don’t want this, then geom_path will use whatever order the data is in. Either way, if you have multiple observations for the same value on the x-axis, then you’ll get something pretty messy because R will try to connect, in some order, all the points. Let’s see an example with two stocks:\nAAPLNFLX = tq_get(c(\u0026quot;AAPL\u0026quot;,\u0026quot;NFLX\u0026quot;), from = \u0026#39;2021-01-01\u0026#39;, to = \u0026#39;2021-08-01\u0026#39;, get = \u0026#39;stock.prices\u0026#39;)\rggplot(AAPLNFLX, aes(x = date, y = close)) +\rgeom_line() +\rlabs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\rThat looks kinda strange. That’s because, for every date, we have two values - the NFLX and the AAPL value, so each day has a vertical line drawn between the two prices. This is nonsense, especially since what we want to see is the history of NFLX and AAPL over time.\nAesthetics to the rescue! Remember, when we use an aesthetic mapping, we are able to separate out data by things like color or linetype. Let’s use color as the aesthetic here, and map it to the stock ticker:\nAAPLNFLX = tq_get(c(\u0026quot;AAPL\u0026quot;,\u0026quot;NFLX\u0026quot;), from = \u0026#39;2021-01-01\u0026#39;, to = \u0026#39;2021-08-01\u0026#39;, get = \u0026#39;stock.prices\u0026#39;)\rggplot(AAPLNFLX, aes(x = date, y = close, color = symbol)) +\rgeom_line() +\rlabs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\rWell there we go! We can now see each stock price over time, with a convenient legend. Later on, we’ll learn how to change the color palatte. If we don’t necessarily want a different color but we do want to separate the lines, we can use the group aesthetic.\nAAPLNFLX = tq_get(c(\u0026quot;AAPL\u0026quot;,\u0026quot;NFLX\u0026quot;), from = \u0026#39;2021-01-01\u0026#39;, to = \u0026#39;2021-08-01\u0026#39;, get = \u0026#39;stock.prices\u0026#39;)\rggplot(AAPLNFLX, aes(x = date, y = close, group = symbol)) +\rgeom_line() + labs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\rSimilar result as geom_line, but without the color difference (which makes it rather hard to tell what you’re looking at). But if we add labels using geom_label, we’ll get one label for every point, which will be overwhelming. The solution? Use some filtered data so that there is only one point for each label. But that means replacing the data in ggplot. Here’s how.\n\rUsing different data with different geometries\rJust as we can use different aesthetic mappings on each geometry, we can use different data entirely. This is useful when we want one geometry to have one set of data (like the stock prices above), but another geometry to only have a subset of the data. Why would we want that? Well, we’d like to label just one part of each of the lines in our plot, right? That means we want to label a subset of the stock data.\nTo replace data in a geometry, we just need to specify the data = argument separately:\nggplot(AAPLNFLX, aes(x = date, y = close, group = symbol)) +\rgeom_line() +\rgeom_label(data = AAPLNFLX %\u0026gt;% group_by(symbol) %\u0026gt;% slice(100),\raes(label = symbol),\rnudge_y = 20) + labs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\rIn geom_label, we specified we wanted the 100th observation from each symbol to be the label location. Then, we nudged it up along y by 20 so that it’s clear of the line.\nR also has a very useful ggrepel package that gives us geom_label_repel which takes care of the nudging for us, even in complicated situations (lots of points, lines, etc.). It does a decent job here of moving the label to a point where it doesn’t cover a lot of data.\nlibrary(ggrepel)\rggplot(AAPLNFLX, aes(x = date, y = close, group = symbol)) +\rgeom_line() +\rgeom_label_repel(data = AAPLNFLX %\u0026gt;% group_by(symbol) %\u0026gt;% slice(100),\raes(label = symbol)) + labs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\rNow, we don’t lose a lot of space to a legend, and we haven’t had to use color to separate the stock symbols.\n\rMultiple geometries\rSince this section is about adding geometries, we can combine points and lines. Since lines connect points, it will look like a giant connect-the-dots.\nlibrary(ggrepel)\rggplot(AAPLNFLX, aes(x = date, y = close, group = symbol)) +\rgeom_line() +\rgeom_point() + geom_label_repel(data = AAPLNFLX %\u0026gt;% group_by(symbol) %\u0026gt;% slice(100),\raes(label = symbol)) + labs(x = \u0026#39;Date\u0026#39;, y = \u0026#39;Closing price\u0026#39;, title = \u0026#39;Apple and Netflix stock price\u0026#39;)\r\r\rTry it!\rTRY IT\nStart by loading the dplyr and ggplot2 library as well as the murders and heights data.\nlibrary(dplyr)\rlibrary(ggplot2)\rlibrary(dslabs)\rdata(heights)\rdata(murders)\rWith ggplot2 plots can be saved as objects. For example we can associate a dataset with a plot object like this\r\rp \u0026lt;- ggplot(data = murders)\rBecause data is the first argument we don’t need to spell it out\np \u0026lt;- ggplot(murders)\rand we can also use the pipe:\np \u0026lt;- murders %\u0026gt;% ggplot()\rWhat is class of the object p?\nRemember that to print an object you can use the command print or simply type the object.\rPrint the object p defined in exercise one and describe what you see.\r\rNothing happens.\rA blank slate plot.\rA scatterplot.\rA histogram.\r\rUsing the pipe %\u0026gt;%, create an object p but this time associated with the heights dataset instead of the murders dataset.\n\rWhat is the class of the object p you have just created?\n\rNow we are going to add a layer and the corresponding aesthetic mappings. For the murders data we plotted total murders versus population sizes. Explore the murders data frame to remind yourself what are the names for these two variables and select the correct answer. Hint: Look at ?murders.\n\r\rstate and abb.\rtotal_murders and population_size.\rtotal and population.\rmurders and size.\r\rTo create the scatterplot we add a layer with geom_point. The aesthetic mappings require us to define the x-axis and y-axis variables, respectively. So the code looks like this:\r\rmurders %\u0026gt;% ggplot(aes(x = , y = )) +\rgeom_point()\rexcept we have to define the two variables x and y. Fill this out with the correct variable names.\nNote that if we don’t use argument names, we can obtain the same plot by making sure we enter the variable names in the right order like this:\r\rmurders %\u0026gt;% ggplot(aes(population, total)) +\rgeom_point()\rRemake the plot but now with total in the x-axis and population in the y-axis.\nIf instead of points we want to add text, we can use the geom_text() or geom_label() geometries. The following code\r\rmurders %\u0026gt;% ggplot(aes(population, total)) + geom_label()\rwill give us the error message: Error: geom_label requires the following missing aesthetics: label\nWhy is this?\nWe need to map a character to each point through the label argument in aes.\rWe need to let geom_label know what character to use in the plot.\rThe geom_label geometry does not require x-axis and y-axis values.\rgeom_label is not a ggplot2 command.\r\rRewrite the code above to use abbreviation as the label through aes\n\rChange the color of the labels to blue. How will we do this?\n\r\rAdding a column called blue to murders.\rBecause each label needs a different color we map the colors through aes.\rUse the color argument in ggplot.\rBecause we want all colors to be blue, we do not need to map colors, just use the color argument in geom_label.\r\rRewrite the code above to make the labels blue.\n\rNow suppose we want to use color to represent the different regions. In this case which of the following is most appropriate:\n\r\rAdding a column called color to murders with the color we want to use.\rBecause each label needs a different color we map the colors through the color argument of aes .\rUse the color argument in ggplot.\rBecause we want all colors to be blue, we do not need to map colors, just use the color argument in geom_label.\r\rRewrite the code above to make the labels’ color be determined by the state’s region.\n\rNow we are going to change the x-axis to a log scale to account for the fact the distribution of population is skewed. Let’s start by defining an object p holding the plot we have made up to now\n\r\rp \u0026lt;- murders %\u0026gt;%\rggplot(aes(population, total, label = abb, color = region)) +\rgeom_label()\rTo change the y-axis to a log scale we learned about the scale_x_log10() function. Add this layer to the object p to change the scale and render the plot.\nRepeat the previous exercise but now change both axes to be in the log scale.\n\rNow edit the code above to add the title “Gun murder data” to the plot. Hint: use the labs function or the ggtitle function.\n\r\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661815238,"objectID":"f4445f225dbc16ad343f16f0677c881d","permalink":"https://ssc442kirkpatrick.netlify.app/content/02-content/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/content/02-content/","section":"content","summary":"Readings\r\rGuiding Questions\rStarting up\r\rScales and transformations\r\rLog transformations\rTransforming data vs. transforming using scale_...\r\rAxis labels, legends, and titles\r\rChanging axis titles\rTitles\r\rAxis ticks\rAdditional geometries\r\rgeom_line\rUsing different data with different geometries\rMultiple geometries\r\rTry it!\r\r\rReadings\r\rThis page.\r\rGuiding Questions\r\rNo guiding questions today as we’re mostly learning some technical aspects of ggplot\rWe have largely reversed our content and example lectures for data viz.","tags":null,"title":"Effective Visualizations","type":"docs"},{"authors":null,"categories":null,"content":"\r\r\rRequired Reading\r\rSupplemental Readings\rGuiding Questions\r\rLinear Models II\r\rCase study: Moneyball\r\rSabermetrics\rBaseball basics\rNo awards for BB\rBase on balls or stolen bases?\rRegression applied to baseball statistics\r\rConfounding\r\rUnderstanding confounding through stratification\rMultivariate regression\r\rLeast squares estimates\r\rInterpreting linear models\rLeast Squares Estimates (LSE)\rThe lm function\rLSE are random variables\rPredicted values are random variables\r\rLinear regression in the tidyverse\r\rThe broom package\r\rCase study: Moneyball (continued)\r\rAdding salary and position information\rPicking nine players\r\rThe regression fallacy\rMeasurement error models\r\r\r\rRequired Reading\r\rThis page.\r\rSupplemental Readings\r\r Chapter 3 in Introduction to Statistical Learning\r\r\rGuiding Questions\r\rHow do we interpret linear regression outputs?\rHow are the standard errors derived?\rWhen should we turn to linear regression versus alternative approaches?\rWhy do we use linear regression so often in data analytics?\r\rAs with recent weeks, we will work with real data during the lecture. Please download the following dataset and load it into R.\n\r Ames.csv\r\r\r\rLinear Models II\rSince Galton’s original development, regression has become one of the most widely used tools in data science. One reason has to do with the fact that regression permits us to find relationships between two variables taking into account the effects of other variables that affect both. This has been particularly popular in fields where randomized experiments are hard to run, such as economics and epidemiology.\nWhen we are not able to randomly assign each individual to a treatment or control group, confounding is particularly prevalent. For example, consider estimating the effect of eating fast foods on life expectancy using data collected from a random sample of people in a jurisdiction. Fast food consumers are more likely to be smokers, drinkers, and have lower incomes. Therefore, a naive regression model may lead to an overestimate of the negative health effect of fast food. So how do we account for confounding in practice? In this lecture we learn how linear models can help with such situations and can be used to describe how one or more variables affect an outcome variable.\nCase study: Moneyball\rMoneyball: The Art of Winning an Unfair Game is a book by Michael Lewis about the Oakland Athletics (A’s) baseball team and its general manager, the person tasked with building the team, Billy Beane.\nTraditionally, baseball teams use scouts to help them decide what players to hire. These scouts evaluate players by observing them perform. Scouts tend to favor athletic players with observable physical abilities. For this reason, scouts tend to agree on who the best players are and, as a result, these players tend to be in high demand. This in turn drives up their salaries.\nFrom 1989 to 1991, the A’s had one of the highest payrolls in baseball. They were able to buy the best players and, during that time, they were one of the best teams. However, in 1995 the A’s team owner changed and the new management cut the budget drastically, leaving then general manager, Sandy Alderson, with one of the lowest payrolls in baseball. He could no longer afford the most sought-after players. Alderson began using a statistical approach to find inefficiencies in the market. Alderson was a mentor to Billy Beane, who succeeded him in 1998 and fully embraced data science, as opposed to scouts, as a method for finding low-cost players that data predicted would help the team win. Today, this strategy has been adapted by most baseball teams. As we will see, regression plays a large role in this approach.\nAs motivation for this lecture, we will pretend it is 2002 (holy sh*t I’m old) and try to build a baseball team with a limited budget, just like the A’s had to do. To appreciate what you are up against, note that in 2002 the Yankees’ payroll of $125,928,583 more than tripled the Oakland A’s $39,679,746:\nSabermetrics\rStatistics have been used in baseball since its beginnings. The dataset we will be using, included in the Lahman library, goes back to the 19th century. For example, a summary statistic we will describe soon, the batting average, has been used for decades to summarize a batter’s success. Other statistics1 such as home runs (HR), runs batted in (RBI), and stolen bases (SB) are reported for each player in the game summaries included in the sports section of newspapers, with players rewarded for high numbers. Although summary statistics such as these were widely used in baseball, data analysis per se was not. These statistics were arbitrarily decided on without much thought as to whether they actually predicted anything or were related to helping a team win.\nThis changed with Bill James2. In the late 1970s, this aspiring writer and baseball fan started publishing articles describing more in-depth analysis of baseball data. He named the approach of using data to predict what outcomes best predicted if a team would win sabermetrics3. Until Billy Beane made sabermetrics the center of his baseball operation, Bill James’ work was mostly ignored by the baseball world. Currently, sabermetrics popularity is no longer limited to just baseball; other sports have started to use this approach as well.\nIn this lecture, to simplify the exercise, we will focus on scoring runs and ignore the two other important aspects of the game: pitching and fielding. We will see how regression analysis can help develop strategies to build a competitive baseball team with a constrained budget. The approach can be divided into two separate data analyses. In the first, we determine which recorded player-specific statistics predict runs. In the second, we examine if players were undervalued based on what our first analysis predicts.\n\rBaseball basics\rTo see how regression will help us find undervalued players, we actually don’t need to understand all the details about the game of baseball, which has over 100 rules. Here, we distill the sport to the basic knowledge one needs to know how to effectively attack the data science problem.\nThe goal of a baseball game is to score more runs (points) than the other team. Each team has 9 batters that have an opportunity to hit a ball with a bat in a predetermined order. After the 9th batter has had their turn, the first batter bats again, then the second, and so on. Each time a batter has an opportunity to bat, we call it a plate appearance (PA). At each PA, the other team’s pitcher throws the ball and the batter tries to hit it. The PA ends with an binary outcome: the batter either makes an out (failure) and returns to the bench or the batter doesn’t (success) and can run around the bases, and potentially score a run (reach all 4 bases). Each team gets nine tries, referred to as innings, to score runs and each inning ends after three outs (three failures).\nHere is a video showing a success: https://www.youtube.com/watch?v=HL-XjMCPfio. And here is one showing a failure: https://www.youtube.com/watch?v=NeloljCx-1g. In these videos, we see how luck is involved in the process. When at bat, the batter wants to hit the ball hard. If the batter hits it hard enough, it is a HR, the best possible outcome as the batter gets at least one automatic run. But sometimes, due to chance, the batter hits the ball very hard and a defender catches it, resulting in an out. In contrast, sometimes the batter hits the ball softly, but it lands just in the right place. The fact that there is chance involved hints at why probability models will be involved.\nNow there are several ways to succeed. Understanding this distinction will be important for our analysis. When the batter hits the ball, the batter wants to pass as many bases as possible. There are four bases with the fourth one called home plate. Home plate is where batters start by trying to hit, so the bases form a cycle.\n(Courtesy of Cburnett4. CC BY-SA 3.0 license5.)\rA batter who goes around the bases and arrives home, scores a run.\nWe are simplifying a bit, but there are five ways a batter can succeed, that is, not make an out:\n\rBases on balls (BB) - the pitcher fails to throw the ball through a predefined area considered to be hittable (the strikezone), so the batter is permitted to go to first base.\rSingle - Batter hits the ball and gets to first base.\rDouble (2B) - Batter hits the ball and gets to second base.\rTriple (3B) - Batter hits the ball and gets to third base.\rHome Run (HR) - Batter hits the ball and goes all the way home and scores a run.\r\rHere is an example of a HR:\rhttps://www.youtube.com/watch?v=xYxSZJ9GZ-w.\rIf a batter gets to a base, the batter still has a chance of getting home and scoring a run if the next batter hits successfully. While the batter is on base, the batter can also try to steal a base (SB). If a batter runs fast enough, the batter can try to go from one base to the next without the other team tagging the runner. [Here] is an example of a stolen base: https://www.youtube.com/watch?v=JSE5kfxkzfk.\nAll these events are kept track of during the season and are available to us through the Lahman package. Now we will start discussing how data analysis can help us decide how to use these statistics to evaluate players.\n\rNo awards for BB\rHistorically, the batting average has been considered the most important offensive statistic. To define this average, we define a hit (H) and an at bat (AB). Singles, doubles, triples, and home runs are hits. The fifth way to be successful, BB, is not a hit. An AB is the number of times you either get a hit or make an out; BBs are excluded. The batting average is simply H/AB and is considered the main measure of a success rate. Today this success rate ranges from 20% to 38%. We refer to the batting average in thousands so, for example, if your success rate is 28%, we call it batting 280.\n(Picture courtesy of Keith Allison6. CC BY-SA 2.0 license7.)\nOne of Bill James’ first important insights is that the batting average ignores BB, but a BB is a success. He proposed we use the on base percentage (OBP) instead of batting average. He defined OBP as (H+BB)/(AB+BB) which is simply the proportion of plate appearances that don’t result in an out, a very intuitive measure. He noted that a player that gets many more BB than the average player might not be recognized if the batter does not excel in batting average. But is this player not helping produce runs? No award is given to the player with the most BB. However, bad habits are hard to break and baseball did not immediately adopt OBP as an important statistic. In contrast, total stolen bases were considered important and an award8 given to the player with the most. But players with high totals of SB also made more outs as they did not always succeed. Does a player with high SB total help produce runs? Can we use data science to determine if it’s better to pay for players with high BB or SB?\n\rBase on balls or stolen bases?\rOne of the challenges in this analysis is that it is not obvious how to determine if a player produces runs because so much depends on his teammates. We do keep track of the number of runs scored by a player. However, remember that if a player X bats right before someone who hits many HRs, batter X will score many runs. But these runs don’t necessarily happen if we hire player X but not his HR hitting teammate. However, we can examine team-level statistics. How do teams with many SB compare to teams with few? How about BB? We have data! Let’s examine some.\nLet’s start with an obvious one: HRs. Do teams that hit more home runs score more runs? We examine data from 1961 to 2001. The visualization of choice when exploring the relationship between two variables, such as HRs and wins, is a scatterplot:\nlibrary(Lahman)\rTeams %\u0026gt;% filter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(HR_per_game = HR / G, R_per_game = R / G) %\u0026gt;%\rggplot(aes(HR_per_game, R_per_game)) +\rgeom_point(alpha = 0.5)\rThe plot shows a strong association: teams with more HRs tend to score more runs. Now let’s examine the relationship between stolen bases and runs:\nTeams %\u0026gt;% filter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(SB_per_game = SB / G, R_per_game = R / G) %\u0026gt;%\rggplot(aes(SB_per_game, R_per_game)) +\rgeom_point(alpha = 0.5)\rHere the relationship is not as clear. Finally, let’s examine the relationship between BB and runs:\nTeams %\u0026gt;% filter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(BB_per_game = BB/G, R_per_game = R/G) %\u0026gt;%\rggplot(aes(BB_per_game, R_per_game)) +\rgeom_point(alpha = 0.5)\rHere again we see a clear association. But does this mean that increasing a team’s BBs causes an increase in runs? One of the most important lessons you learn in this book is that association is not causation.\nIn fact, it looks like BBs and HRs are also associated:\nTeams %\u0026gt;% filter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(HR_per_game = HR/G, BB_per_game = BB/G) %\u0026gt;%\rggplot(aes(HR_per_game, BB_per_game)) +\rgeom_point(alpha = 0.5)\rWe know that HRs cause runs because, as the name “home run” implies, when a player hits a HR they are guaranteed at least one run. Could it be that HRs also cause BB and this makes it appear as if BB cause runs? When this happens we say there is confounding, an important concept we will learn more about throughout this lecture.\nLinear regression will help us parse all this out and quantify the associations. This will then help us determine what players to recruit. Specifically, we will try to predict things like how many more runs will a team score if we increase the number of BBs, but keep the HRs fixed? Regression will help us answer questions like this one.\n\rRegression applied to baseball statistics\rCan we use regression with these data? First, notice that the HR and Run data appear to be bivariate normal. We save the plot into the object p as we will use it again later.\nlibrary(Lahman)\rp \u0026lt;- Teams %\u0026gt;% filter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(HR_per_game = HR/G, R_per_game = R/G) %\u0026gt;%\rggplot(aes(HR_per_game, R_per_game)) +\rgeom_point(alpha = 0.5)\rp\rThe qq-plots confirm that the normal approximation is useful here:\nTeams %\u0026gt;% filter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(z_HR = round((HR - mean(HR))/sd(HR)),\rR_per_game = R/G) %\u0026gt;%\rfilter(z_HR %in% -2:3) %\u0026gt;%\rggplot() +\rstat_qq(aes(sample=R_per_game)) +\rfacet_wrap(~z_HR)\rNow we are ready to use linear regression to predict the number of runs a team will score if we know how many home runs the team hits. All we need to do is compute the five summary statistics:\nsummary_stats \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(HR_per_game = HR/G, R_per_game = R/G) %\u0026gt;%\rsummarize(avg_HR = mean(HR_per_game),\rs_HR = sd(HR_per_game),\ravg_R = mean(R_per_game),\rs_R = sd(R_per_game),\rr = cor(HR_per_game, R_per_game))\rsummary_stats\r## avg_HR s_HR avg_R s_R r\r## 1 0.8547104 0.2429707 4.355262 0.5885791 0.7615597\rand use the formulas given above to create the regression lines, as we did in Week 5’s Content, and adding the line to our plot p created earlier:\nreg_line \u0026lt;- summary_stats %\u0026gt;% summarize(slope = r*s_R/s_HR,\rintercept = avg_R - slope*avg_HR)\rp + geom_abline(intercept = reg_line$intercept, slope = reg_line$slope)\rFor plotting, we can also use the argument method = \"lm\" which stands for linear model, the title of an upcoming section. So we can simplify the code above like this:\np + geom_smooth(method = \u0026quot;lm\u0026quot;)\r## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39;\rAnd, for complete review, we can also use lm to run the regression, and then extract the coefficients to use in geom_abline(). Results are the same.\nreg_data = Teams %\u0026gt;% filter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(HR_per_game = HR/G, R_per_game = R/G)\rreg_lm \u0026lt;- lm(R_per_game ~ HR_per_game, reg_data)\rp + geom_abline(intercept = coefficients(reg_lm)[\u0026#39;(Intercept)\u0026#39;],\rslope = coefficients(reg_lm)[\u0026#39;HR_per_game\u0026#39;])\rIn the example above, the slope is 1.8448241. So this tells us that teams that hit 1 more HR per game than the average team, score 1.8448241 more runs per game than the average team. Given that the most common final score is a difference of a run, this can certainly lead to a large increase in wins. Not surprisingly, HR hitters are very expensive. Because we are working on a budget, we will need to find some other way to increase wins. So in the next section we move our attention to BB.\n\r\rConfounding\rPreviously, we noted a strong relationship between Runs and BB. If we find the regression line for predicting runs from bases on balls, we a get slope of:\nlibrary(tidyverse)\rlibrary(Lahman)\rget_slope \u0026lt;- function(x, y) cor(x, y) * sd(y) / sd(x)\rbb_slope \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(BB_per_game = BB/G, R_per_game = R/G) %\u0026gt;%\rsummarize(slope = get_slope(BB_per_game, R_per_game))\rbb_slope\r## slope\r## 1 0.7353288\rSo does this mean that if we go and hire low salary players with many BB, and who therefore increase the number of walks per game by 2, our team will score 1.5 more runs per game?\nWe are again reminded that association is not causation. The data does provide strong evidence that a team with two more BB per game than the average team, scores 1.5 runs per game. But this does not mean that BB are the cause.\nNote that if we compute the regression line slope for singles we get:\nsingles_slope \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(Singles_per_game = (H-HR-X2B-X3B)/G, R_per_game = R/G) %\u0026gt;%\rsummarize(slope = get_slope(Singles_per_game, R_per_game))\rsingles_slope\r## slope\r## 1 0.4494253\rwhich is a lower value than what we obtain for BB.\nAlso, notice that a single gets you to first base just like a BB. Those that know about baseball will tell you that with a single, runners on base have a better chance of scoring than with a BB. So how can BB be more predictive of runs? The reason this happen is because of confounding. Here we show the correlation between HR, BB, and singles:\nTeams %\u0026gt;%\rfilter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(Singles = (H-HR-X2B-X3B)/G, BB = BB/G, HR = HR/G) %\u0026gt;%\rsummarize(cor(BB, HR), cor(Singles, HR), cor(BB, Singles))\r## cor(BB, HR) cor(Singles, HR) cor(BB, Singles)\r## 1 0.4039313 -0.1737435 -0.05603822\rIt turns out that pitchers, afraid of HRs, will sometimes avoid throwing strikes to HR hitters. As a result, HR hitters tend to have more BBs and a team with many HRs will also have more BBs. Although it may appear that BBs cause runs, it is actually the HRs that cause most of these runs. We say that BBs are confounded with HRs. Nonetheless, could it be that BBs still help? To find out, we somehow have to adjust for the HR effect. Regression can help with this as well.\nUnderstanding confounding through stratification\rA first approach is to keep HRs fixed at a certain value and then examine the relationship between BB and runs. As we did when we stratified fathers by rounding to the closest inch, here we can stratify HR per game to the closest ten. We filter out the strata with few points to avoid highly variable estimates:\ndat \u0026lt;- Teams %\u0026gt;% filter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(HR_strata = round(HR/G, 1),\rBB_per_game = BB / G,\rR_per_game = R / G) %\u0026gt;%\rfilter(HR_strata \u0026gt;= 0.4 \u0026amp; HR_strata \u0026lt;=1.2)\rand then make a scatterplot for each strata:\ndat %\u0026gt;%\rggplot(aes(BB_per_game, R_per_game)) +\rgeom_point(alpha = 0.5) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;) +\rfacet_wrap( ~ HR_strata)\r## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39;\r# Note: we\u0026#39;ll get a \u0026quot;warning\u0026quot;\r# telling us that ggplot has\r# used lm(y ~ x) where\r# y refers to the aesthetic mapping of y\r# x refers to the aesthetic mapping of x\rRemember that the regression slope for predicting runs with BB was 0.7. Once we stratify by HR, these slopes are substantially reduced:\ndat %\u0026gt;%\rgroup_by(HR_strata) %\u0026gt;%\rsummarize(slope = get_slope(BB_per_game, R_per_game))\r## # A tibble: 9 × 2\r## HR_strata slope\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.4 0.734\r## 2 0.5 0.566\r## 3 0.6 0.412\r## 4 0.7 0.285\r## 5 0.8 0.365\r## 6 0.9 0.261\r## 7 1 0.512\r## 8 1.1 0.454\r## 9 1.2 0.440\rThe slopes are reduced, but they are not 0, which indicates that BBs are helpful for producing runs, just not as much as previously thought.\rIn fact, the values above are closer to the slope we obtained from singles, 0.45, which is more consistent with our intuition. Since both singles and BB get us to first base, they should have about the same predictive power.\nAlthough our understanding of the application tells us that HR cause BB but not the other way around, we can still check if stratifying by BB makes the effect of BB go down. To do this, we use the same code except that we swap HR and BBs to get this plot:\n## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39;\rIn this case, the slopes do not change much from the original:\ndat %\u0026gt;% group_by(BB_strata) %\u0026gt;%\rsummarize(slope = get_slope(HR_per_game, R_per_game))\r## # A tibble: 12 × 2\r## BB_strata slope\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2.8 1.52\r## 2 2.9 1.57\r## 3 3 1.52\r## 4 3.1 1.49\r## 5 3.2 1.58\r## 6 3.3 1.56\r## 7 3.4 1.48\r## 8 3.5 1.63\r## 9 3.6 1.83\r## 10 3.7 1.45\r## 11 3.8 1.70\r## 12 3.9 1.30\rThey are reduced a bit, which is consistent with the fact that BB do in fact cause some runs.\nhr_slope \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001 ) %\u0026gt;%\rmutate(HR_per_game = HR/G, R_per_game = R/G) %\u0026gt;%\rsummarize(slope = get_slope(HR_per_game, R_per_game))\rhr_slope\r## slope\r## 1 1.844824\rRegardless, it seems that if we stratify by HR, we have bivariate distributions for runs versus BB. Similarly, if we stratify by BB, we have approximate bivariate normal distributions for HR versus runs.\n\rMultivariate regression\rIt is somewhat complex to be computing regression lines for each strata. We are essentially fitting models like this:\n\\[\r\\mbox{E}[R \\mid BB = x_1, \\, HR = x_2] = \\beta_0 + \\beta_1(x_2) x_1 + \\beta_2(x_1) x_2\r\\]\nwith the slopes for \\(x_1\\) changing for different values of \\(x_2\\) and vice versa. But is there an easier approach?\nIf we take random variability into account, the slopes in the strata don’t appear to change much. If these slopes are in fact the same, this implies that \\(\\beta_1(x_2)\\) and \\(\\beta_2(x_1)\\) are constants. This in turn implies that the expectation of runs conditioned on HR and BB can be written like this:\n\\[\r\\mbox{E}[R \\mid BB = x_1, \\, HR = x_2] = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\r\\]\nThis model suggests that if the number of HR is fixed at \\(x_2\\), we observe a linear relationship between runs and BB with an intercept of \\(\\beta_0 + \\beta_2 x_2\\). Our exploratory data analysis suggested this. The model also suggests that as the number of HR grows, the intercept growth is linear as well and determined by \\(\\beta_1 x_1\\).\nIn this analysis, referred to as multivariate regression, you will often hear people say that the BB slope \\(\\beta_1\\) is adjusted for the HR effect. If the model is correct then confounding has been accounted for. But how do we estimate \\(\\beta_1\\) and \\(\\beta_2\\) from the data? For this, we learn about linear models and least squares estimates.\n\r\rLeast squares estimates\rWe have described how if data is bivariate normal then the conditional expectations follow the regression line. The fact that the conditional expectation is a line is not an extra assumption but rather a derived result. However, in practice it is common to explicitly write down a model that describes the relationship between two or more variables using a linear model.\nWe note that “linear” here does not refer to lines exclusively, but rather to the fact that the conditional expectation is a linear combination of known quantities. In mathematics, when we multiply each variable by a constant and then add them together, we say we formed a linear combination of the variables. For example, \\(3x - 4y + 5z\\) is a linear combination of \\(x\\), \\(y\\), and \\(z\\). We can also add a constant so \\(2 + 3x - 4y + 5z\\) is also linear combination of \\(x\\), \\(y\\), and \\(z\\).\nSo \\(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\\), is a linear combination of \\(x_1\\) and \\(x_2\\).\rThe simplest linear model is a constant \\(\\beta_0\\); the second simplest is a line \\(\\beta_0 + \\beta_1 x\\). If we were to specify a linear model for Galton’s data, we would denote the \\(N\\) observed father heights with \\(x_1, \\dots, x_n\\), then we model the \\(N\\) son heights we are trying to predict with:\n\\[\rY_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i, \\, i=1,\\dots,N.\r\\]\nHere \\(x_i\\) is the father’s height, which is fixed (not random) due to the conditioning, and \\(Y_i\\) is the random son’s height that we want to predict. We further assume that \\(\\varepsilon_i\\) are independent from each other, have expected value 0 and the standard deviation, call it \\(\\sigma\\), does not depend on \\(i\\).\nIn the above model, we know the \\(x_i\\), but to have a useful model for prediction, we need \\(\\beta_0\\) and \\(\\beta_1\\). We estimate these from the data. Once we do this, we can predict son’s heights for any father’s height \\(x\\). We show how to do this in the next section.\nNote that if we further assume that the \\(\\varepsilon\\) is normally distributed, then this model is exactly the same one we derived earlier by assuming bivariate normal data. A somewhat nuanced difference is that in the first approach we assumed the data was bivariate normal and that the linear model was derived, not assumed. In practice, linear models are just assumed without necessarily assuming normality: the distribution of the \\(\\varepsilon\\)s is not specified. Nevertheless, if your data is bivariate normal, the above linear model holds. If your data is not bivariate normal, then you will need to have other ways of justifying the model.\nInterpreting linear models\rOne reason linear models are popular is that they are interpretable. In the case of Galton’s data, we can interpret the data like this: due to inherited genes, the son’s height prediction grows by \\(\\beta_1\\) for each inch we increase the father’s height \\(x\\). Because not all sons with fathers of height \\(x\\) are of equal height, we need the term \\(\\varepsilon\\), which explains the remaining variability. This remaining variability includes the mother’s genetic effect, environmental factors, and other biological randomness.\nGiven how we wrote the model above, the intercept \\(\\beta_0\\) is not very interpretable as it is the predicted height of a son with a father with no height. Due to regression to the mean, the prediction will usually be a bit larger than 0. To make the slope parameter more interpretable, we can rewrite the model slightly as:\n\\[\rY_i = \\beta_0 + \\beta_1 (x_i - \\bar{x}) + \\varepsilon_i, \\, i=1,\\dots,N\r\\]\nwith \\(\\bar{x} = 1/N \\sum_{i=1}^N x_i\\) the average of the \\(x\\). In this case \\(\\beta_0\\) represents the height when \\(x_i = \\bar{x}\\), which is the height of the son of an average father.\n\rLeast Squares Estimates (LSE)\rFor linear models to be useful, we have to estimate the unknown \\(\\beta\\)s. The standard approach in science is to find the values that minimize the distance of the fitted model to the data. The following is called the least squares (LS) equation and we will see it often in this lecture. For Galton’s data, we would write:\n\\[\rRSS = \\sum_{i=1}^n \\left\\{ y_i - \\left(\\beta_0 + \\beta_1 x_i \\right)\\right\\}^2\r\\]\nThis quantity is called the residual sum of squares (RSS). Once we find the values that minimize the RSS, we will call the values the least squares estimates (LSE) and denote them with \\(\\hat{\\beta}_0\\) and \\(\\hat{\\beta}_1\\). Let’s demonstrate this with the previously defined dataset:\nlibrary(HistData)\rdata(\u0026quot;GaltonFamilies\u0026quot;)\rset.seed(1983)\rgalton_heights \u0026lt;- GaltonFamilies %\u0026gt;%\rfilter(gender == \u0026quot;male\u0026quot;) %\u0026gt;%\rgroup_by(family) %\u0026gt;%\rsample_n(1) %\u0026gt;%\rungroup() %\u0026gt;%\rselect(father, childHeight) %\u0026gt;%\rrename(son = childHeight)\rLet’s write a function that computes the RSS for any pair of values \\(\\beta_0\\) and \\(\\beta_1\\).\nrss \u0026lt;- function(beta0, beta1, data){\rresid \u0026lt;- galton_heights$son - (beta0+beta1*galton_heights$father)\rreturn(sum(resid^2))\r}\rSo for any pair of values, we get an RSS. Here is a plot of the RSS as a function of \\(\\beta_1\\) when we keep the \\(\\beta_0\\) fixed at 25.\nbeta1 = seq(0, 1, len=nrow(galton_heights))\rresults \u0026lt;- data.frame(beta1 = beta1,\rrss = sapply(beta1, rss, beta0 = 25))\rresults %\u0026gt;% ggplot(aes(beta1, rss)) + geom_line() +\rgeom_line(aes(beta1, rss))\rWe can see a clear minimum for \\(\\beta_1\\) at around 0.65. However, this minimum for \\(\\beta_1\\) is for when \\(\\beta_0 = 25\\), a value we arbitrarily picked. We don’t know if (25, 0.65) is the pair that minimizes the equation across all possible pairs.\nTrial and error is not going to work in this case. We could search for a minimum within a fine grid of \\(\\beta_0\\) and \\(\\beta_1\\) values, but this is unnecessarily time-consuming since we can use calculus: take the partial derivatives, set them to 0 and solve for \\(\\beta_1\\) and \\(\\beta_2\\). Of course, if we have many parameters, these equations can get rather complex. But there are functions in R that do these calculations for us. We will learn these next. To learn the mathematics behind this, you can consult a book on linear models.\n\rThe lm function\rWe previously used the lm function to fit a regression. This is the workhorse for linear models in R. Let’s review for a second. To fit the model:\n\\[\rY_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i\r\\]\nwith \\(Y_i\\) the son’s height and \\(x_i\\) the father’s height, we can use this code to obtain the least squares estimates.\nfit \u0026lt;- lm(son ~ father, data = galton_heights)\rfit$coef\r## (Intercept) father ## 37.287605 0.461392\rThe most common way we use lm is by using the character ~ to let lm know which is the variable we are predicting (left of ~) and which we are using to predict (right of ~). The intercept is added automatically to the model that will be fit.\nThe object fit includes more information about the fit. We can use the function summary to extract more of this information (not shown):\nsummary(fit)\r## ## Call:\r## lm(formula = son ~ father, data = galton_heights)\r## ## Residuals:\r## Min 1Q Median 3Q Max ## -9.3543 -1.5657 -0.0078 1.7263 9.4150 ## ## Coefficients:\r## Estimate Std. Error t value Pr(\u0026gt;|t|) ## (Intercept) 37.28761 4.98618 7.478 3.37e-12 ***\r## father 0.46139 0.07211 6.398 1.36e-09 ***\r## ---\r## Signif. codes: 0 \u0026#39;***\u0026#39; 0.001 \u0026#39;**\u0026#39; 0.01 \u0026#39;*\u0026#39; 0.05 \u0026#39;.\u0026#39; 0.1 \u0026#39; \u0026#39; 1\r## ## Residual standard error: 2.45 on 177 degrees of freedom\r## Multiple R-squared: 0.1878, Adjusted R-squared: 0.1833 ## F-statistic: 40.94 on 1 and 177 DF, p-value: 1.36e-09\rTo understand some of the information included in this summary we need to remember that the LSE are random variables. Mathematical statistics gives us some ideas of the distribution of these random variables\n\rLSE are random variables\rThe LSE is derived from the data \\(y_1,\\dots,y_N\\), which are a realization of random variables \\(Y_1, \\dots, Y_N\\). This implies that our estimates are random variables. To see this, we can run a Monte Carlo simulation in which we assume the son and father height data defines a population, take a random sample of size \\(N=50\\), and compute the regression slope coefficient for each one:\nB \u0026lt;- 1000\rN \u0026lt;- 50\rlse \u0026lt;- replicate(B, {\rsample_n(galton_heights, N, replace = TRUE) %\u0026gt;%\rlm(son ~ father, data = .) %\u0026gt;%\r.$coef\r})\rlse \u0026lt;- data.frame(beta_0 = lse[1,], beta_1 = lse[2,])\rWe can see the variability of the estimates by plotting their distributions:\nThe reason these look normal is because the central limit theorem applies here as well: for large enough \\(N\\), the least squares estimates will be approximately normal with expected value \\(\\beta_0\\) and \\(\\beta_1\\), respectively. The standard errors are a bit complicated to compute, but mathematical theory does allow us to compute them and they are included in the summary provided by the lm function. Here it is for one of our simulated data sets:\n sample_n(galton_heights, N, replace = TRUE) %\u0026gt;%\rlm(son ~ father, data = .) %\u0026gt;%\rsummary %\u0026gt;% .$coef\r## Estimate Std. Error t value Pr(\u0026gt;|t|)\r## (Intercept) 19.2791952 11.6564590 1.653950 0.1046637693\r## father 0.7198756 0.1693834 4.249977 0.0000979167\rYou can see that the standard errors estimates reported by the summary are close to the standard errors from the simulation:\nlse %\u0026gt;% summarize(se_0 = sd(beta_0), se_1 = sd(beta_1))\r## se_0 se_1\r## 1 8.83591 0.1278812\rThe summary function also reports t-statistics (t value) and p-values (Pr(\u0026gt;|t|)). The t-statistic is not actually based on the central limit theorem but rather on the assumption that the \\(\\varepsilon\\)s follow a normal distribution. Under this assumption, mathematical theory tells us that the LSE divided by their standard error, \\(\\hat{\\beta}_0 / \\hat{\\mbox{SE}}(\\hat{\\beta}_0 )\\) and \\(\\hat{\\beta}_1 / \\hat{\\mbox{SE}}(\\hat{\\beta}_1 )\\), follow a t-distribution with \\(N-p\\) degrees of freedom, with \\(p\\) the number of parameters in our model. In the case of height \\(p=2\\), the two p-values are testing the null hypothesis that \\(\\beta_0 = 0\\) and \\(\\beta_1=0\\), respectively.\nRemember that, as we described in the section on t-tests for large enough \\(N\\), the CLT works and the t-distribution becomes almost the same as the normal distribution. Also, notice that we can construct confidence intervals, but we will soon learn about broom, an add-on package that makes this easy.\nAlthough we do not show examples in this section, hypothesis testing with regression models is commonly used in epidemiology and economics to make statements such as “the effect of A on B was statistically significant after adjusting for X, Y, and Z”. However, several assumptions have to hold for these statements to be true.\n\rPredicted values are random variables\rOnce we fit our model, we can obtain prediction of \\(Y\\) by plugging in the estimates into the regression model. For example, if the father’s height is \\(x\\), then our prediction \\(\\hat{Y}\\) for the son’s height will be:\n\\[\\hat{Y} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x\\]\nWhen we plot \\(\\hat{Y}\\) versus \\(x\\), we see the regression line.\nKeep in mind that the prediction \\(\\hat{Y}\\) is also a random variable and mathematical theory tells us what the standard errors are. If we assume the errors are normal, or have a large enough sample size, we can use theory to construct confidence intervals as well. In fact, the ggplot2 layer geom_smooth(method = \"lm\") that we previously used plots \\(\\hat{Y}\\) and surrounds it by confidence intervals:\ngalton_heights %\u0026gt;% ggplot(aes(son, father)) +\rgeom_point() +\rgeom_smooth(method = \u0026quot;lm\u0026quot;)\rThe R function predict takes an lm object as input and returns the prediction. If requested, the standard errors and other information from which we can construct confidence intervals is provided:\nfit \u0026lt;- galton_heights %\u0026gt;% lm(son ~ father, data = .)\ry_hat \u0026lt;- predict(fit, se.fit = TRUE)\rnames(y_hat)\r## [1] \u0026quot;fit\u0026quot; \u0026quot;se.fit\u0026quot; \u0026quot;df\u0026quot; \u0026quot;residual.scale\u0026quot;\r\r\rLinear regression in the tidyverse\rTo see how we use the lm function in a more complex analysis, let’s go back to the baseball example. In a previous example, we estimated regression lines to predict runs for BB in different HR strata. We first constructed a data frame similar to this:\ndat \u0026lt;- Teams %\u0026gt;% filter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(HR = round(HR/G, 1),\rBB = BB/G,\rR = R/G) %\u0026gt;%\rselect(HR, BB, R) %\u0026gt;%\rfilter(HR \u0026gt;= 0.4 \u0026amp; HR\u0026lt;=1.2)\rSince we didn’t know the lm function, to compute the regression line in each strata, we used the formula directly like this:\nget_slope \u0026lt;- function(x, y) cor(x, y) * sd(y) / sd(x)\rdat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rsummarize(slope = get_slope(BB, R))\rWe argued that the slopes are similar and that the differences were perhaps due to random variation. To provide a more rigorous defense of the slopes being the same, which led to our multivariate model, we could compute confidence intervals for each slope. We have not learned the formula for this, but the lm function provides enough information to construct them.\nFirst, note that if we try to use the lm function to get the estimated slope like this:\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rlm(R ~ BB, data = .) %\u0026gt;% .$coef\r## (Intercept) BB ## 2.1983658 0.6378804\rwe don’t get the result we want. The lm function ignores the group_by. This is expected because lm is not part of the tidyverse and does not know how to handle the outcome of a grouped tibble.\nThe tidyverse functions know how to interpret grouped tibbles. Furthermore, to facilitate stringing commands through the pipe %\u0026gt;%, tidyverse functions consistently return data frames, since this assures that the output of a function is accepted as the input of another.\rBut most R functions do not recognize grouped tibbles nor do they return data frames. The lm function is an example. The do functions serves as a bridge between R functions, such as lm, and the tidyverse. The do function understands grouped tibbles and always returns a data frame.\nSo, let’s try to use the do function to fit a regression line to each HR strata:\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(fit = lm(R ~ BB, data = .))\r## # A tibble: 9 × 2\r## # Rowwise: ## HR fit ## \u0026lt;dbl\u0026gt; \u0026lt;list\u0026gt;\r## 1 0.4 \u0026lt;lm\u0026gt; ## 2 0.5 \u0026lt;lm\u0026gt; ## 3 0.6 \u0026lt;lm\u0026gt; ## 4 0.7 \u0026lt;lm\u0026gt; ## 5 0.8 \u0026lt;lm\u0026gt; ## 6 0.9 \u0026lt;lm\u0026gt; ## 7 1 \u0026lt;lm\u0026gt; ## 8 1.1 \u0026lt;lm\u0026gt; ## 9 1.2 \u0026lt;lm\u0026gt;\rNotice that we did in fact fit a regression line to each strata. The do function will create a data frame with the first column being the strata value and a column named fit (we chose the name, but it can be anything). The column will contain the result of the lm call. Therefore, the returned tibble has a column with lm objects, which is not very useful.\nAlso, if we do not name a column (note above we named it fit), then do will return the actual output of lm, not a data frame, and this will result in an error since do is expecting a data frame as output.\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(lm(R ~ BB, data = .))\rError: Results 1, 2, 3, 4, 5, ... must be data frames, not lm\nFor a useful data frame to be constructed, the output of the function must be a data frame too. We could build a function that returns only what we want in the form of a data frame:\nget_slope \u0026lt;- function(data){\rfit \u0026lt;- lm(R ~ BB, data = data)\rdata.frame(slope = fit$coefficients[2],\rse = summary(fit)$coefficient[2,2])\r}\rAnd then use do without naming the output, since we are already getting a data frame:\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(get_slope(.))\r## # A tibble: 9 × 3\r## # Groups: HR [9]\r## HR slope se\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.4 0.734 0.208 ## 2 0.5 0.566 0.110 ## 3 0.6 0.412 0.0974\r## 4 0.7 0.285 0.0705\r## 5 0.8 0.365 0.0653\r## 6 0.9 0.261 0.0751\r## 7 1 0.512 0.0751\r## 8 1.1 0.454 0.0855\r## 9 1.2 0.440 0.0801\rIf we name the output, then we get something we do not want, a column containing data frames:\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(slope = get_slope(.))\r## # A tibble: 9 × 2\r## # Rowwise: ## HR slope ## \u0026lt;dbl\u0026gt; \u0026lt;list\u0026gt; ## 1 0.4 \u0026lt;df [1 × 2]\u0026gt;\r## 2 0.5 \u0026lt;df [1 × 2]\u0026gt;\r## 3 0.6 \u0026lt;df [1 × 2]\u0026gt;\r## 4 0.7 \u0026lt;df [1 × 2]\u0026gt;\r## 5 0.8 \u0026lt;df [1 × 2]\u0026gt;\r## 6 0.9 \u0026lt;df [1 × 2]\u0026gt;\r## 7 1 \u0026lt;df [1 × 2]\u0026gt;\r## 8 1.1 \u0026lt;df [1 × 2]\u0026gt;\r## 9 1.2 \u0026lt;df [1 × 2]\u0026gt;\rThis is not very useful, so let’s cover one last feature of do. If the data frame being returned has more than one row, these will be concatenated appropriately. Here is an example in which we return both estimated parameters:\nget_lse \u0026lt;- function(data){\rfit \u0026lt;- lm(R ~ BB, data = data)\rdata.frame(term = names(fit$coefficients),\rslope = fit$coefficients,\rse = summary(fit)$coefficient[,2])\r}\rdat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(get_lse(.))\r## # A tibble: 18 × 4\r## # Groups: HR [9]\r## HR term slope se\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.4 (Intercept) 1.36 0.631 ## 2 0.4 BB 0.734 0.208 ## 3 0.5 (Intercept) 2.01 0.344 ## 4 0.5 BB 0.566 0.110 ## 5 0.6 (Intercept) 2.53 0.305 ## 6 0.6 BB 0.412 0.0974\r## 7 0.7 (Intercept) 3.21 0.225 ## 8 0.7 BB 0.285 0.0705\r## 9 0.8 (Intercept) 3.07 0.213 ## 10 0.8 BB 0.365 0.0653\r## 11 0.9 (Intercept) 3.54 0.251 ## 12 0.9 BB 0.261 0.0751\r## 13 1 (Intercept) 2.88 0.256 ## 14 1 BB 0.512 0.0751\r## 15 1.1 (Intercept) 3.21 0.300 ## 16 1.1 BB 0.454 0.0855\r## 17 1.2 (Intercept) 3.40 0.291 ## 18 1.2 BB 0.440 0.0801\rIf you think this is all a bit too complicated, you are not alone. To simplify things, we introduce the broom package which was designed to facilitate the use of model fitting functions, such as lm, with the tidyverse.\nThe broom package\rOur original task was to provide an estimate and confidence interval for the slope estimates of each strata. The broom package will make this quite easy.\nThe broom package has three main functions, all of which extract information from the object returned by lm and return it in a tidyverse friendly data frame. These functions are tidy, glance, and augment. The tidy function returns estimates and related information as a data frame:\nlibrary(broom)\rfit \u0026lt;- lm(R ~ BB, data = dat)\rtidy(fit)\r## # A tibble: 2 × 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) 2.20 0.113 19.4 1.12e-70\r## 2 BB 0.638 0.0344 18.5 1.35e-65\rWe can add other important summaries, such as confidence intervals:\ntidy(fit, conf.int = TRUE)\r## # A tibble: 2 × 7\r## term estimate std.error statistic p.value conf.low conf.high\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) 2.20 0.113 19.4 1.12e-70 1.98 2.42 ## 2 BB 0.638 0.0344 18.5 1.35e-65 0.570 0.705\rBecause the outcome is a data frame, we can immediately use it with do to string together the commands that produce the table we are after. Because a data frame is returned, we can filter and select the rows and columns we want, which facilitates working with ggplot2:\ndat %\u0026gt;%\rgroup_by(HR) %\u0026gt;%\rdo(tidy(lm(R ~ BB, data = .), conf.int = TRUE)) %\u0026gt;%\rfilter(term == \u0026quot;BB\u0026quot;) %\u0026gt;%\rselect(HR, estimate, conf.low, conf.high) %\u0026gt;%\rggplot(aes(HR, y = estimate, ymin = conf.low, ymax = conf.high)) +\rgeom_errorbar() +\rgeom_point()\rNow we return to discussing our original task of determining if slopes changed. The plot we just made, using do and tidy, shows that the confidence intervals overlap, which provides a nice visual confirmation that our assumption that the slope does not change is safe.\nThe other functions provided by broom, glance, and augment, relate to model-specific and observation-specific outcomes, respectively. Here, we can see the model fit summaries glance returns:\nglance(fit)\r## # A tibble: 1 × 12\r## r.squared adj.r.squa…¹ sigma stati…² p.value df logLik AIC BIC devia…³\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.266 0.265 0.454 343. 1.35e-65 1 -596. 1199. 1214. 195.\r## # … with 2 more variables: df.residual \u0026lt;int\u0026gt;, nobs \u0026lt;int\u0026gt;, and abbreviated\r## # variable names ¹​adj.r.squared, ²​statistic, ³​deviance\rYou can learn more about these summaries in any regression text book.\nWe will see an example of augment in the next section.\n\r\rCase study: Moneyball (continued)\rIn trying to answer how well BBs predict runs, data exploration led us to a model:\n\\[\r\\mbox{E}[R \\mid BB = x_1, HR = x_2] = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\r\\]\nHere, the data is approximately normal and conditional distributions were also normal. Thus, we are justified in using a linear model:\n\\[\rY_i = \\beta_0 + \\beta_1 x_{i,1} + \\beta_2 x_{i,2} + \\varepsilon_i\r\\]\nwith \\(Y_i\\) runs per game for team \\(i\\), \\(x_{i,1}\\) walks per game, and \\(x_{i,2}\\). To use lm here, we need to let the function know we have two predictor variables. So we use the + symbol as follows:\nfit \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(BB = BB/G, HR = HR/G, R = R/G) %\u0026gt;%\rlm(R ~ BB + HR, data = .)\rWe can use tidy to see a nice summary:\ntidy(fit, conf.int = TRUE)\r## # A tibble: 3 × 7\r## term estimate std.error statistic p.value conf.low conf.high\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) 1.74 0.0824 21.2 7.62e- 83 1.58 1.91 ## 2 BB 0.387 0.0270 14.3 1.20e- 42 0.334 0.440\r## 3 HR 1.56 0.0490 31.9 1.78e-155 1.47 1.66\rWhen we fit the model with only one variable, the estimated slopes were 0.7353288 and 1.8448241 for BB and HR, respectively. Note that when fitting the multivariate model both go down, with the BB effect decreasing much more.\nNow we want to construct a metric to pick players, we need to consider singles, doubles, and triples as well. Can we build a model that predicts runs based on all these outcomes?\nWe now are going to take somewhat of a “leap of faith” and assume that these five variables are jointly normal. This means that if we pick any one of them, and hold the other four fixed, the relationship with the outcome is linear and the slope does not depend on the four values held constant. If this is true, then a linear model for our data is:\n\\[\rY_i = \\beta_0 + \\beta_1 x_{i,1} + \\beta_2 x_{i,2} + \\beta_3 x_{i,3}+ \\beta_4 x_{i,4} + \\beta_5 x_{i,5} + \\varepsilon_i\r\\]\nwith \\(x_{i,1}, x_{i,2}, x_{i,3}, x_{i,4}, x_{i,5}\\) representing BB, singles, doubles, triples, and HR respectively.\nUsing lm, we can quickly find the LSE for the parameters using:\nfit \u0026lt;- Teams %\u0026gt;%\rfilter(yearID %in% 1961:2001) %\u0026gt;%\rmutate(BB = BB / G,\rsingles = (H - X2B - X3B - HR) / G,\rdoubles = X2B / G,\rtriples = X3B / G,\rHR = HR / G,\rR = R / G) %\u0026gt;%\rlm(R ~ BB + singles + doubles + triples + HR, data = .)\rWe can see the coefficients using tidy:\ncoefs \u0026lt;- tidy(fit, conf.int = TRUE)\rcoefs\r## # A tibble: 6 × 7\r## term estimate std.error statistic p.value conf.low conf.high\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) -2.77 0.0862 -32.1 4.76e-157 -2.94 -2.60 ## 2 BB 0.371 0.0117 31.6 1.87e-153 0.348 0.394\r## 3 singles 0.519 0.0127 40.8 8.67e-217 0.494 0.544\r## 4 doubles 0.771 0.0226 34.1 8.44e-171 0.727 0.816\r## 5 triples 1.24 0.0768 16.1 2.12e- 52 1.09 1.39 ## 6 HR 1.44 0.0243 59.3 0 1.40 1.49\rTo see how well our metric actually predicts runs, we can predict the number of runs for each team in 2002 using the function predict, then make a plot:\nTeams %\u0026gt;%\rfilter(yearID %in% 2002) %\u0026gt;%\rmutate(BB = BB/G,\rsingles = (H-X2B-X3B-HR)/G,\rdoubles = X2B/G,\rtriples =X3B/G,\rHR=HR/G,\rR=R/G) %\u0026gt;%\rmutate(R_hat = predict(fit, newdata = .)) %\u0026gt;%\rggplot(aes(R_hat, R, label = teamID)) +\rgeom_point() +\rgeom_text(nudge_x=0.1, cex = 2) +\rgeom_abline()\rOur model does quite a good job as demonstrated by the fact that points from the observed versus predicted plot fall close to the identity line.\nSo instead of using batting average, or just number of HR, as a measure of picking players, we can use our fitted model to form a metric that relates more directly to run production. Specifically, to define a metric for player A, we imagine a team made up of players just like player A and use our fitted regression model to predict how many runs this team would produce. The formula would look like this:\r-2.7691857 +\r0.3712147 \\(\\times\\) BB +\r0.5193923 \\(\\times\\) singles +\r0.7711444 \\(\\times\\) doubles +\r1.2399696 \\(\\times\\) triples +\r1.4433701 \\(\\times\\) HR.\nTo define a player-specific metric, we have a bit more work to do. A challenge here is that we derived the metric for teams, based on team-level summary statistics. For example, the HR value that is entered into the equation is HR per game for the entire team. If we compute the HR per game for a player, it will be much lower since the total is accumulated by 9 batters. Furthermore, if a player only plays part of the game and gets fewer opportunities than average, it is still considered a game played. For players, a rate that takes into account opportunities is the per-plate-appearance rate.\nTo make the per-game team rate comparable to the per-plate-appearance player rate, we compute the average number of team plate appearances per game:\npa_per_game \u0026lt;- Batting %\u0026gt;% filter(yearID == 2002) %\u0026gt;%\rgroup_by(teamID) %\u0026gt;%\rsummarize(pa_per_game = sum(AB+BB)/max(G)) %\u0026gt;%\rpull(pa_per_game) %\u0026gt;%\rmean\rWe compute the per-plate-appearance rates for players available in 2002 on data from 1997-2001. To avoid small sample artifacts, we filter players with less than 200 plate appearances per year. Here is the entire calculation in one line:\nplayers \u0026lt;- Batting %\u0026gt;% filter(yearID %in% 1997:2001) %\u0026gt;%\rgroup_by(playerID) %\u0026gt;%\rmutate(PA = BB + AB) %\u0026gt;%\rsummarize(G = sum(PA)/pa_per_game,\rBB = sum(BB)/G,\rsingles = sum(H-X2B-X3B-HR)/G,\rdoubles = sum(X2B)/G,\rtriples = sum(X3B)/G,\rHR = sum(HR)/G,\rAVG = sum(H)/sum(AB),\rPA = sum(PA)) %\u0026gt;%\rfilter(PA \u0026gt;= 1000) %\u0026gt;%\rselect(-G) %\u0026gt;%\rmutate(R_hat = predict(fit, newdata = .))\rThe player-specific predicted runs computed here can be interpreted as the number of runs we predict a team will score if all batters are exactly like that player. The distribution shows that there is wide variability across players:\nqplot(R_hat, data = players, binwidth = 0.5, color = I(\u0026quot;black\u0026quot;))\rAdding salary and position information\rTo actually build the team, we will need to know their salaries as well as their defensive position. For this, we join the players data frame we just created with the player information data frame included in some of the other Lahman data tables. We will learn more about the join function (and we will discuss this further in a later lecture). For now, we just need to know that a join matches a “key” field that is shared between the two datasets. Here, it is playerID.\nEach join consists of two datasets, a shared key (or keys), and a type of join. A right join takes any rows in X that match rows in Y, and all rows in Y. A left join takes all rows of X and any rows of Y that match. With left and right joins, you may end up with observations where some columns do not have data. R will give these an “NA”.\nAn inner join takes only the rows in X and Y that match, so all observations will have data. A full join takes all rows in X and Y.\nIf more than one observation in Y matches the key field in X (or vice-versa), then you can get duplicated observations. We’ll cover joins more later. For now, we’ll just use right and left joins on data we know is safe to merge.\nStart by adding the 2002 salary of each player:\nplayers \u0026lt;- Salaries %\u0026gt;%\rfilter(yearID == 2002) %\u0026gt;%\rselect(playerID, salary) %\u0026gt;%\rright_join(players, by=\u0026quot;playerID\u0026quot;)\rNext, we add their defensive position. This is a somewhat complicated task because players play more than one position each year. The Lahman package table Appearances tells how many games each player played in each position, so we can pick the position that was most played using which.max on each row. We use apply to do this. However, because some players are traded, they appear more than once on the table, so we first sum their appearances across teams.\rHere, we pick the one position the player most played using the top_n function. To make sure we only pick one position, in the case of ties, we pick the first row of the resulting data frame. We also remove the OF position which stands for outfielder, a generalization of three positions: left field (LF), center field (CF), and right field (RF). We also remove pitchers since they don’t bat in the league in which the A’s play.\nposition_names \u0026lt;-\rpaste0(\u0026quot;G_\u0026quot;, c(\u0026quot;p\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;1b\u0026quot;,\u0026quot;2b\u0026quot;,\u0026quot;3b\u0026quot;,\u0026quot;ss\u0026quot;,\u0026quot;lf\u0026quot;,\u0026quot;cf\u0026quot;,\u0026quot;rf\u0026quot;, \u0026quot;dh\u0026quot;))\rtmp \u0026lt;- Appearances %\u0026gt;%\rfilter(yearID == 2002) %\u0026gt;%\rgroup_by(playerID) %\u0026gt;%\rsummarize_at(position_names, sum) %\u0026gt;%\rungroup()\rpos \u0026lt;- tmp %\u0026gt;%\rselect(position_names) %\u0026gt;%\rapply(., 1, which.max)\r## Note: Using an external vector in selections is ambiguous.\r## ℹ Use `all_of(position_names)` instead of `position_names` to silence this message.\r## ℹ See \u0026lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html\u0026gt;.\r## This message is displayed once per session.\rplayers \u0026lt;- tibble(playerID = tmp$playerID, POS = position_names[pos]) %\u0026gt;%\rmutate(POS = str_to_upper(str_remove(POS, \u0026quot;G_\u0026quot;))) %\u0026gt;%\rfilter(POS != \u0026quot;P\u0026quot;) %\u0026gt;%\rright_join(players, by=\u0026quot;playerID\u0026quot;) %\u0026gt;%\rfilter(!is.na(POS) \u0026amp; !is.na(salary))\rFinally, we add their first and last name:\nplayers \u0026lt;- People %\u0026gt;%\rselect(playerID, nameFirst, nameLast, debut) %\u0026gt;%\rmutate(debut = as.Date(debut)) %\u0026gt;%\rright_join(players, by=\u0026quot;playerID\u0026quot;)\rIf you are a baseball fan, you will recognize the top 10 players:\nplayers %\u0026gt;% select(nameFirst, nameLast, POS, salary, R_hat) %\u0026gt;%\rarrange(desc(R_hat)) %\u0026gt;% top_n(10)\r## Selecting by R_hat\r## nameFirst nameLast POS salary R_hat\r## 1 Barry Bonds LF 15000000 8.441480\r## 2 Larry Walker RF 12666667 8.344316\r## 3 Todd Helton 1B 5000000 7.764649\r## 4 Manny Ramirez LF 15462727 7.714582\r## 5 Sammy Sosa RF 15000000 7.559582\r## 6 Jeff Bagwell 1B 11000000 7.405572\r## 7 Mike Piazza C 10571429 7.343984\r## 8 Jason Giambi 1B 10428571 7.263690\r## 9 Edgar Martinez DH 7086668 7.259399\r## 10 Jim Thome 1B 8000000 7.231955\r\rPicking nine players\rOn average, players with a higher metric have higher salaries:\nplayers %\u0026gt;% ggplot(aes(salary, R_hat, color = POS)) +\rgeom_point() +\rscale_x_log10()\r% filter(year(debut) %\rggplot(aes(salary, R_hat, color = POS)) +\rgeom_point() +\rscale_x_log10()\r```\r--\rWe can search for good deals by looking at players who produce many more runs than others with similar salaries. We can use this table to decide what players to pick and keep our total salary below the 40 million dollars Billy Beane had to work with. This can be done using what computer scientists call linear programming. This is not something we teach, but here are the position players selected with this approach:\n\r\rnameFirst\r\rnameLast\r\rPOS\r\rsalary\r\rR_hat\r\r\r\r\r\rTodd\r\rHelton\r\r1B\r\r5000000\r\r7.764649\r\r\r\rMike\r\rPiazza\r\rC\r\r10571429\r\r7.343984\r\r\r\rEdgar\r\rMartinez\r\rDH\r\r7086668\r\r7.259399\r\r\r\rJim\r\rEdmonds\r\rCF\r\r7333333\r\r6.552456\r\r\r\rJeff\r\rKent\r\r2B\r\r6000000\r\r6.391614\r\r\r\rPhil\r\rNevin\r\r3B\r\r2600000\r\r6.163936\r\r\r\rMatt\r\rStairs\r\rRF\r\r500000\r\r6.062372\r\r\r\rHenry\r\rRodriguez\r\rLF\r\r300000\r\r5.938315\r\r\r\rJohn\r\rValentin\r\rSS\r\r550000\r\r5.273441\r\r\r\r\rWe see that all these players have above average BB and most have above average HR rates, while the same is not true for singles. Here is a table with statistics standardized across players so that, for example, above average HR hitters have values above 0.\n\r\rnameLast\r\rBB\r\rsingles\r\rdoubles\r\rtriples\r\rHR\r\rAVG\r\rR_hat\r\r\r\r\r\rHelton\r\r0.9088340\r\r-0.2147828\r\r2.6489997\r\r-0.3105275\r\r1.5221254\r\r2.6704562\r\r2.5316660\r\r\r\rPiazza\r\r0.3281058\r\r0.4231217\r\r0.2037161\r\r-1.4181571\r\r1.8253653\r\r2.1990055\r\r2.0890701\r\r\r\rMartinez\r\r2.1352215\r\r-0.0051702\r\r1.2649044\r\r-1.2242578\r\r0.8079817\r\r2.2032836\r\r2.0000756\r\r\r\rEdmonds\r\r1.0706548\r\r-0.5579104\r\r0.7912381\r\r-1.1517126\r\r0.9730052\r\r0.8543566\r\r1.2562767\r\r\r\rKent\r\r0.2316321\r\r-0.7322902\r\r2.0113988\r\r0.4483097\r\r0.7658693\r\r0.7871932\r\r1.0870488\r\r\r\rNevin\r\r0.3066863\r\r-0.9051225\r\r0.4787634\r\r-1.1908955\r\r1.1927055\r\r0.1048721\r\r0.8475017\r\r\r\rStairs\r\r1.0996635\r\r-1.5127562\r\r-0.0460876\r\r-1.1285395\r\r1.1209081\r\r-0.5608456\r\r0.7406428\r\r\r\rRodriguez\r\r0.2011513\r\r-1.5963595\r\r0.3324557\r\r-0.7823620\r\r1.3202734\r\r-0.6723416\r\r0.6101181\r\r\r\rValentin\r\r0.1802855\r\r-0.9287069\r\r1.7940379\r\r-0.4348410\r\r-0.0452462\r\r-0.4717038\r\r-0.0894187\r\r\r\r\r\r\rThe regression fallacy\rWikipedia defines the sophomore slump as:\n\rA sophomore slump or sophomore jinx or sophomore jitters refers to an instance in which a second, or sophomore, effort fails to live up to the standards of the first effort. It is commonly used to refer to the apathy of students (second year of high school, college or university), the performance of athletes (second season of play), singers/bands (second album), television shows (second seasons) and movies (sequels/prequels).\n\rIn Major League Baseball, the rookie of the year (ROY) award is given to the first-year player who is judged to have performed the best. The sophmore slump phrase is used to describe the observation that ROY award winners don’t do as well during their second year. For example, this Fox Sports article9 asks “Will MLB’s tremendous rookie class of 2015 suffer a sophomore slump?”.\nDoes the data confirm the existence of a sophomore slump? Let’s take a look. Examining the data for batting average, we see that this observation holds true for the top performing ROYs:\n\r\rnameFirst\r\rnameLast\r\rrookie_year\r\rrookie\r\rsophomore\r\r\r\r\r\rWillie\r\rMcCovey\r\r1959\r\r0.3541667\r\r0.2384615\r\r\r\rIchiro\r\rSuzuki\r\r2001\r\r0.3497110\r\r0.3214838\r\r\r\rAl\r\rBumbry\r\r1973\r\r0.3370787\r\r0.2333333\r\r\r\rFred\r\rLynn\r\r1975\r\r0.3314394\r\r0.3136095\r\r\r\rAlbert\r\rPujols\r\r2001\r\r0.3288136\r\r0.3135593\r\r\r\r\rIn fact, the proportion of players that have a lower batting average their sophomore year is 0.6981132.\nSo is it “jitters” or “jinx”? To answer this question, let’s turn our attention to all players that played the 2013 and 2014 seasons and batted more than 130 times (minimum to win Rookie of the Year).\nThe same pattern arises when we look at the top performers: batting averages go down for most of the top performers.\n\r\rnameFirst\r\rnameLast\r\r2013\r\r2014\r\r\r\r\r\rMiguel\r\rCabrera\r\r0.3477477\r\r0.3126023\r\r\r\rHanley\r\rRamirez\r\r0.3453947\r\r0.2828508\r\r\r\rMichael\r\rCuddyer\r\r0.3312883\r\r0.3315789\r\r\r\rScooter\r\rGennett\r\r0.3239437\r\r0.2886364\r\r\r\rJoe\r\rMauer\r\r0.3235955\r\r0.2769231\r\r\r\r\rBut these are not rookies! Also, look at what happens to the worst performers of 2013:\n\r\rnameFirst\r\rnameLast\r\r2013\r\r2014\r\r\r\r\r\rDanny\r\rEspinosa\r\r0.1582278\r\r0.2192192\r\r\r\rDan\r\rUggla\r\r0.1785714\r\r0.1489362\r\r\r\rJeff\r\rMathis\r\r0.1810345\r\r0.2000000\r\r\r\rB. J.\r\rUpton\r\r0.1841432\r\r0.2080925\r\r\r\rAdam\r\rRosales\r\r0.1904762\r\r0.2621951\r\r\r\r\rTheir batting averages mostly go up! Is this some sort of reverse sophomore slump? It is not. There is no such thing as the sophomore slump. This is all explained with a simple statistical fact: the correlation for performance in two separate years is high, but not perfect:\nThe correlation is 0.460254 and\rthe data look very much like a bivariate normal distribution, which means we predict a 2014 batting average \\(Y\\) for any given player that had a 2013 batting average \\(X\\) with:\n\\[ \\frac{Y - .255}{.032} = 0.46 \\left( \\frac{X - .261}{.023}\\right) \\]\nBecause the correlation is not perfect, regression tells us that, on average, expect high performers from 2013 to do a bit worse in 2014. It’s not a jinx; it’s just due to chance. The ROY are selected from the top values of \\(X\\) so it is expected that \\(Y\\) will regress to the mean.\n\rMeasurement error models\rUp to now, all our linear regression examples have been applied to two or more random variables. We assume the pairs are bivariate normal and use this to motivate a linear model. This approach covers most real-life examples of linear regression. The other major application comes from measurement errors models. In these applications, it is common to have a non-random covariate, such as time, and randomness is introduced from measurement error rather than sampling or natural variability.\nTo understand these models, imagine you are Galileo in the 16th century trying to describe the velocity of a falling object. An assistant climbs the Tower of Pisa and drops a ball, while several other assistants record the position at different times. Let’s simulate some data using the equations we know today and adding some measurement error. The dslabs function rfalling_object generates these simulations:\nlibrary(dslabs)\rfalling_object \u0026lt;- rfalling_object()\rThe assistants hand the data to Galileo and this is what he sees:\nfalling_object %\u0026gt;%\rggplot(aes(time, observed_distance)) +\rgeom_point() +\rylab(\u0026quot;Distance in meters\u0026quot;) +\rxlab(\u0026quot;Time in seconds\u0026quot;)\rGalileo does not know the exact equation, but by looking at the plot above, he deduces that the position should follow a parabola, which we can write like this:\n\\[ f(x) = \\beta_0 + \\beta_1 x + \\beta_2 x^2\\]\nThe data does not fall exactly on a parabola. Galileo knows this is due to measurement error. His helpers make mistakes when measuring the distance. To account for this, he models the data with:\n\\[ Y_i = \\beta_0 + \\beta_1 x_i + \\beta_2 x_i^2 + \\varepsilon_i, i=1,\\dots,n \\]\nwith \\(Y_i\\) representing distance in meters, \\(x_i\\) representing time in seconds, and \\(\\varepsilon\\) accounting for measurement error. The measurement error is assumed to be random, independent from each other, and having the same distribution for each \\(i\\). We also assume that there is no bias, which means the expected value \\(\\mbox{E}[\\varepsilon] = 0\\).\nNote that this is a linear model because it is a linear combination of known quantities (\\(x\\) and \\(x^2\\) are known) and unknown parameters (the \\(\\beta\\)s are unknown parameters to Galileo). Unlike our previous examples, here \\(x\\) is a fixed quantity; we are not conditioning.\nTo pose a new physical theory and start making predictions about other falling objects, Galileo needs actual numbers, rather than unknown parameters. Using LSE seems like a reasonable approach. How do we find the LSE?\nLSE calculations do not require the errors to be approximately normal. The lm function will find the \\(\\beta\\) s that will minimize the residual sum of squares:\nfit \u0026lt;- falling_object %\u0026gt;%\rmutate(time_sq = time^2) %\u0026gt;%\rlm(observed_distance~time+time_sq, data=.)\rtidy(fit)\r## # A tibble: 3 × 5\r## term estimate std.error statistic p.value\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) 56.1 0.592 94.9 2.23e-17\r## 2 time -0.786 0.845 -0.930 3.72e- 1\r## 3 time_sq -4.53 0.251 -18.1 1.58e- 9\rLet’s check if the estimated parabola fits the data. The broom function augment lets us do this easily:\naugment(fit) %\u0026gt;%\rggplot() +\rgeom_point(aes(time, observed_distance)) +\rgeom_line(aes(time, .fitted), col = \u0026quot;blue\u0026quot;)\rThanks to my high school physics teacher, I know that the equation for the trajectory of a falling object is:\n\\[d = h_0 + v_0 t - 0.5 \\times 9.8 t^2\\]\nwith \\(h_0\\) and \\(v_0\\) the starting height and velocity, respectively. The data we simulated above followed this equation and added measurement error to simulate n observations for dropping the ball \\((v_0=0)\\) from the tower of Pisa \\((h_0=55.86)\\).\nThese are consistent with the parameter estimates:\ntidy(fit, conf.int = TRUE)\r## # A tibble: 3 × 7\r## term estimate std.error statistic p.value conf.low conf.high\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 (Intercept) 56.1 0.592 94.9 2.23e-17 54.8 57.4 ## 2 time -0.786 0.845 -0.930 3.72e- 1 -2.65 1.07\r## 3 time_sq -4.53 0.251 -18.1 1.58e- 9 -5.08 -3.98\rThe Tower of Pisa height is within the confidence interval for \\(\\beta_0\\), the initial velocity 0 is in the confidence interval for \\(\\beta_1\\) (note the p-value is larger than 0.05), and the acceleration constant is in a confidence interval for \\(-2 \\times \\beta_2\\).\nTRY IT\nSince the 1980s, sabermetricians have used a summary statistic different from batting average to evaluate players. They realized walks were important and that doubles, triples, and HRs, should be weighed more than singles. As a result, they proposed the following metric:\n\\[\r\\frac{\\mbox{BB}}{\\mbox{PA}} + \\frac{\\mbox{Singles} + 2 \\mbox{Doubles} + 3 \\mbox{Triples} + 4\\mbox{HR}}{\\mbox{AB}}\r\\]\nThey called this on-base-percentage plus slugging percentage (OPS). Although the sabermetricians probably did not use regression, here we show how this metric is close to what one gets with regression.\nCompute the OPS for each team in the 2001 season. Then plot Runs per game versus OPS.\n\rFor every year since 1961, compute the correlation between runs per game and OPS; then plot these correlations as a function of year.\n\rNote that we can rewrite OPS as a weighted average of BBs, singles, doubles, triples, and HRs. We know that the weights for doubles, triples, and HRs are 2, 3, and 4 times that of singles. But what about BB? What is the weight for BB relative to singles? Hint: the weight for BB relative to singles will be a function of AB and PA.\n\rNote that the weight for BB, \\(\\frac{\\mbox{AB}}{\\mbox{PA}}\\), will change from team to team. To see how variable it is, compute and plot this quantity for each team for each year since 1961. Then plot it again, but instead of computing it for every team, compute and plot the ratio for the entire year. Then, once you are convinced that there is not much of a time or team trend, report the overall average.\n\rSo now we know that the formula for OPS is proportional to \\(0.91 \\times \\mbox{BB} + \\mbox{singles} + 2 \\times \\mbox{doubles} + 3 \\times \\mbox{triples} + 4 \\times \\mbox{HR}\\). Let’s see how these coefficients compare to those obtained with regression. Fit a regression model to the data after 1961, as done earlier: using per game statistics for each year for each team. After fitting this model, report the coefficients as weights relative to the coefficient for singles.\n\rWe see that our linear regression model coefficients follow the same general trend as those used by OPS, but with slightly less weight for metrics other than singles. For each team in years after 1961, compute the OPS, the predicted runs with the regression model and compute the correlation between the two as well as the correlation with runs per game.\n\r\r\r\r\r\rhttp://mlb.mlb.com/stats/league_leaders.jsp↩︎\n\rhttps://en.wikipedia.org/wiki/Bill_James↩︎\n\rhttps://en.wikipedia.org/wiki/Sabermetrics↩︎\n\rhttps://en.wikipedia.org/wiki/User:Cburnett↩︎\n\rhttps://creativecommons.org/licenses/by-sa/3.0/deed.en↩︎\n\rhttps://www.flickr.com/people/27003603@N00↩︎\n\rhttps://creativecommons.org/licenses/by-sa/2.0↩︎\n\rhttp://www.baseball-almanac.com/awards/lou_brock_award.shtml↩︎\n\rhttp://www.foxsports.com/mlb/story/kris-bryant-carlos-correa-rookies-of-year-award-matt-duffy-francisco-lindor-kang-sano-120715↩︎\n\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661170210,"objectID":"4fb51266c58f677bf1e1454e5cd9c527","permalink":"https://ssc442kirkpatrick.netlify.app/content/06-content/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/content/06-content/","section":"content","summary":"Required Reading\r\rSupplemental Readings\rGuiding Questions\r\rLinear Models II\r\rCase study: Moneyball\r\rSabermetrics\rBaseball basics\rNo awards for BB\rBase on balls or stolen bases?\rRegression applied to baseball statistics\r\rConfounding\r\rUnderstanding confounding through stratification\rMultivariate regression\r\rLeast squares estimates\r\rInterpreting linear models\rLeast Squares Estimates (LSE)\rThe lm function\rLSE are random variables\rPredicted values are random variables\r\rLinear regression in the tidyverse\r\rThe broom package\r\rCase study: Moneyball (continued)\r\rAdding salary and position information\rPicking nine players\r\rThe regression fallacy\rMeasurement error models\r\r\r\rRequired Reading\r\rThis page.","tags":null,"title":"Linear Regression II","type":"docs"},{"authors":null,"categories":null,"content":"\rBelow is a roadmap for the semester. Note that this will inevitably change from the first day you access this course. However, whatever is listed below should be considered canon. Accordingly, you should visit this page frequently throughout the term.\nAs mentioned in the syllabus, the course is structured by topics; each week introduces a new topic. Moreover, every week is divided into three important sections that you should engage with.\nOverview\rThe class is structured with three distinct bits. First, the Tuesday lecture will give an overview of the topic for the week. Next, the Thursday lecture will have a short, practical lecture and an activity which is designed to give you hands-on experience and a greater understanding of the broader material. Finally, you will complete weekly writings (short) and labs (also short; requiring coding in R). Out of class, you will complete readings and complete assignments.\n\rContent (): This page contains the readings for the topic. These pages should be read completely. Lectures are not an exact replication of the written content; on the contrary, the lectures are intended to keep you focused on the high-level ideas, while the readings are broader and more comprehensive. Accordingly, lectures are shorter than the (often quite lengthy) written content.\n\rExamples (): This page the material that we will discuss in Thursday classes. In addition to teaching specific content, there are many more R code examples. These are intended as a useful reference to various functions that you will need when working on (nearly) weekly labs and your group project.\n\rAssignments (): This page contains the instructions for the weekly lab (1–3 brief tasks) and for the two mini projects + final project. Labs are due by 11:59 PM (Eastern) on the Monday after they’re posted.\n\r\r\rOffice Hours (TA) Monday (time TBA, 1.5 hours in morning) via Zoom\rThe teaching assistant for this course (Sam Tucker; tucke130@msu.edu) will host office each week to help promote additional understanding. I highly encourage you to utilize this resource, especially if you struggle with basic R programming.\n\rProf. K’s Office Hours Wednesdays 2:00 pm to 3:00 pm via Zoom passcode: DATA\rI will hold weekly drop-in office hours on Wednesdays from 2-3pm and via appointment (just ask!). I will be in the Zoom Room from 2-3 pm, but will stay later if and only if someone is there or you have emailed me beforehand to let me know you’re planning on coming later. Drop-in office hours are time set aside for you to ask questions about the material, the course, the topic, or about life in general. They are a great resource and most faculty are bewildered when students don’t use them.\nAll office hours are via Zoom as questions will often (but don’t always) center around coding and sharing a screen in Zoom is pretty easy. Both the TA and Prof. K will monitor the course slack for questions as well.\ntl;dr: You should follow this general process (in order) each week:\n\rDo everything on the content () page before Tuesday\rCome to the lecture on Tuesday.\rWhile “in class” on Thursday, work through the example () page\rComplete the lab () and the weekly writing (assigned in class) before the next Tuesday.\rAs needed, attend the lab hours hosted by the TA.\r\r\r\r\r\rProgramming Foundations\rContent\rExample\rAssignment\r\r\rWeek 0 (Sep 1)\r(Re-) Introduction to R\r\r\r\r\r\rWeek 1 (Sep 6/8)\rProgramming Basics, the tidyverse, and Visualization\r\r\r\r\r\rWeek 2 (Sep 13/15)\rVisualization II\r\r\r\r\r\rWeek 3 (Sep 20/22)\rVisualization III\r\r\r\r\r\r\rData Analysis Foundations\rContent\rExample\rAssignment\r\r\rWeek 4 (Sep 27/29)\rUncertainty and Probability in R\r\r\r\r\r\rWeek 5 (Oct 4/6)\rLinear Regression I\r\r\r\r\r\rWeek 6 (Oct 11/13)\rLinear Regression II\r\r\r\r\r\rSaturday Oct 15th\r Project 1 Due\r\r\r\r\r\r\r\rWeek 7 (Oct 18/20)\rLinear Regression III\r\r\r\r\r\r\rApplications of Data Analysis\rContent\rExample\rAssignment\r\r\rWeek 8 (Oct -25/27)\rLASSO: Least Absolute Shrinkage and Selection\r\r\r\r\r\r\rWeek 9 (Nov 1/3)\rNonlinear Regression\r\r\r\r\r\rWeek 10 (Nov 8/10)\rBias vs Variance\r\r\r\r\r\r\rWeek 11 (Nov 15/17)\rClassification\r\r\r\r\r\rSaturday Nov 19th\r Project 2 Due\r\r\r\r\r\r\r\r\rFurther Extensions\rContent\rExample\rAssignment\r\r\rWeek 12 (Nov 22/-24)\rText as Data\r\r\r\r\r\r\rWeek 13 (Nov 29/Dec 1)\rWrangling Data\r\r\r\r\r\rWeek 14 (Dec 6/8)\rGeospatial in R\r\r\r\r\r\r\r\rConclusions\rContent\rExample\rAssignment\r\r\rFriday Dec 11th, 11:59pm\r Final Project Due\r\r\r\r\r\r\r\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661815619,"objectID":"3e223d7ba58b0122b42458e4cf52e04c","permalink":"https://ssc442kirkpatrick.netlify.app/schedule/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/schedule/","section":"","summary":"Below is a roadmap for the semester. Note that this will inevitably change from the first day you access this course. However, whatever is listed below should be considered canon. Accordingly, you should visit this page frequently throughout the term.\nAs mentioned in the syllabus, the course is structured by topics; each week introduces a new topic. Moreover, every week is divided into three important sections that you should engage with.","tags":null,"title":"Schedule","type":"page"}]